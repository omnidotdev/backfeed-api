// @ts-nocheck
import { PgBooleanFilterStep, PgConditionStep, PgDeleteSingleStep, PgExecutor, PgOrFilterStep, PgSelectStep, PgUnionAllStep, TYPES, assertPgClassSingleStep, enumCodec, listOfCodec, makeRegistry, pgDeleteSingle, pgInsertSingle, pgSelectFromRecord, pgUpdateSingle, pgWhereConditionSpecListToSQL, recordCodec } from "@dataplan/pg";
import { and, eq } from "drizzle-orm";
import { ConnectionStep, EdgeStep, ExecutableStep, ModifierStep, ObjectStep, SafeError, __ValueStep, assertEdgeCapableStep, assertExecutableStep, assertPageInfoCapableStep, connection, constant, context, first, getEnumValueConfig, isExecutableStep, lambda, makeGrafastSchema, node, object, rootValue, sideEffect } from "grafast";
import { GraphQLEnumType, GraphQLError, Kind } from "graphql";
import * as lib_drizzle_schema from "lib/drizzle/schema";
import { sql } from "pg-sql2";
import { inspect } from "util";
const handler = {
  typeName: "Query",
  codec: {
    name: "raw",
    encode: Object.assign(function rawEncode(value) {
      return typeof value === "string" ? value : null;
    }, {
      isSyncAndSafe: true
    }),
    decode: Object.assign(function rawDecode(value) {
      return typeof value === "string" ? value : null;
    }, {
      isSyncAndSafe: true
    })
  },
  match(specifier) {
    return specifier === "query";
  },
  getSpec() {
    return "irrelevant";
  },
  get() {
    return rootValue();
  },
  plan() {
    return constant`query`;
  }
};
const nodeIdCodecs = Object.assign(Object.create(null), {
  raw: handler.codec,
  base64JSON: {
    name: "base64JSON",
    encode: (() => {
      function base64JSONEncode(value) {
        return Buffer.from(JSON.stringify(value), "utf8").toString("base64");
      }
      base64JSONEncode.isSyncAndSafe = !0;
      return base64JSONEncode;
    })(),
    decode: (() => {
      function base64JSONDecode(value) {
        return JSON.parse(Buffer.from(value, "base64").toString("utf8"));
      }
      base64JSONDecode.isSyncAndSafe = !0;
      return base64JSONDecode;
    })()
  },
  pipeString: {
    name: "pipeString",
    encode: Object.assign(function pipeStringEncode(value) {
      return Array.isArray(value) ? value.join("|") : null;
    }, {
      isSyncAndSafe: true
    }),
    decode: Object.assign(function pipeStringDecode(value) {
      return typeof value === "string" ? value.split("|") : null;
    }, {
      isSyncAndSafe: true
    })
  }
});
const nodeIdHandlerByTypeName = Object.assign(Object.create(null), {
  Query: handler
});
const executor = new PgExecutor({
  name: "main",
  context() {
    const ctx = context();
    return object({
      pgSettings: "pgSettings" != null ? ctx.get("pgSettings") : constant(null),
      withPgClient: ctx.get("withPgClient")
    });
  }
});
const downvoteIdentifier = sql.identifier("public", "downvote");
const spec_downvote = {
  name: "downvote",
  identifier: downvoteIdentifier,
  attributes: Object.assign(Object.create(null), {
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    post_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  }),
  description: undefined,
  extensions: {
    oid: "58083",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "downvote"
    },
    tags: Object.create(null)
  },
  executor: executor
};
const downvoteCodec = recordCodec(spec_downvote);
const upvoteIdentifier = sql.identifier("public", "upvote");
const spec_upvote = {
  name: "upvote",
  identifier: upvoteIdentifier,
  attributes: Object.assign(Object.create(null), {
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    post_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  }),
  description: undefined,
  extensions: {
    oid: "57996",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "upvote"
    },
    tags: Object.create(null)
  },
  executor: executor
};
const upvoteCodec = recordCodec(spec_upvote);
const invitationIdentifier = sql.identifier("public", "invitation");
const spec_invitation = {
  name: "invitation",
  identifier: invitationIdentifier,
  attributes: Object.assign(Object.create(null), {
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    email: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  }),
  description: undefined,
  extensions: {
    oid: "58183",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "invitation"
    },
    tags: Object.create(null)
  },
  executor: executor
};
const invitationCodec = recordCodec(spec_invitation);
const organizationIdentifier = sql.identifier("public", "organization");
const spec_organization = {
  name: "organization",
  identifier: organizationIdentifier,
  attributes: Object.assign(Object.create(null), {
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    name: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    slug: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  }),
  description: undefined,
  extensions: {
    oid: "57958",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "organization"
    },
    tags: Object.create(null)
  },
  executor: executor
};
const organizationCodec = recordCodec(spec_organization);
const commentIdentifier = sql.identifier("public", "comment");
const spec_comment = {
  name: "comment",
  identifier: commentIdentifier,
  attributes: Object.assign(Object.create(null), {
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    message: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    post_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  }),
  description: undefined,
  extensions: {
    oid: "58063",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "comment"
    },
    tags: Object.create(null)
  },
  executor: executor
};
const commentCodec = recordCodec(spec_comment);
const memberIdentifier = sql.identifier("public", "member");
const roleCodec = enumCodec({
  name: "role",
  identifier: sql.identifier("public", "role"),
  values: ["owner", "admin", "member"],
  description: undefined,
  extensions: {
    oid: "58102",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "role"
    },
    tags: Object.create(null)
  }
});
const spec_member = {
  name: "member",
  identifier: memberIdentifier,
  attributes: Object.assign(Object.create(null), {
    user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    role: {
      description: undefined,
      codec: roleCodec,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  }),
  description: undefined,
  extensions: {
    oid: "58018",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "member"
    },
    tags: Object.create(null)
  },
  executor: executor
};
const memberCodec = recordCodec(spec_member);
const postIdentifier = sql.identifier("public", "post");
const spec_post = {
  name: "post",
  identifier: postIdentifier,
  attributes: Object.assign(Object.create(null), {
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    title: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    project_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    status_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    status_updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  }),
  description: undefined,
  extensions: {
    oid: "57972",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "post"
    },
    tags: Object.create(null)
  },
  executor: executor
};
const postCodec = recordCodec(spec_post);
const postStatusIdentifier = sql.identifier("public", "post_status");
const spec_postStatus = {
  name: "postStatus",
  identifier: postStatusIdentifier,
  attributes: Object.assign(Object.create(null), {
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    status: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    color: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    project_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    is_default: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  }),
  description: undefined,
  extensions: {
    oid: "58157",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "post_status"
    },
    tags: Object.create(null)
  },
  executor: executor
};
const postStatusCodec = recordCodec(spec_postStatus);
const projectIdentifier = sql.identifier("public", "project");
const spec_project = {
  name: "project",
  identifier: projectIdentifier,
  attributes: Object.assign(Object.create(null), {
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    name: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    image: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    slug: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  }),
  description: undefined,
  extensions: {
    oid: "57982",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "project"
    },
    tags: Object.create(null)
  },
  executor: executor
};
const projectCodec = recordCodec(spec_project);
const userIdentifier = sql.identifier("public", "user");
const spec_user = {
  name: "user",
  identifier: userIdentifier,
  attributes: Object.assign(Object.create(null), {
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    hidra_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    username: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    first_name: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    last_name: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    email: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  }),
  description: undefined,
  extensions: {
    oid: "58006",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "user"
    },
    tags: Object.create(null)
  },
  executor: executor
};
const userCodec = recordCodec(spec_user);
const downvoteUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["post_id", "user_id"],
  description: undefined,
  extensions: {
    tags: Object.assign(Object.create(null), {
      behavior: ["-update", "-delete"]
    })
  }
}];
const registryConfig_pgResources_downvote_downvote = {
  executor: executor,
  name: "downvote",
  identifier: "main.public.downvote",
  from: downvoteIdentifier,
  codec: downvoteCodec,
  uniques: downvoteUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "downvote"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const upvoteUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["post_id", "user_id"],
  description: undefined,
  extensions: {
    tags: Object.assign(Object.create(null), {
      behavior: ["-update", "-delete"]
    })
  }
}];
const registryConfig_pgResources_upvote_upvote = {
  executor: executor,
  name: "upvote",
  identifier: "main.public.upvote",
  from: upvoteIdentifier,
  codec: upvoteCodec,
  uniques: upvoteUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "upvote"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const invitationUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["email"],
  description: undefined,
  extensions: {
    tags: Object.assign(Object.create(null), {
      behavior: ["-update", "-delete"]
    })
  }
}];
const registryConfig_pgResources_invitation_invitation = {
  executor: executor,
  name: "invitation",
  identifier: "main.public.invitation",
  from: invitationIdentifier,
  codec: invitationCodec,
  uniques: invitationUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "invitation"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const organizationUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["name"],
  description: undefined,
  extensions: {
    tags: Object.assign(Object.create(null), {
      behavior: ["-update", "-delete"]
    })
  }
}, {
  isPrimary: false,
  attributes: ["slug"],
  description: undefined,
  extensions: {
    tags: Object.assign(Object.create(null), {
      behavior: ["-update", "-delete"]
    })
  }
}];
const registryConfig_pgResources_organization_organization = {
  executor: executor,
  name: "organization",
  identifier: "main.public.organization",
  from: organizationIdentifier,
  codec: organizationCodec,
  uniques: organizationUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "organization"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const commentUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_comment_comment = {
  executor: executor,
  name: "comment",
  identifier: "main.public.comment",
  from: commentIdentifier,
  codec: commentCodec,
  uniques: commentUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "comment"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const projectUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["name"],
  description: undefined,
  extensions: {
    tags: Object.assign(Object.create(null), {
      behavior: ["-update", "-delete"]
    })
  }
}, {
  isPrimary: false,
  attributes: ["slug", "organization_id"],
  description: undefined,
  extensions: {
    tags: Object.assign(Object.create(null), {
      behavior: ["-update", "-delete"]
    })
  }
}];
const registryConfig_pgResources_project_project = {
  executor: executor,
  name: "project",
  identifier: "main.public.project",
  from: projectIdentifier,
  codec: projectCodec,
  uniques: projectUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "project"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const userUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["email"],
  description: undefined,
  extensions: {
    tags: Object.assign(Object.create(null), {
      behavior: ["-update", "-delete"]
    })
  }
}, {
  isPrimary: false,
  attributes: ["hidra_id"],
  description: undefined,
  extensions: {
    tags: Object.assign(Object.create(null), {
      behavior: ["-update", "-delete"]
    })
  }
}, {
  isPrimary: false,
  attributes: ["username"],
  description: undefined,
  extensions: {
    tags: Object.assign(Object.create(null), {
      behavior: ["-update", "-delete"]
    })
  }
}];
const registryConfig_pgResources_user_user = {
  executor: executor,
  name: "user",
  identifier: "main.public.user",
  from: userIdentifier,
  codec: userCodec,
  uniques: userUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "user"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const memberUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}, {
  isPrimary: false,
  attributes: ["user_id", "organization_id"],
  description: undefined,
  extensions: {
    tags: Object.assign(Object.create(null), {
      behavior: ["-update", "-delete"]
    })
  }
}];
const registryConfig_pgResources_member_member = {
  executor: executor,
  name: "member",
  identifier: "main.public.member",
  from: memberIdentifier,
  codec: memberCodec,
  uniques: memberUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "member"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const postUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_post_post = {
  executor: executor,
  name: "post",
  identifier: "main.public.post",
  from: postIdentifier,
  codec: postCodec,
  uniques: postUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "post"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const post_statusUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: Object.create(null)
  }
}];
const registryConfig_pgResources_post_status_post_status = {
  executor: executor,
  name: "post_status",
  identifier: "main.public.post_status",
  from: postStatusIdentifier,
  codec: postStatusCodec,
  uniques: post_statusUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "post_status"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const registryConfig = {
  pgExecutors: Object.assign(Object.create(null), {
    main: executor
  }),
  pgCodecs: Object.assign(Object.create(null), {
    downvote: downvoteCodec,
    uuid: TYPES.uuid,
    timestamptz: TYPES.timestamptz,
    upvote: upvoteCodec,
    invitation: invitationCodec,
    text: TYPES.text,
    organization: organizationCodec,
    comment: commentCodec,
    member: memberCodec,
    role: roleCodec,
    post: postCodec,
    postStatus: postStatusCodec,
    bool: TYPES.boolean,
    project: projectCodec,
    user: userCodec
  }),
  pgResources: Object.assign(Object.create(null), {
    downvote: registryConfig_pgResources_downvote_downvote,
    upvote: registryConfig_pgResources_upvote_upvote,
    invitation: registryConfig_pgResources_invitation_invitation,
    organization: registryConfig_pgResources_organization_organization,
    comment: registryConfig_pgResources_comment_comment,
    project: registryConfig_pgResources_project_project,
    user: registryConfig_pgResources_user_user,
    member: registryConfig_pgResources_member_member,
    post: registryConfig_pgResources_post_post,
    post_status: registryConfig_pgResources_post_status_post_status
  }),
  pgRelations: Object.assign(Object.create(null), {
    comment: Object.assign(Object.create(null), {
      postByMyPostId: {
        localCodec: commentCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["post_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyUserId: {
        localCodec: commentCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    downvote: Object.assign(Object.create(null), {
      postByMyPostId: {
        localCodec: downvoteCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["post_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyUserId: {
        localCodec: downvoteCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    invitation: Object.assign(Object.create(null), {
      organizationByMyOrganizationId: {
        localCodec: invitationCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    member: Object.assign(Object.create(null), {
      organizationByMyOrganizationId: {
        localCodec: memberCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyUserId: {
        localCodec: memberCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    organization: Object.assign(Object.create(null), {
      projectsByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_project_project,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      membersByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_member_member,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      invitationsByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_invitation_invitation,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    post: Object.assign(Object.create(null), {
      projectByMyProjectId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_project_project,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["project_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      postStatusByMyStatusId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_post_status_post_status,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["status_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyUserId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      upvotesByTheirPostId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_upvote_upvote,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["post_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      commentsByTheirPostId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_comment_comment,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["post_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      downvotesByTheirPostId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_downvote_downvote,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["post_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    postStatus: Object.assign(Object.create(null), {
      projectByMyProjectId: {
        localCodec: postStatusCodec,
        remoteResourceOptions: registryConfig_pgResources_project_project,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["project_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      postsByTheirStatusId: {
        localCodec: postStatusCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["status_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    project: Object.assign(Object.create(null), {
      organizationByMyOrganizationId: {
        localCodec: projectCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      postsByTheirProjectId: {
        localCodec: projectCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["project_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      postStatusesByTheirProjectId: {
        localCodec: projectCodec,
        remoteResourceOptions: registryConfig_pgResources_post_status_post_status,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["project_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    upvote: Object.assign(Object.create(null), {
      postByMyPostId: {
        localCodec: upvoteCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["post_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyUserId: {
        localCodec: upvoteCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }),
    user: Object.assign(Object.create(null), {
      postsByTheirUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      upvotesByTheirUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_upvote_upvote,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      membersByTheirUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_member_member,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      commentsByTheirUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_comment_comment,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      downvotesByTheirUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_downvote_downvote,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    })
  })
};
const registry = makeRegistry(registryConfig);
const resource_downvotePgResource = registry.pgResources["downvote"];
const resource_upvotePgResource = registry.pgResources["upvote"];
const resource_invitationPgResource = registry.pgResources["invitation"];
const resource_organizationPgResource = registry.pgResources["organization"];
const resource_commentPgResource = registry.pgResources["comment"];
const resource_projectPgResource = registry.pgResources["project"];
const resource_userPgResource = registry.pgResources["user"];
const resource_memberPgResource = registry.pgResources["member"];
const resource_postPgResource = registry.pgResources["post"];
const resource_post_statusPgResource = registry.pgResources["post_status"];
const applyOrderToPlan = ($select, $value, TableOrderByType) => {
  if (!("evalLength" in $value)) return;
  const length = $value.evalLength();
  if (length == null) return;
  for (let i = 0; i < length; i++) {
    const order = $value.at(i).eval();
    if (order == null) continue;
    const plan = getEnumValueConfig(TableOrderByType, order)?.extensions?.grafast?.applyPlan;
    if (typeof plan !== "function") {
      console.error(`Internal server error: invalid orderBy configuration: expected function, but received ${inspect(plan)}`);
      throw new SafeError("Internal server error: invalid orderBy configuration");
    }
    plan($select);
  }
};
function assertAllowed(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed2(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed3(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed4(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed5(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed6(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed7(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed8(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed9(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed10(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function UUIDSerialize(value) {
  return "" + value;
}
const coerce = string => {
  if (!/^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$/i.test(string)) throw new GraphQLError("Invalid UUID, expected 32 hexadecimal characters, optionally with hypens");
  return string;
};
function assertAllowed11(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed12(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed13(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed14(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed15(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed16(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed17(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed18(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function ProjectGroupBy_extensions_grafast_applyPlan($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("image")}`
  });
}
function ProjectGroupBy_extensions_grafast_applyPlan2($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("slug")}`
  });
}
function ProjectGroupBy_extensions_grafast_applyPlan3($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("description")}`
  });
}
function ProjectGroupBy_extensions_grafast_applyPlan4($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("organization_id")}`
  });
}
function ProjectGroupBy_extensions_grafast_applyPlan5($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`
  });
}
const aggregateGroupBySpec = {
  id: "truncated-to-hour",
  isSuitableType(codec) {
    return codec === TYPES.timestamp || codec === TYPES.timestamptz;
  },
  sqlWrap(sqlFrag) {
    return sql`date_trunc('hour', ${sqlFrag})`;
  }
};
function ProjectGroupBy_extensions_grafast_applyPlan6($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
const aggregateGroupBySpec2 = {
  id: "truncated-to-day",
  isSuitableType(codec) {
    return codec === TYPES.timestamp || codec === TYPES.timestamptz;
  },
  sqlWrap(sqlFrag) {
    return sql`date_trunc('day', ${sqlFrag})`;
  }
};
function ProjectGroupBy_extensions_grafast_applyPlan7($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function ProjectGroupBy_extensions_grafast_applyPlan8($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`
  });
}
function ProjectGroupBy_extensions_grafast_applyPlan9($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
function ProjectGroupBy_extensions_grafast_applyPlan10($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
export const ProjectGroupBy = new GraphQLEnumType({
  name: "ProjectGroupBy",
  description: "Grouping methods for `Project` for usage during aggregation.",
  values: Object.assign(Object.create(null), {
    IMAGE: {
      value: "IMAGE",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: ProjectGroupBy_extensions_grafast_applyPlan
        }
      })
    },
    SLUG: {
      value: "SLUG",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: ProjectGroupBy_extensions_grafast_applyPlan2
        }
      })
    },
    DESCRIPTION: {
      value: "DESCRIPTION",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: ProjectGroupBy_extensions_grafast_applyPlan3
        }
      })
    },
    ORGANIZATION_ID: {
      value: "ORGANIZATION_ID",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: ProjectGroupBy_extensions_grafast_applyPlan4
        }
      })
    },
    CREATED_AT: {
      value: "CREATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: ProjectGroupBy_extensions_grafast_applyPlan5
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      value: "CREATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: ProjectGroupBy_extensions_grafast_applyPlan6
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      value: "CREATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: ProjectGroupBy_extensions_grafast_applyPlan7
        }
      })
    },
    UPDATED_AT: {
      value: "UPDATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: ProjectGroupBy_extensions_grafast_applyPlan8
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      value: "UPDATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: ProjectGroupBy_extensions_grafast_applyPlan9
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      value: "UPDATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: ProjectGroupBy_extensions_grafast_applyPlan10
        }
      })
    }
  })
});
const dataTypeToAggregateTypeMap = {};
const spec = {
  id: "distinctCount",
  humanLabel: "distinct count",
  HumanLabel: "Distinct count",
  isSuitableType() {
    return !0;
  },
  sqlAggregateWrap(sqlFrag) {
    return sql`count(distinct ${sqlFrag})`;
  },
  pgTypeCodecModifier(codec) {
    var _a, _b;
    const oid = (_a = codec.extensions) === null || _a === void 0 ? void 0 : _a.oid;
    return (_b = oid ? dataTypeToAggregateTypeMap[oid] : null) !== null && _b !== void 0 ? _b : TYPES.bigint;
  }
};
const isIntervalLike = codec => {
  var _a;
  return !!((_a = codec.extensions) === null || _a === void 0 ? void 0 : _a.isIntervalLike);
};
const isNumberLike = codec => {
  var _a;
  return !!((_a = codec.extensions) === null || _a === void 0 ? void 0 : _a.isNumberLike);
};
const aggregateSpec_isSuitableType = codec => isIntervalLike(codec) || isNumberLike(codec);
const dataTypeToAggregateTypeMap2 = {
  "20": TYPES.numeric,
  "21": TYPES.bigint,
  "23": TYPES.bigint,
  "700": TYPES.float4,
  "701": TYPES.float,
  "790": TYPES.money,
  "1186": TYPES.interval
};
const aggregateSpec = {
  id: "sum",
  humanLabel: "sum",
  HumanLabel: "Sum",
  isSuitableType: aggregateSpec_isSuitableType,
  sqlAggregateWrap(sqlFrag) {
    return sql`coalesce(sum(${sqlFrag}), '0')`;
  },
  isNonNull: true,
  pgTypeCodecModifier(codec) {
    var _a, _b;
    const oid = (_a = codec.extensions) === null || _a === void 0 ? void 0 : _a.oid;
    return (_b = oid ? dataTypeToAggregateTypeMap2[oid] : null) !== null && _b !== void 0 ? _b : TYPES.numeric;
  }
};
const infix = () => sql.fragment`=`;
const infix2 = () => sql.fragment`<>`;
const infix3 = () => sql.fragment`>`;
const infix4 = () => sql.fragment`>=`;
const infix5 = () => sql.fragment`<`;
const infix6 = () => sql.fragment`<=`;
const aggregateSpec2 = {
  id: "min",
  humanLabel: "minimum",
  HumanLabel: "Minimum",
  isSuitableType: aggregateSpec_isSuitableType,
  sqlAggregateWrap(sqlFrag) {
    return sql`min(${sqlFrag})`;
  }
};
const aggregateSpec3 = {
  id: "max",
  humanLabel: "maximum",
  HumanLabel: "Maximum",
  isSuitableType: aggregateSpec_isSuitableType,
  sqlAggregateWrap(sqlFrag) {
    return sql`max(${sqlFrag})`;
  }
};
const dataTypeToAggregateTypeMap3 = {
  "20": TYPES.numeric,
  "21": TYPES.numeric,
  "23": TYPES.numeric,
  "700": TYPES.float,
  "701": TYPES.float,
  "1186": TYPES.interval,
  "1700": TYPES.numeric
};
const aggregateSpec4 = {
  id: "average",
  humanLabel: "mean average",
  HumanLabel: "Mean average",
  isSuitableType: aggregateSpec_isSuitableType,
  sqlAggregateWrap(sqlFrag) {
    return sql`avg(${sqlFrag})`;
  },
  pgTypeCodecModifier(codec) {
    var _a, _b;
    const oid = (_a = codec.extensions) === null || _a === void 0 ? void 0 : _a.oid;
    return (_b = oid ? dataTypeToAggregateTypeMap3[oid] : null) !== null && _b !== void 0 ? _b : TYPES.numeric;
  }
};
const dataTypeToAggregateTypeMap4 = {
  "700": TYPES.float,
  "701": TYPES.float
};
const aggregateSpec5 = {
  id: "stddevSample",
  humanLabel: "sample standard deviation",
  HumanLabel: "Sample standard deviation",
  isSuitableType: isNumberLike,
  sqlAggregateWrap(sqlFrag) {
    return sql`stddev_samp(${sqlFrag})`;
  },
  pgTypeCodecModifier(codec) {
    var _a, _b;
    const oid = (_a = codec.extensions) === null || _a === void 0 ? void 0 : _a.oid;
    return (_b = oid ? dataTypeToAggregateTypeMap4[oid] : null) !== null && _b !== void 0 ? _b : TYPES.numeric;
  }
};
const dataTypeToAggregateTypeMap5 = {
  "700": TYPES.float,
  "701": TYPES.float
};
const aggregateSpec6 = {
  id: "stddevPopulation",
  humanLabel: "population standard deviation",
  HumanLabel: "Population standard deviation",
  isSuitableType: isNumberLike,
  sqlAggregateWrap(sqlFrag) {
    return sql`stddev_pop(${sqlFrag})`;
  },
  pgTypeCodecModifier(codec) {
    var _a, _b;
    const oid = (_a = codec.extensions) === null || _a === void 0 ? void 0 : _a.oid;
    return (_b = oid ? dataTypeToAggregateTypeMap5[oid] : null) !== null && _b !== void 0 ? _b : TYPES.numeric;
  }
};
const dataTypeToAggregateTypeMap6 = {
  "700": TYPES.float,
  "701": TYPES.float
};
const aggregateSpec7 = {
  id: "varianceSample",
  humanLabel: "sample variance",
  HumanLabel: "Sample variance",
  isSuitableType: isNumberLike,
  sqlAggregateWrap(sqlFrag) {
    return sql`var_samp(${sqlFrag})`;
  },
  pgTypeCodecModifier(codec) {
    var _a, _b;
    const oid = (_a = codec.extensions) === null || _a === void 0 ? void 0 : _a.oid;
    return (_b = oid ? dataTypeToAggregateTypeMap6[oid] : null) !== null && _b !== void 0 ? _b : TYPES.numeric;
  }
};
const dataTypeToAggregateTypeMap7 = {
  "700": TYPES.float,
  "701": TYPES.float
};
const aggregateSpec8 = {
  id: "variancePopulation",
  humanLabel: "population variance",
  HumanLabel: "Population variance",
  isSuitableType: isNumberLike,
  sqlAggregateWrap(sqlFrag) {
    return sql`var_pop(${sqlFrag})`;
  },
  pgTypeCodecModifier(codec) {
    var _a, _b;
    const oid = (_a = codec.extensions) === null || _a === void 0 ? void 0 : _a.oid;
    return (_b = oid ? dataTypeToAggregateTypeMap7[oid] : null) !== null && _b !== void 0 ? _b : TYPES.numeric;
  }
};
const relation = registry.pgRelations["project"]["postsByTheirProjectId"];
const relation2 = registry.pgRelations["project"]["postStatusesByTheirProjectId"];
const colSpec = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_project.attributes.id
};
const colSpec2 = {
  fieldName: "name",
  attributeName: "name",
  attribute: spec_project.attributes.name
};
const colSpec3 = {
  fieldName: "image",
  attributeName: "image",
  attribute: spec_project.attributes.image
};
const colSpec4 = {
  fieldName: "slug",
  attributeName: "slug",
  attribute: spec_project.attributes.slug
};
const colSpec5 = {
  fieldName: "description",
  attributeName: "description",
  attribute: spec_project.attributes.description
};
const colSpec6 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_project.attributes.organization_id
};
const colSpec7 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_project.attributes.created_at
};
const colSpec8 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_project.attributes.updated_at
};
function assertAllowed19(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed20(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed21(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const resolve = (i, _v, $input) => sql`${i} ${$input.eval() ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec = () => TYPES.boolean;
const resolveSqlValue = () => sql.null;
const resolve2 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec2(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive.includes(resolveDomains(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive.includes(resolveDomains(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive.includes(resolveDomains(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive.includes(resolveDomains(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve3 = (i, v) => sql`${i} <> ${v}`;
const resolve4 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve5 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve6 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec3(c) {
  if (forceTextTypesSensitive.includes(resolveDomains(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve7 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve8 = (i, v) => sql`${i} < ${v}`;
const resolve9 = (i, v) => sql`${i} <= ${v}`;
const resolve10 = (i, v) => sql`${i} > ${v}`;
const resolve11 = (i, v) => sql`${i} >= ${v}`;
const resolve12 = (i, _v, $input) => sql`${i} ${$input.eval() ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec4 = () => TYPES.boolean;
const resolveSqlValue2 = () => sql.null;
const resolve13 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive2 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains2(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec5(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive2.includes(resolveDomains2(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive2.includes(resolveDomains2(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier2(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive2.includes(resolveDomains2(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive2.includes(resolveDomains2(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve14 = (i, v) => sql`${i} <> ${v}`;
const resolve15 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve16 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve17 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec6(c) {
  if (forceTextTypesSensitive2.includes(resolveDomains2(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve18 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve19 = (i, v) => sql`${i} < ${v}`;
const resolve20 = (i, v) => sql`${i} <= ${v}`;
const resolve21 = (i, v) => sql`${i} > ${v}`;
const resolve22 = (i, v) => sql`${i} >= ${v}`;
const resolve23 = (i, v) => sql`${i} LIKE ${v}`;
function escapeLikeWildcards(input) {
  if (typeof input !== "string") throw new Error("Non-string input was provided to escapeLikeWildcards");else return input.split("%").join("\\%").split("_").join("\\_");
}
const resolveInput = input => `%${escapeLikeWildcards(input)}%`;
const resolve24 = (i, v) => sql`${i} NOT LIKE ${v}`;
const resolveInput2 = input => `%${escapeLikeWildcards(input)}%`;
const resolve25 = (i, v) => sql`${i} ILIKE ${v}`;
const resolveInput3 = input => `%${escapeLikeWildcards(input)}%`;
const forceTextTypesInsensitive = [TYPES.char, TYPES.bpchar];
function resolveInputCodec7(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesInsensitive.includes(resolveDomains2(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesInsensitive.includes(resolveDomains2(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier3(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesInsensitive.includes(resolveDomains2(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesInsensitive.includes(resolveDomains2(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve26 = (i, v) => sql`${i} NOT ILIKE ${v}`;
const resolveInput4 = input => `%${escapeLikeWildcards(input)}%`;
const resolve27 = (i, v) => sql`${i} LIKE ${v}`;
const resolveInput5 = input => `${escapeLikeWildcards(input)}%`;
const resolve28 = (i, v) => sql`${i} NOT LIKE ${v}`;
const resolveInput6 = input => `${escapeLikeWildcards(input)}%`;
const resolve29 = (i, v) => sql`${i} ILIKE ${v}`;
const resolveInput7 = input => `${escapeLikeWildcards(input)}%`;
const resolve30 = (i, v) => sql`${i} NOT ILIKE ${v}`;
const resolveInput8 = input => `${escapeLikeWildcards(input)}%`;
const resolve31 = (i, v) => sql`${i} LIKE ${v}`;
const resolveInput9 = input => `%${escapeLikeWildcards(input)}`;
const resolve32 = (i, v) => sql`${i} NOT LIKE ${v}`;
const resolveInput10 = input => `%${escapeLikeWildcards(input)}`;
const resolve33 = (i, v) => sql`${i} ILIKE ${v}`;
const resolveInput11 = input => `%${escapeLikeWildcards(input)}`;
const resolve34 = (i, v) => sql`${i} NOT ILIKE ${v}`;
const resolveInput12 = input => `%${escapeLikeWildcards(input)}`;
const resolve35 = (i, v) => sql`${i} LIKE ${v}`;
const resolve36 = (i, v) => sql`${i} NOT LIKE ${v}`;
const resolve37 = (i, v) => sql`${i} ILIKE ${v}`;
const resolve38 = (i, v) => sql`${i} NOT ILIKE ${v}`;
function resolveInputCodec8(inputCodec) {
  if ("equalTo" === "in" || "equalTo" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier4(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue3($placeholderable, $input, inputCodec) {
  if ("equalTo" === "in" || "equalTo" === "notIn") {
    const sqlList = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec9(inputCodec) {
  if ("notEqualTo" === "in" || "notEqualTo" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier5(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue4($placeholderable, $input, inputCodec) {
  if ("notEqualTo" === "in" || "notEqualTo" === "notIn") {
    const sqlList = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec10(inputCodec) {
  if ("distinctFrom" === "in" || "distinctFrom" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier6(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue5($placeholderable, $input, inputCodec) {
  if ("distinctFrom" === "in" || "distinctFrom" === "notIn") {
    const sqlList = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec11(inputCodec) {
  if ("notDistinctFrom" === "in" || "notDistinctFrom" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier7(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue6($placeholderable, $input, inputCodec) {
  if ("notDistinctFrom" === "in" || "notDistinctFrom" === "notIn") {
    const sqlList = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec12(inputCodec) {
  if ("in" === "in" || "in" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier8(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue7($placeholderable, $input, inputCodec) {
  if ("in" === "in" || "in" === "notIn") {
    const sqlList = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec13(inputCodec) {
  if ("notIn" === "in" || "notIn" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier9(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue8($placeholderable, $input, inputCodec) {
  if ("notIn" === "in" || "notIn" === "notIn") {
    const sqlList = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec14(inputCodec) {
  if ("lessThan" === "in" || "lessThan" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier10(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue9($placeholderable, $input, inputCodec) {
  if ("lessThan" === "in" || "lessThan" === "notIn") {
    const sqlList = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec15(inputCodec) {
  if ("lessThanOrEqualTo" === "in" || "lessThanOrEqualTo" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier11(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue10($placeholderable, $input, inputCodec) {
  if ("lessThanOrEqualTo" === "in" || "lessThanOrEqualTo" === "notIn") {
    const sqlList = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec16(inputCodec) {
  if ("greaterThan" === "in" || "greaterThan" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier12(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue11($placeholderable, $input, inputCodec) {
  if ("greaterThan" === "in" || "greaterThan" === "notIn") {
    const sqlList = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec17(inputCodec) {
  if ("greaterThanOrEqualTo" === "in" || "greaterThanOrEqualTo" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier13(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue12($placeholderable, $input, inputCodec) {
  if ("greaterThanOrEqualTo" === "in" || "greaterThanOrEqualTo" === "notIn") {
    const sqlList = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = $placeholderable.placeholder($input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
const resolve39 = (i, _v, $input) => sql`${i} ${$input.eval() ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec18 = () => TYPES.boolean;
const resolveSqlValue13 = () => sql.null;
const resolve40 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive3 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains3(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec19(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive3.includes(resolveDomains3(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive3.includes(resolveDomains3(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier14(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive3.includes(resolveDomains3(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive3.includes(resolveDomains3(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve41 = (i, v) => sql`${i} <> ${v}`;
const resolve42 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve43 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve44 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec20(c) {
  if (forceTextTypesSensitive3.includes(resolveDomains3(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve45 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve46 = (i, v) => sql`${i} < ${v}`;
const resolve47 = (i, v) => sql`${i} <= ${v}`;
const resolve48 = (i, v) => sql`${i} > ${v}`;
const resolve49 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed22(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const PgAggregateConditionExpressionStep = class PgAggregateConditionExpressionStep extends ModifierStep {
  constructor($parent, spec, pgWhereConditionSpecListToSQL) {
    super($parent);
    this.spec = spec;
    this.pgWhereConditionSpecListToSQL = pgWhereConditionSpecListToSQL;
    this.conditions = [];
    this.alias = $parent.alias;
  }
  placeholder($step, codec) {
    return this.$parent.placeholder($step, codec);
  }
  where(condition) {
    this.conditions.push(condition);
  }
  apply() {
    const sqlCondition = this.pgWhereConditionSpecListToSQL(this.alias, this.conditions);
    if (sqlCondition) this.$parent.expression(sqlCondition);
  }
};
const PgAggregateConditionStep = class PgAggregateConditionStep extends ModifierStep {
  constructor($parent, options, pgWhereConditionSpecListToSQL) {
    super($parent);
    this.pgWhereConditionSpecListToSQL = pgWhereConditionSpecListToSQL;
    this.conditions = [];
    this.expressions = [];
    const {
      sql,
      tableExpression,
      alias
    } = options;
    this.sql = sql;
    this.alias = sql.identifier(Symbol(alias !== null && alias !== void 0 ? alias : "aggregate"));
    this.tableExpression = tableExpression;
  }
  placeholder($step, codec) {
    return this.$parent.placeholder($step, codec);
  }
  where(condition) {
    this.conditions.push(condition);
  }
  expression(expression) {
    this.expressions.push(expression);
  }
  forAggregate(spec) {
    return new PgAggregateConditionExpressionStep(this, spec, this.pgWhereConditionSpecListToSQL);
  }
  apply() {
    const {
        sql
      } = this,
      sqlCondition = this.pgWhereConditionSpecListToSQL(this.alias, this.conditions),
      where = sqlCondition ? sql`where ${sqlCondition}` : sql.blank,
      boolExpr = this.expressions.length === 0 ? sql.true : sql.parens(sql.join(this.expressions.map(expr => sql.parens(expr)), `
and
`)),
      subquery = sql`(${sql.indent`\
select ${boolExpr}
from ${this.tableExpression} as ${this.alias}
${where}`}
group by ())`;
    return this.$parent.where(subquery);
  }
};
const colSpec9 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_post.attributes.id
};
const colSpec10 = {
  fieldName: "title",
  attributeName: "title",
  attribute: spec_post.attributes.title
};
const colSpec11 = {
  fieldName: "description",
  attributeName: "description",
  attribute: spec_post.attributes.description
};
const colSpec12 = {
  fieldName: "projectId",
  attributeName: "project_id",
  attribute: spec_post.attributes.project_id
};
const colSpec13 = {
  fieldName: "userId",
  attributeName: "user_id",
  attribute: spec_post.attributes.user_id
};
const colSpec14 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_post.attributes.created_at
};
const colSpec15 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_post.attributes.updated_at
};
const colSpec16 = {
  fieldName: "statusId",
  attributeName: "status_id",
  attribute: spec_post.attributes.status_id
};
const colSpec17 = {
  fieldName: "statusUpdatedAt",
  attributeName: "status_updated_at",
  attribute: spec_post.attributes.status_updated_at
};
function assertAllowed23(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed24(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed25(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed26(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec18 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_upvote.attributes.id
};
const colSpec19 = {
  fieldName: "postId",
  attributeName: "post_id",
  attribute: spec_upvote.attributes.post_id
};
const colSpec20 = {
  fieldName: "userId",
  attributeName: "user_id",
  attribute: spec_upvote.attributes.user_id
};
const colSpec21 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_upvote.attributes.created_at
};
const colSpec22 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_upvote.attributes.updated_at
};
function assertAllowed27(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed28(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec23 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_user.attributes.id
};
const colSpec24 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_user.attributes.created_at
};
const colSpec25 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_user.attributes.updated_at
};
const colSpec26 = {
  fieldName: "hidraId",
  attributeName: "hidra_id",
  attribute: spec_user.attributes.hidra_id
};
const colSpec27 = {
  fieldName: "username",
  attributeName: "username",
  attribute: spec_user.attributes.username
};
const colSpec28 = {
  fieldName: "firstName",
  attributeName: "first_name",
  attribute: spec_user.attributes.first_name
};
const colSpec29 = {
  fieldName: "lastName",
  attributeName: "last_name",
  attribute: spec_user.attributes.last_name
};
const colSpec30 = {
  fieldName: "email",
  attributeName: "email",
  attribute: spec_user.attributes.email
};
function assertAllowed29(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed30(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed31(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const resolve50 = (i, _v, $input) => sql`${i} ${$input.eval() ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec21 = () => TYPES.boolean;
const resolveSqlValue14 = () => sql.null;
const resolve51 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive4 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains4(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec22(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive4.includes(resolveDomains4(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive4.includes(resolveDomains4(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier15(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive4.includes(resolveDomains4(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive4.includes(resolveDomains4(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve52 = (i, v) => sql`${i} <> ${v}`;
const resolve53 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve54 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve55 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec23(c) {
  if (forceTextTypesSensitive4.includes(resolveDomains4(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve56 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve57 = (i, v) => sql`${i} < ${v}`;
const resolve58 = (i, v) => sql`${i} <= ${v}`;
const resolve59 = (i, v) => sql`${i} > ${v}`;
const resolve60 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed32(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed33(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec31 = {
  fieldName: "userId",
  attributeName: "user_id",
  attribute: spec_member.attributes.user_id
};
const colSpec32 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_member.attributes.organization_id
};
const colSpec33 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_member.attributes.created_at
};
const colSpec34 = {
  fieldName: "role",
  attributeName: "role",
  attribute: spec_member.attributes.role
};
const colSpec35 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_member.attributes.id
};
function assertAllowed34(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed35(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const resolve61 = (i, _v, $input) => sql`${i} ${$input.eval() ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec24 = () => TYPES.boolean;
const resolveSqlValue15 = () => sql.null;
const resolve62 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive5 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains5(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec25(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive5.includes(resolveDomains5(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive5.includes(resolveDomains5(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier16(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive5.includes(resolveDomains5(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive5.includes(resolveDomains5(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve63 = (i, v) => sql`${i} <> ${v}`;
const resolve64 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve65 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve66 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec26(c) {
  if (forceTextTypesSensitive5.includes(resolveDomains5(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve67 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve68 = (i, v) => sql`${i} < ${v}`;
const resolve69 = (i, v) => sql`${i} <= ${v}`;
const resolve70 = (i, v) => sql`${i} > ${v}`;
const resolve71 = (i, v) => sql`${i} >= ${v}`;
const colSpec36 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_organization.attributes.id
};
const colSpec37 = {
  fieldName: "name",
  attributeName: "name",
  attribute: spec_organization.attributes.name
};
const colSpec38 = {
  fieldName: "slug",
  attributeName: "slug",
  attribute: spec_organization.attributes.slug
};
const colSpec39 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_organization.attributes.created_at
};
const colSpec40 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_organization.attributes.updated_at
};
function assertAllowed36(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed37(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed38(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed39(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed40(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec41 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_invitation.attributes.id
};
const colSpec42 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_invitation.attributes.organization_id
};
const colSpec43 = {
  fieldName: "email",
  attributeName: "email",
  attribute: spec_invitation.attributes.email
};
const colSpec44 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_invitation.attributes.created_at
};
const colSpec45 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_invitation.attributes.updated_at
};
function assertAllowed41(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed42(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed43(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec46 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_comment.attributes.id
};
const colSpec47 = {
  fieldName: "message",
  attributeName: "message",
  attribute: spec_comment.attributes.message
};
const colSpec48 = {
  fieldName: "postId",
  attributeName: "post_id",
  attribute: spec_comment.attributes.post_id
};
const colSpec49 = {
  fieldName: "userId",
  attributeName: "user_id",
  attribute: spec_comment.attributes.user_id
};
const colSpec50 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_comment.attributes.created_at
};
const colSpec51 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_comment.attributes.updated_at
};
function assertAllowed44(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed45(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed46(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec52 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_downvote.attributes.id
};
const colSpec53 = {
  fieldName: "postId",
  attributeName: "post_id",
  attribute: spec_downvote.attributes.post_id
};
const colSpec54 = {
  fieldName: "userId",
  attributeName: "user_id",
  attribute: spec_downvote.attributes.user_id
};
const colSpec55 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_downvote.attributes.created_at
};
const colSpec56 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_downvote.attributes.updated_at
};
function assertAllowed47(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed48(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed49(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed50(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec57 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_postStatus.attributes.id
};
const colSpec58 = {
  fieldName: "status",
  attributeName: "status",
  attribute: spec_postStatus.attributes.status
};
const colSpec59 = {
  fieldName: "description",
  attributeName: "description",
  attribute: spec_postStatus.attributes.description
};
const colSpec60 = {
  fieldName: "color",
  attributeName: "color",
  attribute: spec_postStatus.attributes.color
};
const colSpec61 = {
  fieldName: "projectId",
  attributeName: "project_id",
  attribute: spec_postStatus.attributes.project_id
};
const colSpec62 = {
  fieldName: "isDefault",
  attributeName: "is_default",
  attribute: spec_postStatus.attributes.is_default
};
const colSpec63 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_postStatus.attributes.created_at
};
const colSpec64 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_postStatus.attributes.updated_at
};
function assertAllowed51(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed52(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed53(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const resolve72 = (i, _v, $input) => sql`${i} ${$input.eval() ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec27 = () => TYPES.boolean;
const resolveSqlValue16 = () => sql.null;
const resolve73 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive6 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains6(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec28(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive6.includes(resolveDomains6(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive6.includes(resolveDomains6(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier17(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive6.includes(resolveDomains6(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive6.includes(resolveDomains6(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve74 = (i, v) => sql`${i} <> ${v}`;
const resolve75 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve76 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve77 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec29(c) {
  if (forceTextTypesSensitive6.includes(resolveDomains6(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve78 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve79 = (i, v) => sql`${i} < ${v}`;
const resolve80 = (i, v) => sql`${i} <= ${v}`;
const resolve81 = (i, v) => sql`${i} > ${v}`;
const resolve82 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed54(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed55(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function MemberGroupBy_extensions_grafast_applyPlan($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("user_id")}`
  });
}
function MemberGroupBy_extensions_grafast_applyPlan2($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("organization_id")}`
  });
}
function MemberGroupBy_extensions_grafast_applyPlan3($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`
  });
}
function MemberGroupBy_extensions_grafast_applyPlan4($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function MemberGroupBy_extensions_grafast_applyPlan5($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function MemberGroupBy_extensions_grafast_applyPlan6($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("role")}`
  });
}
export const MemberGroupBy = new GraphQLEnumType({
  name: "MemberGroupBy",
  description: "Grouping methods for `Member` for usage during aggregation.",
  values: Object.assign(Object.create(null), {
    USER_ID: {
      value: "USER_ID",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: MemberGroupBy_extensions_grafast_applyPlan
        }
      })
    },
    ORGANIZATION_ID: {
      value: "ORGANIZATION_ID",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: MemberGroupBy_extensions_grafast_applyPlan2
        }
      })
    },
    CREATED_AT: {
      value: "CREATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: MemberGroupBy_extensions_grafast_applyPlan3
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      value: "CREATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: MemberGroupBy_extensions_grafast_applyPlan4
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      value: "CREATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: MemberGroupBy_extensions_grafast_applyPlan5
        }
      })
    },
    ROLE: {
      value: "ROLE",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: MemberGroupBy_extensions_grafast_applyPlan6
        }
      })
    }
  })
});
function assertAllowed56(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed57(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed58(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed59(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed60(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function PostGroupBy_extensions_grafast_applyPlan($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("title")}`
  });
}
function PostGroupBy_extensions_grafast_applyPlan2($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("description")}`
  });
}
function PostGroupBy_extensions_grafast_applyPlan3($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("project_id")}`
  });
}
function PostGroupBy_extensions_grafast_applyPlan4($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("user_id")}`
  });
}
function PostGroupBy_extensions_grafast_applyPlan5($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`
  });
}
function PostGroupBy_extensions_grafast_applyPlan6($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function PostGroupBy_extensions_grafast_applyPlan7($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function PostGroupBy_extensions_grafast_applyPlan8($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`
  });
}
function PostGroupBy_extensions_grafast_applyPlan9($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
function PostGroupBy_extensions_grafast_applyPlan10($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
function PostGroupBy_extensions_grafast_applyPlan11($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("status_id")}`
  });
}
function PostGroupBy_extensions_grafast_applyPlan12($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("status_updated_at")}`
  });
}
function PostGroupBy_extensions_grafast_applyPlan13($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("status_updated_at")}`)
  });
}
function PostGroupBy_extensions_grafast_applyPlan14($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("status_updated_at")}`)
  });
}
export const PostGroupBy = new GraphQLEnumType({
  name: "PostGroupBy",
  description: "Grouping methods for `Post` for usage during aggregation.",
  values: Object.assign(Object.create(null), {
    TITLE: {
      value: "TITLE",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostGroupBy_extensions_grafast_applyPlan
        }
      })
    },
    DESCRIPTION: {
      value: "DESCRIPTION",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostGroupBy_extensions_grafast_applyPlan2
        }
      })
    },
    PROJECT_ID: {
      value: "PROJECT_ID",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostGroupBy_extensions_grafast_applyPlan3
        }
      })
    },
    USER_ID: {
      value: "USER_ID",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostGroupBy_extensions_grafast_applyPlan4
        }
      })
    },
    CREATED_AT: {
      value: "CREATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostGroupBy_extensions_grafast_applyPlan5
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      value: "CREATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostGroupBy_extensions_grafast_applyPlan6
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      value: "CREATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostGroupBy_extensions_grafast_applyPlan7
        }
      })
    },
    UPDATED_AT: {
      value: "UPDATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostGroupBy_extensions_grafast_applyPlan8
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      value: "UPDATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostGroupBy_extensions_grafast_applyPlan9
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      value: "UPDATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostGroupBy_extensions_grafast_applyPlan10
        }
      })
    },
    STATUS_ID: {
      value: "STATUS_ID",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostGroupBy_extensions_grafast_applyPlan11
        }
      })
    },
    STATUS_UPDATED_AT: {
      value: "STATUS_UPDATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostGroupBy_extensions_grafast_applyPlan12
        }
      })
    },
    STATUS_UPDATED_AT_TRUNCATED_TO_HOUR: {
      value: "STATUS_UPDATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostGroupBy_extensions_grafast_applyPlan13
        }
      })
    },
    STATUS_UPDATED_AT_TRUNCATED_TO_DAY: {
      value: "STATUS_UPDATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostGroupBy_extensions_grafast_applyPlan14
        }
      })
    }
  })
});
const relation3 = registry.pgRelations["post"]["upvotesByTheirPostId"];
const relation4 = registry.pgRelations["post"]["commentsByTheirPostId"];
const relation5 = registry.pgRelations["post"]["downvotesByTheirPostId"];
function UpvoteGroupBy_extensions_grafast_applyPlan($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("post_id")}`
  });
}
function UpvoteGroupBy_extensions_grafast_applyPlan2($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("user_id")}`
  });
}
function UpvoteGroupBy_extensions_grafast_applyPlan3($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`
  });
}
function UpvoteGroupBy_extensions_grafast_applyPlan4($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function UpvoteGroupBy_extensions_grafast_applyPlan5($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function UpvoteGroupBy_extensions_grafast_applyPlan6($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`
  });
}
function UpvoteGroupBy_extensions_grafast_applyPlan7($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
function UpvoteGroupBy_extensions_grafast_applyPlan8($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
export const UpvoteGroupBy = new GraphQLEnumType({
  name: "UpvoteGroupBy",
  description: "Grouping methods for `Upvote` for usage during aggregation.",
  values: Object.assign(Object.create(null), {
    POST_ID: {
      value: "POST_ID",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan
        }
      })
    },
    USER_ID: {
      value: "USER_ID",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan2
        }
      })
    },
    CREATED_AT: {
      value: "CREATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan3
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      value: "CREATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan4
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      value: "CREATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan5
        }
      })
    },
    UPDATED_AT: {
      value: "UPDATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan6
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      value: "UPDATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan7
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      value: "UPDATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan8
        }
      })
    }
  })
});
function CommentGroupBy_extensions_grafast_applyPlan($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("message")}`
  });
}
function CommentGroupBy_extensions_grafast_applyPlan2($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("post_id")}`
  });
}
function CommentGroupBy_extensions_grafast_applyPlan3($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("user_id")}`
  });
}
function CommentGroupBy_extensions_grafast_applyPlan4($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`
  });
}
function CommentGroupBy_extensions_grafast_applyPlan5($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function CommentGroupBy_extensions_grafast_applyPlan6($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function CommentGroupBy_extensions_grafast_applyPlan7($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`
  });
}
function CommentGroupBy_extensions_grafast_applyPlan8($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
function CommentGroupBy_extensions_grafast_applyPlan9($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
export const CommentGroupBy = new GraphQLEnumType({
  name: "CommentGroupBy",
  description: "Grouping methods for `Comment` for usage during aggregation.",
  values: Object.assign(Object.create(null), {
    MESSAGE: {
      value: "MESSAGE",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: CommentGroupBy_extensions_grafast_applyPlan
        }
      })
    },
    POST_ID: {
      value: "POST_ID",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: CommentGroupBy_extensions_grafast_applyPlan2
        }
      })
    },
    USER_ID: {
      value: "USER_ID",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: CommentGroupBy_extensions_grafast_applyPlan3
        }
      })
    },
    CREATED_AT: {
      value: "CREATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: CommentGroupBy_extensions_grafast_applyPlan4
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      value: "CREATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: CommentGroupBy_extensions_grafast_applyPlan5
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      value: "CREATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: CommentGroupBy_extensions_grafast_applyPlan6
        }
      })
    },
    UPDATED_AT: {
      value: "UPDATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: CommentGroupBy_extensions_grafast_applyPlan7
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      value: "UPDATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: CommentGroupBy_extensions_grafast_applyPlan8
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      value: "UPDATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: CommentGroupBy_extensions_grafast_applyPlan9
        }
      })
    }
  })
});
function DownvoteGroupBy_extensions_grafast_applyPlan($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("post_id")}`
  });
}
function DownvoteGroupBy_extensions_grafast_applyPlan2($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("user_id")}`
  });
}
function DownvoteGroupBy_extensions_grafast_applyPlan3($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`
  });
}
function DownvoteGroupBy_extensions_grafast_applyPlan4($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function DownvoteGroupBy_extensions_grafast_applyPlan5($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function DownvoteGroupBy_extensions_grafast_applyPlan6($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`
  });
}
function DownvoteGroupBy_extensions_grafast_applyPlan7($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
function DownvoteGroupBy_extensions_grafast_applyPlan8($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
export const DownvoteGroupBy = new GraphQLEnumType({
  name: "DownvoteGroupBy",
  description: "Grouping methods for `Downvote` for usage during aggregation.",
  values: Object.assign(Object.create(null), {
    POST_ID: {
      value: "POST_ID",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan
        }
      })
    },
    USER_ID: {
      value: "USER_ID",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan2
        }
      })
    },
    CREATED_AT: {
      value: "CREATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan3
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      value: "CREATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan4
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      value: "CREATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan5
        }
      })
    },
    UPDATED_AT: {
      value: "UPDATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan6
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      value: "UPDATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan7
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      value: "UPDATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan8
        }
      })
    }
  })
});
function InvitationGroupBy_extensions_grafast_applyPlan($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("organization_id")}`
  });
}
function InvitationGroupBy_extensions_grafast_applyPlan2($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`
  });
}
function InvitationGroupBy_extensions_grafast_applyPlan3($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function InvitationGroupBy_extensions_grafast_applyPlan4($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function InvitationGroupBy_extensions_grafast_applyPlan5($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`
  });
}
function InvitationGroupBy_extensions_grafast_applyPlan6($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
function InvitationGroupBy_extensions_grafast_applyPlan7($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
export const InvitationGroupBy = new GraphQLEnumType({
  name: "InvitationGroupBy",
  description: "Grouping methods for `Invitation` for usage during aggregation.",
  values: Object.assign(Object.create(null), {
    ORGANIZATION_ID: {
      value: "ORGANIZATION_ID",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: InvitationGroupBy_extensions_grafast_applyPlan
        }
      })
    },
    CREATED_AT: {
      value: "CREATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: InvitationGroupBy_extensions_grafast_applyPlan2
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      value: "CREATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: InvitationGroupBy_extensions_grafast_applyPlan3
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      value: "CREATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: InvitationGroupBy_extensions_grafast_applyPlan4
        }
      })
    },
    UPDATED_AT: {
      value: "UPDATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: InvitationGroupBy_extensions_grafast_applyPlan5
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      value: "UPDATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: InvitationGroupBy_extensions_grafast_applyPlan6
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      value: "UPDATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: InvitationGroupBy_extensions_grafast_applyPlan7
        }
      })
    }
  })
});
function PostStatusGroupBy_extensions_grafast_applyPlan($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("status")}`
  });
}
function PostStatusGroupBy_extensions_grafast_applyPlan2($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("description")}`
  });
}
function PostStatusGroupBy_extensions_grafast_applyPlan3($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("color")}`
  });
}
function PostStatusGroupBy_extensions_grafast_applyPlan4($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("project_id")}`
  });
}
function PostStatusGroupBy_extensions_grafast_applyPlan5($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("is_default")}`
  });
}
function PostStatusGroupBy_extensions_grafast_applyPlan6($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`
  });
}
function PostStatusGroupBy_extensions_grafast_applyPlan7($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function PostStatusGroupBy_extensions_grafast_applyPlan8($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function PostStatusGroupBy_extensions_grafast_applyPlan9($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`
  });
}
function PostStatusGroupBy_extensions_grafast_applyPlan10($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
function PostStatusGroupBy_extensions_grafast_applyPlan11($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
export const PostStatusGroupBy = new GraphQLEnumType({
  name: "PostStatusGroupBy",
  description: "Grouping methods for `PostStatus` for usage during aggregation.",
  values: Object.assign(Object.create(null), {
    STATUS: {
      value: "STATUS",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan
        }
      })
    },
    DESCRIPTION: {
      value: "DESCRIPTION",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan2
        }
      })
    },
    COLOR: {
      value: "COLOR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan3
        }
      })
    },
    PROJECT_ID: {
      value: "PROJECT_ID",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan4
        }
      })
    },
    IS_DEFAULT: {
      value: "IS_DEFAULT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan5
        }
      })
    },
    CREATED_AT: {
      value: "CREATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan6
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      value: "CREATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan7
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      value: "CREATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan8
        }
      })
    },
    UPDATED_AT: {
      value: "UPDATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan9
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      value: "UPDATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan10
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      value: "UPDATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan11
        }
      })
    }
  })
});
function assertAllowed61(fieldArgs, mode) {
  const $raw = fieldArgs.getRaw();
  if (mode === "object" && !false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !false && "evalLength" in $raw) {
    const l = $raw.evalLength();
    if (l != null) for (let i = 0; i < l; i++) {
      const $entry = $raw.at(i);
      if ("evalIsEmpty" in $entry && $entry.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const relation6 = registry.pgRelations["postStatus"]["postsByTheirStatusId"];
function OrganizationGroupBy_extensions_grafast_applyPlan($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`
  });
}
function OrganizationGroupBy_extensions_grafast_applyPlan2($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function OrganizationGroupBy_extensions_grafast_applyPlan3($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function OrganizationGroupBy_extensions_grafast_applyPlan4($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`
  });
}
function OrganizationGroupBy_extensions_grafast_applyPlan5($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
function OrganizationGroupBy_extensions_grafast_applyPlan6($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
export const OrganizationGroupBy = new GraphQLEnumType({
  name: "OrganizationGroupBy",
  description: "Grouping methods for `Organization` for usage during aggregation.",
  values: Object.assign(Object.create(null), {
    CREATED_AT: {
      value: "CREATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: OrganizationGroupBy_extensions_grafast_applyPlan
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      value: "CREATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: OrganizationGroupBy_extensions_grafast_applyPlan2
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      value: "CREATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: OrganizationGroupBy_extensions_grafast_applyPlan3
        }
      })
    },
    UPDATED_AT: {
      value: "UPDATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: OrganizationGroupBy_extensions_grafast_applyPlan4
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      value: "UPDATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: OrganizationGroupBy_extensions_grafast_applyPlan5
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      value: "UPDATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: OrganizationGroupBy_extensions_grafast_applyPlan6
        }
      })
    }
  })
});
const relation7 = registry.pgRelations["organization"]["projectsByTheirOrganizationId"];
const relation8 = registry.pgRelations["organization"]["membersByTheirOrganizationId"];
const relation9 = registry.pgRelations["organization"]["invitationsByTheirOrganizationId"];
function UserGroupBy_extensions_grafast_applyPlan($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`
  });
}
function UserGroupBy_extensions_grafast_applyPlan2($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function UserGroupBy_extensions_grafast_applyPlan3($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`)
  });
}
function UserGroupBy_extensions_grafast_applyPlan4($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`
  });
}
function UserGroupBy_extensions_grafast_applyPlan5($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
function UserGroupBy_extensions_grafast_applyPlan6($pgSelect) {
  $pgSelect.groupBy({
    fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`)
  });
}
function UserGroupBy_extensions_grafast_applyPlan7($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("first_name")}`
  });
}
function UserGroupBy_extensions_grafast_applyPlan8($pgSelect) {
  $pgSelect.groupBy({
    fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("last_name")}`
  });
}
export const UserGroupBy = new GraphQLEnumType({
  name: "UserGroupBy",
  description: "Grouping methods for `User` for usage during aggregation.",
  values: Object.assign(Object.create(null), {
    CREATED_AT: {
      value: "CREATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UserGroupBy_extensions_grafast_applyPlan
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      value: "CREATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UserGroupBy_extensions_grafast_applyPlan2
        }
      })
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      value: "CREATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UserGroupBy_extensions_grafast_applyPlan3
        }
      })
    },
    UPDATED_AT: {
      value: "UPDATED_AT",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UserGroupBy_extensions_grafast_applyPlan4
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      value: "UPDATED_AT_TRUNCATED_TO_HOUR",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UserGroupBy_extensions_grafast_applyPlan5
        }
      })
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      value: "UPDATED_AT_TRUNCATED_TO_DAY",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UserGroupBy_extensions_grafast_applyPlan6
        }
      })
    },
    FIRST_NAME: {
      value: "FIRST_NAME",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UserGroupBy_extensions_grafast_applyPlan7
        }
      })
    },
    LAST_NAME: {
      value: "LAST_NAME",
      extensions: Object.assign(Object.create(null), {
        grafast: {
          applyPlan: UserGroupBy_extensions_grafast_applyPlan8
        }
      })
    }
  })
});
const relation10 = registry.pgRelations["user"]["postsByTheirUserId"];
const relation11 = registry.pgRelations["user"]["upvotesByTheirUserId"];
const relation12 = registry.pgRelations["user"]["membersByTheirUserId"];
const relation13 = registry.pgRelations["user"]["commentsByTheirUserId"];
const relation14 = registry.pgRelations["user"]["downvotesByTheirUserId"];
function oldPlan(_, args) {
  const plan = object({
    result: pgInsertSingle(resource_projectPgResource, Object.create(null))
  });
  args.apply(plan);
  return plan;
}
const planWrapper = (plan, _, fieldArgs) => {
  const $project = fieldArgs.getRaw(["input", "project"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$project, $currentUser, $db], async ([project, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    let organizationId;
    const {
      members,
      projects
    } = lib_drizzle_schema;
    if ("create" === "create") organizationId = project.organizationId;else {
      const [currentProject] = await db.select().from(projects).where(eq(projects.id, project));
      organizationId = currentProject.organizationId;
    }
    const [userRole] = await db.select({
      role: members.role
    }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, organizationId)));
    if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
  });
  return plan();
};
function oldPlan2(_, args) {
  const plan = object({
    result: pgInsertSingle(resource_memberPgResource, Object.create(null))
  });
  args.apply(plan);
  return plan;
}
const planWrapper2 = (plan, _, fieldArgs) => {
  const $input = fieldArgs.getRaw(["input", "member"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$input, $currentUser, $db], async ([input, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
      members
    } = lib_drizzle_schema;
    if ("create" === "create") {
      const {
          role,
          userId,
          organizationId
        } = input,
        organizationUsers = await db.select().from(members).where(eq(members.organizationId, organizationId));
      if (organizationUsers.length) {
        const userRole = organizationUsers.find(user => user.userId === currentUser.id)?.role;
        if (!userRole) {
          if (userId !== currentUser.id || role !== "member") throw new Error("Insufficient permissions");
        } else if (userRole !== "owner") throw new Error("Insufficient permissions");
      }
    } else {
      const [member] = await db.select().from(members).where(eq(members.id, input));
      if (currentUser.id !== member.userId) {
        const [userRole] = await db.select({
          role: members.role
        }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, member.organizationId)));
        if (userRole.role !== "owner") throw new Error("Insufficient permissions");
      } else if ("create" === "update" && member.role !== "owner") throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
function oldPlan3(_, args) {
  const plan = object({
    result: pgInsertSingle(resource_post_statusPgResource, Object.create(null))
  });
  args.apply(plan);
  return plan;
}
const planWrapper3 = (plan, _, fieldArgs) => {
  const $postStatus = fieldArgs.getRaw(["input", "postStatus"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$postStatus, $currentUser, $db], async ([postStatus, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
      members,
      projects,
      postStatuses
    } = lib_drizzle_schema;
    let projectId;
    if ("create" === "create") projectId = postStatus.projectId;else {
      const [currentPostStatus] = await db.select().from(postStatuses).where(eq(postStatuses.id, postStatus));
      projectId = currentPostStatus.projectId;
    }
    const [project] = await db.select({
        organizationId: projects.organizationId
      }).from(projects).where(eq(projects.id, projectId)),
      [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, project.organizationId)));
    if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan4 = (_$root, args) => {
  const plan = object({
    result: pgUpdateSingle(resource_downvotePgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper4 = (plan, _, fieldArgs) => {
  const $downvoteId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$downvoteId, $currentUser, $db], async ([downvoteId, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
        downvotes
      } = lib_drizzle_schema,
      [downvote] = await db.select().from(downvotes).where(eq(downvotes.id, downvoteId));
    if (currentUser.id !== downvote.userId) throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan5 = (_$root, args) => {
  const plan = object({
    result: pgUpdateSingle(resource_upvotePgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper5 = (plan, _, fieldArgs) => {
  const $upvoteId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$upvoteId, $currentUser, $db], async ([upvoteId, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
        upvotes
      } = lib_drizzle_schema,
      [upvote] = await db.select().from(upvotes).where(eq(upvotes.id, upvoteId));
    if (currentUser.id !== upvote.userId) throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan6 = (_$root, args) => {
  const plan = object({
    result: pgUpdateSingle(resource_organizationPgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper6 = (plan, _, fieldArgs) => {
  const $organizationId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$organizationId, $currentUser, $db], async ([organizationId, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
        members
      } = lib_drizzle_schema,
      [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, organizationId)));
    if ("update" === "delete" && userRole.role !== "owner") throw new Error("Insufficient permissions");
    if ("update" === "update" && (!userRole || userRole.role === "member")) throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan7 = (_$root, args) => {
  const plan = object({
    result: pgUpdateSingle(resource_commentPgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper7 = (plan, _, fieldArgs) => {
  const $commentId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$commentId, $currentUser, $db], async ([commentId, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
        members,
        projects,
        posts,
        comments
      } = lib_drizzle_schema,
      [comment] = await db.select({
        organizationId: projects.organizationId,
        userId: posts.userId
      }).from(comments).innerJoin(posts, eq(comments.postId, posts.id)).innerJoin(projects, eq(posts.projectId, projects.id)).where(eq(comments.id, commentId));
    if (currentUser.id !== comment.userId) {
      const [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, comment.organizationId)));
      if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
const oldPlan8 = (_$root, args) => {
  const plan = object({
    result: pgUpdateSingle(resource_projectPgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper8 = (plan, _, fieldArgs) => {
  const $project = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$project, $currentUser, $db], async ([project, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    let organizationId;
    const {
      members,
      projects
    } = lib_drizzle_schema;
    if ("update" === "create") organizationId = project.organizationId;else {
      const [currentProject] = await db.select().from(projects).where(eq(projects.id, project));
      organizationId = currentProject.organizationId;
    }
    const [userRole] = await db.select({
      role: members.role
    }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, organizationId)));
    if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan9 = (_$root, args) => {
  const plan = object({
    result: pgUpdateSingle(resource_userPgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper9 = (plan, _, fieldArgs) => {
  const $userId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser");
  sideEffect([$userId, $currentUser], async ([userId, currentUser]) => {
    if (!currentUser) throw new Error("Unauthorized");
    if (userId !== currentUser.id) throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan10 = (_$root, args) => {
  const plan = object({
    result: pgUpdateSingle(resource_memberPgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper10 = (plan, _, fieldArgs) => {
  const $input = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$input, $currentUser, $db], async ([input, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
      members
    } = lib_drizzle_schema;
    if ("update" === "create") {
      const {
          role,
          userId,
          organizationId
        } = input,
        organizationUsers = await db.select().from(members).where(eq(members.organizationId, organizationId));
      if (organizationUsers.length) {
        const userRole = organizationUsers.find(user => user.userId === currentUser.id)?.role;
        if (!userRole) {
          if (userId !== currentUser.id || role !== "member") throw new Error("Insufficient permissions");
        } else if (userRole !== "owner") throw new Error("Insufficient permissions");
      }
    } else {
      const [member] = await db.select().from(members).where(eq(members.id, input));
      if (currentUser.id !== member.userId) {
        const [userRole] = await db.select({
          role: members.role
        }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, member.organizationId)));
        if (userRole.role !== "owner") throw new Error("Insufficient permissions");
      } else if ("update" === "update" && member.role !== "owner") throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
const oldPlan11 = (_$root, args) => {
  const plan = object({
    result: pgUpdateSingle(resource_postPgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper11 = (plan, _, fieldArgs) => {
  const $postId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$postId, $currentUser, $db], async ([postId, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
        members,
        projects,
        posts
      } = lib_drizzle_schema,
      [post] = await db.select({
        organizationId: projects.organizationId,
        userId: posts.userId
      }).from(posts).innerJoin(projects, eq(posts.projectId, projects.id)).where(eq(posts.id, postId));
    if (currentUser.id !== post.userId) {
      const [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, post.organizationId)));
      if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
const oldPlan12 = (_$root, args) => {
  const plan = object({
    result: pgUpdateSingle(resource_post_statusPgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper12 = (plan, _, fieldArgs) => {
  const $postStatus = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$postStatus, $currentUser, $db], async ([postStatus, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
      members,
      projects,
      postStatuses
    } = lib_drizzle_schema;
    let projectId;
    if ("update" === "create") projectId = postStatus.projectId;else {
      const [currentPostStatus] = await db.select().from(postStatuses).where(eq(postStatuses.id, postStatus));
      projectId = currentPostStatus.projectId;
    }
    const [project] = await db.select({
        organizationId: projects.organizationId
      }).from(projects).where(eq(projects.id, projectId)),
      [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, project.organizationId)));
    if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan13 = (_$root, args) => {
  const plan = object({
    result: pgDeleteSingle(resource_downvotePgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper13 = (plan, _, fieldArgs) => {
  const $downvoteId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$downvoteId, $currentUser, $db], async ([downvoteId, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
        downvotes
      } = lib_drizzle_schema,
      [downvote] = await db.select().from(downvotes).where(eq(downvotes.id, downvoteId));
    if (currentUser.id !== downvote.userId) throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan14 = (_$root, args) => {
  const plan = object({
    result: pgDeleteSingle(resource_upvotePgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper14 = (plan, _, fieldArgs) => {
  const $upvoteId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$upvoteId, $currentUser, $db], async ([upvoteId, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
        upvotes
      } = lib_drizzle_schema,
      [upvote] = await db.select().from(upvotes).where(eq(upvotes.id, upvoteId));
    if (currentUser.id !== upvote.userId) throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan15 = (_$root, args) => {
  const plan = object({
    result: pgDeleteSingle(resource_organizationPgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper15 = (plan, _, fieldArgs) => {
  const $organizationId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$organizationId, $currentUser, $db], async ([organizationId, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
        members
      } = lib_drizzle_schema,
      [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, organizationId)));
    if ("delete" === "delete" && userRole.role !== "owner") throw new Error("Insufficient permissions");
    if ("delete" === "update" && (!userRole || userRole.role === "member")) throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan16 = (_$root, args) => {
  const plan = object({
    result: pgDeleteSingle(resource_commentPgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper16 = (plan, _, fieldArgs) => {
  const $commentId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$commentId, $currentUser, $db], async ([commentId, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
        members,
        projects,
        posts,
        comments
      } = lib_drizzle_schema,
      [comment] = await db.select({
        organizationId: projects.organizationId,
        userId: posts.userId
      }).from(comments).innerJoin(posts, eq(comments.postId, posts.id)).innerJoin(projects, eq(posts.projectId, projects.id)).where(eq(comments.id, commentId));
    if (currentUser.id !== comment.userId) {
      const [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, comment.organizationId)));
      if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
const oldPlan17 = (_$root, args) => {
  const plan = object({
    result: pgDeleteSingle(resource_projectPgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper17 = (plan, _, fieldArgs) => {
  const $project = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$project, $currentUser, $db], async ([project, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    let organizationId;
    const {
      members,
      projects
    } = lib_drizzle_schema;
    if ("delete" === "create") organizationId = project.organizationId;else {
      const [currentProject] = await db.select().from(projects).where(eq(projects.id, project));
      organizationId = currentProject.organizationId;
    }
    const [userRole] = await db.select({
      role: members.role
    }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, organizationId)));
    if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan18 = (_$root, args) => {
  const plan = object({
    result: pgDeleteSingle(resource_userPgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper18 = (plan, _, fieldArgs) => {
  const $userId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser");
  sideEffect([$userId, $currentUser], async ([userId, currentUser]) => {
    if (!currentUser) throw new Error("Unauthorized");
    if (userId !== currentUser.id) throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan19 = (_$root, args) => {
  const plan = object({
    result: pgDeleteSingle(resource_memberPgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper19 = (plan, _, fieldArgs) => {
  const $input = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$input, $currentUser, $db], async ([input, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
      members
    } = lib_drizzle_schema;
    if ("delete" === "create") {
      const {
          role,
          userId,
          organizationId
        } = input,
        organizationUsers = await db.select().from(members).where(eq(members.organizationId, organizationId));
      if (organizationUsers.length) {
        const userRole = organizationUsers.find(user => user.userId === currentUser.id)?.role;
        if (!userRole) {
          if (userId !== currentUser.id || role !== "member") throw new Error("Insufficient permissions");
        } else if (userRole !== "owner") throw new Error("Insufficient permissions");
      }
    } else {
      const [member] = await db.select().from(members).where(eq(members.id, input));
      if (currentUser.id !== member.userId) {
        const [userRole] = await db.select({
          role: members.role
        }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, member.organizationId)));
        if (userRole.role !== "owner") throw new Error("Insufficient permissions");
      } else if ("delete" === "update" && member.role !== "owner") throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
const oldPlan20 = (_$root, args) => {
  const plan = object({
    result: pgDeleteSingle(resource_postPgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper20 = (plan, _, fieldArgs) => {
  const $postId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$postId, $currentUser, $db], async ([postId, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
        members,
        projects,
        posts
      } = lib_drizzle_schema,
      [post] = await db.select({
        organizationId: projects.organizationId,
        userId: posts.userId
      }).from(posts).innerJoin(projects, eq(posts.projectId, projects.id)).where(eq(posts.id, postId));
    if (currentUser.id !== post.userId) {
      const [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, post.organizationId)));
      if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
const oldPlan21 = (_$root, args) => {
  const plan = object({
    result: pgDeleteSingle(resource_post_statusPgResource, {
      id: args.get(['input', "rowId"])
    })
  });
  args.apply(plan);
  return plan;
};
const planWrapper21 = (plan, _, fieldArgs) => {
  const $postStatus = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$postStatus, $currentUser, $db], async ([postStatus, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
      members,
      projects,
      postStatuses
    } = lib_drizzle_schema;
    let projectId;
    if ("delete" === "create") projectId = postStatus.projectId;else {
      const [currentPostStatus] = await db.select().from(postStatuses).where(eq(postStatuses.id, postStatus));
      projectId = currentPostStatus.projectId;
    }
    const [project] = await db.select({
        organizationId: projects.organizationId
      }).from(projects).where(eq(projects.id, projectId)),
      [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, project.organizationId)));
    if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
  });
  return plan();
};
export const typeDefs = /* GraphQL */`"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a \`Node\` to work well with Relay 1 mutations. This just resolves to \`query\`.
  """
  id: ID!

  """Fetches an object given its globally unique \`ID\`."""
  node(
    """The globally unique \`ID\`."""
    id: ID!
  ): Node

  """Get a single \`Downvote\`."""
  downvote(rowId: UUID!): Downvote

  """Get a single \`Downvote\`."""
  downvoteByPostIdAndUserId(postId: UUID!, userId: UUID!): Downvote

  """Get a single \`Upvote\`."""
  upvote(rowId: UUID!): Upvote

  """Get a single \`Upvote\`."""
  upvoteByPostIdAndUserId(postId: UUID!, userId: UUID!): Upvote

  """Get a single \`Invitation\`."""
  invitation(rowId: UUID!): Invitation

  """Get a single \`Invitation\`."""
  invitationByEmail(email: String!): Invitation

  """Get a single \`Organization\`."""
  organization(rowId: UUID!): Organization

  """Get a single \`Organization\`."""
  organizationByName(name: String!): Organization

  """Get a single \`Organization\`."""
  organizationBySlug(slug: String!): Organization

  """Get a single \`Comment\`."""
  comment(rowId: UUID!): Comment

  """Get a single \`Project\`."""
  project(rowId: UUID!): Project

  """Get a single \`Project\`."""
  projectByName(name: String!): Project

  """Get a single \`Project\`."""
  projectBySlugAndOrganizationId(slug: String!, organizationId: UUID!): Project

  """Get a single \`User\`."""
  user(rowId: UUID!): User

  """Get a single \`User\`."""
  userByEmail(email: String!): User

  """Get a single \`User\`."""
  userByHidraId(hidraId: UUID!): User

  """Get a single \`User\`."""
  userByUsername(username: String!): User

  """Get a single \`Member\`."""
  member(rowId: UUID!): Member

  """Get a single \`Member\`."""
  memberByUserIdAndOrganizationId(userId: UUID!, organizationId: UUID!): Member

  """Get a single \`Post\`."""
  post(rowId: UUID!): Post

  """Get a single \`PostStatus\`."""
  postStatus(rowId: UUID!): PostStatus

  """Reads and enables pagination through a set of \`Downvote\`."""
  downvotes(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Downvote\`."""
    orderBy: [DownvoteOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DownvoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DownvoteFilter
  ): DownvoteConnection

  """Reads and enables pagination through a set of \`Upvote\`."""
  upvotes(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Upvote\`."""
    orderBy: [UpvoteOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UpvoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UpvoteFilter
  ): UpvoteConnection

  """Reads and enables pagination through a set of \`Invitation\`."""
  invitations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Invitation\`."""
    orderBy: [InvitationOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InvitationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: InvitationFilter
  ): InvitationConnection

  """Reads and enables pagination through a set of \`Organization\`."""
  organizations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganizationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganizationFilter
  ): OrganizationConnection

  """Reads and enables pagination through a set of \`Comment\`."""
  comments(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Comment\`."""
    orderBy: [CommentOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CommentFilter
  ): CommentConnection

  """Reads and enables pagination through a set of \`Project\`."""
  projects(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Project\`."""
    orderBy: [ProjectOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter
  ): ProjectConnection

  """Reads and enables pagination through a set of \`User\`."""
  users(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`User\`."""
    orderBy: [UserOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter
  ): UserConnection

  """Reads and enables pagination through a set of \`Member\`."""
  members(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Member\`."""
    orderBy: [MemberOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MemberFilter
  ): MemberConnection

  """Reads and enables pagination through a set of \`Post\`."""
  posts(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter
  ): PostConnection

  """Reads and enables pagination through a set of \`PostStatus\`."""
  postStatuses(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`PostStatus\`."""
    orderBy: [PostStatusOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostStatusCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostStatusFilter
  ): PostStatusConnection
}

"""An object with a globally unique \`ID\`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
}

type Downvote {
  rowId: UUID!
  postId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Post\` that is related to this \`Downvote\`."""
  post: Post

  """Reads a single \`User\` that is related to this \`Downvote\`."""
  user: User
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) and, if it has a timezone, [RFC
3339](https://datatracker.ietf.org/doc/html/rfc3339) standards. Input values
that do not conform to both ISO 8601 and RFC 3339 may be coerced, which may lead
to unexpected results.
"""
scalar Datetime

type Post {
  rowId: UUID!
  title: String
  description: String
  projectId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
  statusId: UUID
  statusUpdatedAt: Datetime

  """Reads a single \`Project\` that is related to this \`Post\`."""
  project: Project

  """Reads a single \`PostStatus\` that is related to this \`Post\`."""
  status: PostStatus

  """Reads a single \`User\` that is related to this \`Post\`."""
  user: User

  """Reads and enables pagination through a set of \`Upvote\`."""
  upvotes(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Upvote\`."""
    orderBy: [UpvoteOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UpvoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UpvoteFilter
  ): UpvoteConnection!

  """Reads and enables pagination through a set of \`Comment\`."""
  comments(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Comment\`."""
    orderBy: [CommentOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CommentFilter
  ): CommentConnection!

  """Reads and enables pagination through a set of \`Downvote\`."""
  downvotes(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Downvote\`."""
    orderBy: [DownvoteOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DownvoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DownvoteFilter
  ): DownvoteConnection!
}

type Project {
  rowId: UUID!
  name: String
  image: String
  slug: String!
  description: String
  organizationId: UUID!
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Organization\` that is related to this \`Project\`."""
  organization: Organization

  """Reads and enables pagination through a set of \`Post\`."""
  posts(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter
  ): PostConnection!

  """Reads and enables pagination through a set of \`PostStatus\`."""
  postStatuses(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`PostStatus\`."""
    orderBy: [PostStatusOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostStatusCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostStatusFilter
  ): PostStatusConnection!
}

type Organization {
  rowId: UUID!
  name: String
  slug: String!
  createdAt: Datetime
  updatedAt: Datetime

  """Reads and enables pagination through a set of \`Project\`."""
  projects(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Project\`."""
    orderBy: [ProjectOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter
  ): ProjectConnection!

  """Reads and enables pagination through a set of \`Member\`."""
  members(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Member\`."""
    orderBy: [MemberOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MemberFilter
  ): MemberConnection!

  """Reads and enables pagination through a set of \`Invitation\`."""
  invitations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Invitation\`."""
    orderBy: [InvitationOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InvitationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: InvitationFilter
  ): InvitationConnection!
}

"""A connection to a list of \`Project\` values."""
type ProjectConnection {
  """A list of \`Project\` objects."""
  nodes: [Project]!

  """
  A list of edges which contains the \`Project\` and cursor to aid in pagination.
  """
  edges: [ProjectEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Project\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ProjectAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Project\` for these aggregates."""
    groupBy: [ProjectGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ProjectHavingInput
  ): [ProjectAggregates!]
}

"""A \`Project\` edge in the connection."""
type ProjectEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Project\` at the end of the edge."""
  node: Project
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

type ProjectAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ProjectDistinctCountAggregates
}

type ProjectDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of image across the matching connection"""
  image: BigInt

  """Distinct count of slug across the matching connection"""
  slug: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""Grouping methods for \`Project\` for usage during aggregation."""
enum ProjectGroupBy {
  IMAGE
  SLUG
  DESCRIPTION
  ORGANIZATION_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`Project\` aggregates."""
input ProjectHavingInput {
  AND: [ProjectHavingInput!]
  OR: [ProjectHavingInput!]
  sum: ProjectHavingSumInput
  distinctCount: ProjectHavingDistinctCountInput
  min: ProjectHavingMinInput
  max: ProjectHavingMaxInput
  average: ProjectHavingAverageInput
  stddevSample: ProjectHavingStddevSampleInput
  stddevPopulation: ProjectHavingStddevPopulationInput
  varianceSample: ProjectHavingVarianceSampleInput
  variancePopulation: ProjectHavingVariancePopulationInput
}

input ProjectHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input HavingDatetimeFilter {
  equalTo: Datetime
  notEqualTo: Datetime
  greaterThan: Datetime
  greaterThanOrEqualTo: Datetime
  lessThan: Datetime
  lessThanOrEqualTo: Datetime
}

input ProjectHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering \`Project\`."""
enum ProjectOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  SLUG_ASC
  SLUG_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  POSTS_COUNT_ASC
  POSTS_COUNT_DESC
  POSTS_DISTINCT_COUNT_ROW_ID_ASC
  POSTS_DISTINCT_COUNT_ROW_ID_DESC
  POSTS_DISTINCT_COUNT_TITLE_ASC
  POSTS_DISTINCT_COUNT_TITLE_DESC
  POSTS_DISTINCT_COUNT_DESCRIPTION_ASC
  POSTS_DISTINCT_COUNT_DESCRIPTION_DESC
  POSTS_DISTINCT_COUNT_PROJECT_ID_ASC
  POSTS_DISTINCT_COUNT_PROJECT_ID_DESC
  POSTS_DISTINCT_COUNT_USER_ID_ASC
  POSTS_DISTINCT_COUNT_USER_ID_DESC
  POSTS_DISTINCT_COUNT_CREATED_AT_ASC
  POSTS_DISTINCT_COUNT_CREATED_AT_DESC
  POSTS_DISTINCT_COUNT_UPDATED_AT_ASC
  POSTS_DISTINCT_COUNT_UPDATED_AT_DESC
  POSTS_DISTINCT_COUNT_STATUS_ID_ASC
  POSTS_DISTINCT_COUNT_STATUS_ID_DESC
  POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_ASC
  POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_DESC
  POST_STATUSES_COUNT_ASC
  POST_STATUSES_COUNT_DESC
  POST_STATUSES_DISTINCT_COUNT_ROW_ID_ASC
  POST_STATUSES_DISTINCT_COUNT_ROW_ID_DESC
  POST_STATUSES_DISTINCT_COUNT_STATUS_ASC
  POST_STATUSES_DISTINCT_COUNT_STATUS_DESC
  POST_STATUSES_DISTINCT_COUNT_DESCRIPTION_ASC
  POST_STATUSES_DISTINCT_COUNT_DESCRIPTION_DESC
  POST_STATUSES_DISTINCT_COUNT_COLOR_ASC
  POST_STATUSES_DISTINCT_COUNT_COLOR_DESC
  POST_STATUSES_DISTINCT_COUNT_PROJECT_ID_ASC
  POST_STATUSES_DISTINCT_COUNT_PROJECT_ID_DESC
  POST_STATUSES_DISTINCT_COUNT_IS_DEFAULT_ASC
  POST_STATUSES_DISTINCT_COUNT_IS_DEFAULT_DESC
  POST_STATUSES_DISTINCT_COUNT_CREATED_AT_ASC
  POST_STATUSES_DISTINCT_COUNT_CREATED_AT_DESC
  POST_STATUSES_DISTINCT_COUNT_UPDATED_AT_ASC
  POST_STATUSES_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""
A condition to be used against \`Project\` object types. All fields are tested for equality and combined with a logical and.
"""
input ProjectCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`name\` field."""
  name: String

  """Checks for equality with the objects \`image\` field."""
  image: String

  """Checks for equality with the objects \`slug\` field."""
  slug: String

  """Checks for equality with the objects \`description\` field."""
  description: String

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime
}

"""
A filter to be used against \`Project\` object types. All fields are combined with a logical and.
"""
input ProjectFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`name\` field."""
  name: StringFilter

  """Filter by the objects \`image\` field."""
  image: StringFilter

  """Filter by the objects \`slug\` field."""
  slug: StringFilter

  """Filter by the objects \`description\` field."""
  description: StringFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`posts\` relation."""
  posts: ProjectToManyPostFilter

  """Some related \`posts\` exist."""
  postsExist: Boolean

  """Filter by the objects \`postStatuses\` relation."""
  postStatuses: ProjectToManyPostStatusFilter

  """Some related \`postStatuses\` exist."""
  postStatusesExist: Boolean

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Checks for all expressions in this list."""
  and: [ProjectFilter!]

  """Checks for any expressions in this list."""
  or: [ProjectFilter!]

  """Negates the expression."""
  not: ProjectFilter
}

"""
A filter to be used against UUID fields. All fields are combined with a logical and.
"""
input UUIDFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: UUID

  """Not equal to the specified value."""
  notEqualTo: UUID

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: UUID

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: UUID

  """Included in the specified list."""
  in: [UUID!]

  """Not included in the specified list."""
  notIn: [UUID!]

  """Less than the specified value."""
  lessThan: UUID

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: UUID

  """Greater than the specified value."""
  greaterThan: UUID

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: UUID
}

"""
A filter to be used against String fields. All fields are combined with a logical and.
"""
input StringFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String
}

"""
A filter to be used against Datetime fields. All fields are combined with a logical and.
"""
input DatetimeFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Datetime

  """Not equal to the specified value."""
  notEqualTo: Datetime

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Datetime

  """Included in the specified list."""
  in: [Datetime!]

  """Not included in the specified list."""
  notIn: [Datetime!]

  """Less than the specified value."""
  lessThan: Datetime

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Datetime

  """Greater than the specified value."""
  greaterThan: Datetime

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Datetime
}

"""
A filter to be used against many \`Post\` object types. All fields are combined with a logical and.
"""
input ProjectToManyPostFilter {
  """
  Every related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PostFilter

  """
  Some related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PostFilter

  """
  No related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PostFilter

  """Aggregates across related \`Post\` match the filter criteria."""
  aggregates: PostAggregatesFilter
}

"""
A filter to be used against \`Post\` object types. All fields are combined with a logical and.
"""
input PostFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`title\` field."""
  title: StringFilter

  """Filter by the objects \`description\` field."""
  description: StringFilter

  """Filter by the objects \`projectId\` field."""
  projectId: UUIDFilter

  """Filter by the objects \`userId\` field."""
  userId: UUIDFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`statusId\` field."""
  statusId: UUIDFilter

  """Filter by the objects \`statusUpdatedAt\` field."""
  statusUpdatedAt: DatetimeFilter

  """Filter by the objects \`upvotes\` relation."""
  upvotes: PostToManyUpvoteFilter

  """Some related \`upvotes\` exist."""
  upvotesExist: Boolean

  """Filter by the objects \`comments\` relation."""
  comments: PostToManyCommentFilter

  """Some related \`comments\` exist."""
  commentsExist: Boolean

  """Filter by the objects \`downvotes\` relation."""
  downvotes: PostToManyDownvoteFilter

  """Some related \`downvotes\` exist."""
  downvotesExist: Boolean

  """Filter by the objects \`project\` relation."""
  project: ProjectFilter

  """Filter by the objects \`status\` relation."""
  status: PostStatusFilter

  """A related \`status\` exists."""
  statusExists: Boolean

  """Filter by the objects \`user\` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [PostFilter!]

  """Checks for any expressions in this list."""
  or: [PostFilter!]

  """Negates the expression."""
  not: PostFilter
}

"""
A filter to be used against many \`Upvote\` object types. All fields are combined with a logical and.
"""
input PostToManyUpvoteFilter {
  """
  Every related \`Upvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: UpvoteFilter

  """
  Some related \`Upvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: UpvoteFilter

  """
  No related \`Upvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: UpvoteFilter

  """Aggregates across related \`Upvote\` match the filter criteria."""
  aggregates: UpvoteAggregatesFilter
}

"""
A filter to be used against \`Upvote\` object types. All fields are combined with a logical and.
"""
input UpvoteFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`postId\` field."""
  postId: UUIDFilter

  """Filter by the objects \`userId\` field."""
  userId: UUIDFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`post\` relation."""
  post: PostFilter

  """Filter by the objects \`user\` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [UpvoteFilter!]

  """Checks for any expressions in this list."""
  or: [UpvoteFilter!]

  """Negates the expression."""
  not: UpvoteFilter
}

"""
A filter to be used against \`User\` object types. All fields are combined with a logical and.
"""
input UserFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`hidraId\` field."""
  hidraId: UUIDFilter

  """Filter by the objects \`username\` field."""
  username: StringFilter

  """Filter by the objects \`firstName\` field."""
  firstName: StringFilter

  """Filter by the objects \`lastName\` field."""
  lastName: StringFilter

  """Filter by the objects \`email\` field."""
  email: StringFilter

  """Filter by the objects \`posts\` relation."""
  posts: UserToManyPostFilter

  """Some related \`posts\` exist."""
  postsExist: Boolean

  """Filter by the objects \`upvotes\` relation."""
  upvotes: UserToManyUpvoteFilter

  """Some related \`upvotes\` exist."""
  upvotesExist: Boolean

  """Filter by the objects \`members\` relation."""
  members: UserToManyMemberFilter

  """Some related \`members\` exist."""
  membersExist: Boolean

  """Filter by the objects \`comments\` relation."""
  comments: UserToManyCommentFilter

  """Some related \`comments\` exist."""
  commentsExist: Boolean

  """Filter by the objects \`downvotes\` relation."""
  downvotes: UserToManyDownvoteFilter

  """Some related \`downvotes\` exist."""
  downvotesExist: Boolean

  """Checks for all expressions in this list."""
  and: [UserFilter!]

  """Checks for any expressions in this list."""
  or: [UserFilter!]

  """Negates the expression."""
  not: UserFilter
}

"""
A filter to be used against many \`Post\` object types. All fields are combined with a logical and.
"""
input UserToManyPostFilter {
  """
  Every related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PostFilter

  """
  Some related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PostFilter

  """
  No related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PostFilter

  """Aggregates across related \`Post\` match the filter criteria."""
  aggregates: PostAggregatesFilter
}

"""A filter to be used against aggregates of \`Post\` object types."""
input PostAggregatesFilter {
  """
  A filter that must pass for the relevant \`Post\` object to be included within the aggregate.
  """
  filter: PostFilter

  """Distinct count aggregate over matching \`Post\` objects."""
  distinctCount: PostDistinctCountAggregateFilter
}

input PostDistinctCountAggregateFilter {
  rowId: BigIntFilter
  title: BigIntFilter
  description: BigIntFilter
  projectId: BigIntFilter
  userId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  statusId: BigIntFilter
  statusUpdatedAt: BigIntFilter
}

"""
A filter to be used against BigInt fields. All fields are combined with a logical and.
"""
input BigIntFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigInt

  """Not equal to the specified value."""
  notEqualTo: BigInt

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigInt

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigInt

  """Included in the specified list."""
  in: [BigInt!]

  """Not included in the specified list."""
  notIn: [BigInt!]

  """Less than the specified value."""
  lessThan: BigInt

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigInt

  """Greater than the specified value."""
  greaterThan: BigInt

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigInt
}

"""
A filter to be used against many \`Upvote\` object types. All fields are combined with a logical and.
"""
input UserToManyUpvoteFilter {
  """
  Every related \`Upvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: UpvoteFilter

  """
  Some related \`Upvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: UpvoteFilter

  """
  No related \`Upvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: UpvoteFilter

  """Aggregates across related \`Upvote\` match the filter criteria."""
  aggregates: UpvoteAggregatesFilter
}

"""A filter to be used against aggregates of \`Upvote\` object types."""
input UpvoteAggregatesFilter {
  """
  A filter that must pass for the relevant \`Upvote\` object to be included within the aggregate.
  """
  filter: UpvoteFilter

  """Distinct count aggregate over matching \`Upvote\` objects."""
  distinctCount: UpvoteDistinctCountAggregateFilter
}

input UpvoteDistinctCountAggregateFilter {
  rowId: BigIntFilter
  postId: BigIntFilter
  userId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many \`Member\` object types. All fields are combined with a logical and.
"""
input UserToManyMemberFilter {
  """
  Every related \`Member\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: MemberFilter

  """
  Some related \`Member\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: MemberFilter

  """
  No related \`Member\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: MemberFilter

  """Aggregates across related \`Member\` match the filter criteria."""
  aggregates: MemberAggregatesFilter
}

"""
A filter to be used against \`Member\` object types. All fields are combined with a logical and.
"""
input MemberFilter {
  """Filter by the objects \`userId\` field."""
  userId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`role\` field."""
  role: RoleFilter

  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Filter by the objects \`user\` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [MemberFilter!]

  """Checks for any expressions in this list."""
  or: [MemberFilter!]

  """Negates the expression."""
  not: MemberFilter
}

"""
A filter to be used against Role fields. All fields are combined with a logical and.
"""
input RoleFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Role

  """Not equal to the specified value."""
  notEqualTo: Role

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Role

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Role

  """Included in the specified list."""
  in: [Role!]

  """Not included in the specified list."""
  notIn: [Role!]

  """Less than the specified value."""
  lessThan: Role

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Role

  """Greater than the specified value."""
  greaterThan: Role

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Role
}

enum Role {
  owner
  admin
  member
}

"""
A filter to be used against \`Organization\` object types. All fields are combined with a logical and.
"""
input OrganizationFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`name\` field."""
  name: StringFilter

  """Filter by the objects \`slug\` field."""
  slug: StringFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`projects\` relation."""
  projects: OrganizationToManyProjectFilter

  """Some related \`projects\` exist."""
  projectsExist: Boolean

  """Filter by the objects \`members\` relation."""
  members: OrganizationToManyMemberFilter

  """Some related \`members\` exist."""
  membersExist: Boolean

  """Filter by the objects \`invitations\` relation."""
  invitations: OrganizationToManyInvitationFilter

  """Some related \`invitations\` exist."""
  invitationsExist: Boolean

  """Checks for all expressions in this list."""
  and: [OrganizationFilter!]

  """Checks for any expressions in this list."""
  or: [OrganizationFilter!]

  """Negates the expression."""
  not: OrganizationFilter
}

"""
A filter to be used against many \`Project\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyProjectFilter {
  """
  Every related \`Project\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: ProjectFilter

  """
  Some related \`Project\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: ProjectFilter

  """
  No related \`Project\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: ProjectFilter

  """Aggregates across related \`Project\` match the filter criteria."""
  aggregates: ProjectAggregatesFilter
}

"""A filter to be used against aggregates of \`Project\` object types."""
input ProjectAggregatesFilter {
  """
  A filter that must pass for the relevant \`Project\` object to be included within the aggregate.
  """
  filter: ProjectFilter

  """Distinct count aggregate over matching \`Project\` objects."""
  distinctCount: ProjectDistinctCountAggregateFilter
}

input ProjectDistinctCountAggregateFilter {
  rowId: BigIntFilter
  name: BigIntFilter
  image: BigIntFilter
  slug: BigIntFilter
  description: BigIntFilter
  organizationId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many \`Member\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyMemberFilter {
  """
  Every related \`Member\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: MemberFilter

  """
  Some related \`Member\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: MemberFilter

  """
  No related \`Member\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: MemberFilter

  """Aggregates across related \`Member\` match the filter criteria."""
  aggregates: MemberAggregatesFilter
}

"""A filter to be used against aggregates of \`Member\` object types."""
input MemberAggregatesFilter {
  """
  A filter that must pass for the relevant \`Member\` object to be included within the aggregate.
  """
  filter: MemberFilter

  """Distinct count aggregate over matching \`Member\` objects."""
  distinctCount: MemberDistinctCountAggregateFilter
}

input MemberDistinctCountAggregateFilter {
  userId: BigIntFilter
  organizationId: BigIntFilter
  createdAt: BigIntFilter
  role: BigIntFilter
  rowId: BigIntFilter
}

"""
A filter to be used against many \`Invitation\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyInvitationFilter {
  """
  Every related \`Invitation\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: InvitationFilter

  """
  Some related \`Invitation\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: InvitationFilter

  """
  No related \`Invitation\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: InvitationFilter

  """Aggregates across related \`Invitation\` match the filter criteria."""
  aggregates: InvitationAggregatesFilter
}

"""
A filter to be used against \`Invitation\` object types. All fields are combined with a logical and.
"""
input InvitationFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`email\` field."""
  email: StringFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Checks for all expressions in this list."""
  and: [InvitationFilter!]

  """Checks for any expressions in this list."""
  or: [InvitationFilter!]

  """Negates the expression."""
  not: InvitationFilter
}

"""A filter to be used against aggregates of \`Invitation\` object types."""
input InvitationAggregatesFilter {
  """
  A filter that must pass for the relevant \`Invitation\` object to be included within the aggregate.
  """
  filter: InvitationFilter

  """Distinct count aggregate over matching \`Invitation\` objects."""
  distinctCount: InvitationDistinctCountAggregateFilter
}

input InvitationDistinctCountAggregateFilter {
  rowId: BigIntFilter
  organizationId: BigIntFilter
  email: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many \`Comment\` object types. All fields are combined with a logical and.
"""
input UserToManyCommentFilter {
  """
  Every related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: CommentFilter

  """
  Some related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: CommentFilter

  """
  No related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: CommentFilter

  """Aggregates across related \`Comment\` match the filter criteria."""
  aggregates: CommentAggregatesFilter
}

"""
A filter to be used against \`Comment\` object types. All fields are combined with a logical and.
"""
input CommentFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`message\` field."""
  message: StringFilter

  """Filter by the objects \`postId\` field."""
  postId: UUIDFilter

  """Filter by the objects \`userId\` field."""
  userId: UUIDFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`post\` relation."""
  post: PostFilter

  """Filter by the objects \`user\` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [CommentFilter!]

  """Checks for any expressions in this list."""
  or: [CommentFilter!]

  """Negates the expression."""
  not: CommentFilter
}

"""A filter to be used against aggregates of \`Comment\` object types."""
input CommentAggregatesFilter {
  """
  A filter that must pass for the relevant \`Comment\` object to be included within the aggregate.
  """
  filter: CommentFilter

  """Distinct count aggregate over matching \`Comment\` objects."""
  distinctCount: CommentDistinctCountAggregateFilter
}

input CommentDistinctCountAggregateFilter {
  rowId: BigIntFilter
  message: BigIntFilter
  postId: BigIntFilter
  userId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many \`Downvote\` object types. All fields are combined with a logical and.
"""
input UserToManyDownvoteFilter {
  """
  Every related \`Downvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: DownvoteFilter

  """
  Some related \`Downvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: DownvoteFilter

  """
  No related \`Downvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: DownvoteFilter

  """Aggregates across related \`Downvote\` match the filter criteria."""
  aggregates: DownvoteAggregatesFilter
}

"""
A filter to be used against \`Downvote\` object types. All fields are combined with a logical and.
"""
input DownvoteFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`postId\` field."""
  postId: UUIDFilter

  """Filter by the objects \`userId\` field."""
  userId: UUIDFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`post\` relation."""
  post: PostFilter

  """Filter by the objects \`user\` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [DownvoteFilter!]

  """Checks for any expressions in this list."""
  or: [DownvoteFilter!]

  """Negates the expression."""
  not: DownvoteFilter
}

"""A filter to be used against aggregates of \`Downvote\` object types."""
input DownvoteAggregatesFilter {
  """
  A filter that must pass for the relevant \`Downvote\` object to be included within the aggregate.
  """
  filter: DownvoteFilter

  """Distinct count aggregate over matching \`Downvote\` objects."""
  distinctCount: DownvoteDistinctCountAggregateFilter
}

input DownvoteDistinctCountAggregateFilter {
  rowId: BigIntFilter
  postId: BigIntFilter
  userId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many \`Comment\` object types. All fields are combined with a logical and.
"""
input PostToManyCommentFilter {
  """
  Every related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: CommentFilter

  """
  Some related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: CommentFilter

  """
  No related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: CommentFilter

  """Aggregates across related \`Comment\` match the filter criteria."""
  aggregates: CommentAggregatesFilter
}

"""
A filter to be used against many \`Downvote\` object types. All fields are combined with a logical and.
"""
input PostToManyDownvoteFilter {
  """
  Every related \`Downvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: DownvoteFilter

  """
  Some related \`Downvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: DownvoteFilter

  """
  No related \`Downvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: DownvoteFilter

  """Aggregates across related \`Downvote\` match the filter criteria."""
  aggregates: DownvoteAggregatesFilter
}

"""
A filter to be used against \`PostStatus\` object types. All fields are combined with a logical and.
"""
input PostStatusFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`status\` field."""
  status: StringFilter

  """Filter by the objects \`description\` field."""
  description: StringFilter

  """Filter by the objects \`color\` field."""
  color: StringFilter

  """Filter by the objects \`projectId\` field."""
  projectId: UUIDFilter

  """Filter by the objects \`isDefault\` field."""
  isDefault: BooleanFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`postsByStatusId\` relation."""
  postsByStatusId: PostStatusToManyPostFilter

  """Some related \`postsByStatusId\` exist."""
  postsByStatusIdExist: Boolean

  """Filter by the objects \`project\` relation."""
  project: ProjectFilter

  """Checks for all expressions in this list."""
  and: [PostStatusFilter!]

  """Checks for any expressions in this list."""
  or: [PostStatusFilter!]

  """Negates the expression."""
  not: PostStatusFilter
}

"""
A filter to be used against Boolean fields. All fields are combined with a logical and.
"""
input BooleanFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Boolean

  """Not equal to the specified value."""
  notEqualTo: Boolean

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Boolean

  """Included in the specified list."""
  in: [Boolean!]

  """Not included in the specified list."""
  notIn: [Boolean!]

  """Less than the specified value."""
  lessThan: Boolean

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Boolean

  """Greater than the specified value."""
  greaterThan: Boolean

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Boolean
}

"""
A filter to be used against many \`Post\` object types. All fields are combined with a logical and.
"""
input PostStatusToManyPostFilter {
  """
  Every related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PostFilter

  """
  Some related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PostFilter

  """
  No related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PostFilter

  """Aggregates across related \`Post\` match the filter criteria."""
  aggregates: PostAggregatesFilter
}

"""
A filter to be used against many \`PostStatus\` object types. All fields are combined with a logical and.
"""
input ProjectToManyPostStatusFilter {
  """
  Every related \`PostStatus\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PostStatusFilter

  """
  Some related \`PostStatus\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PostStatusFilter

  """
  No related \`PostStatus\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PostStatusFilter

  """Aggregates across related \`PostStatus\` match the filter criteria."""
  aggregates: PostStatusAggregatesFilter
}

"""A filter to be used against aggregates of \`PostStatus\` object types."""
input PostStatusAggregatesFilter {
  """
  A filter that must pass for the relevant \`PostStatus\` object to be included within the aggregate.
  """
  filter: PostStatusFilter

  """Distinct count aggregate over matching \`PostStatus\` objects."""
  distinctCount: PostStatusDistinctCountAggregateFilter
}

input PostStatusDistinctCountAggregateFilter {
  rowId: BigIntFilter
  status: BigIntFilter
  description: BigIntFilter
  color: BigIntFilter
  projectId: BigIntFilter
  isDefault: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""A connection to a list of \`Member\` values."""
type MemberConnection {
  """A list of \`Member\` objects."""
  nodes: [Member]!

  """
  A list of edges which contains the \`Member\` and cursor to aid in pagination.
  """
  edges: [MemberEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Member\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: MemberAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Member\` for these aggregates."""
    groupBy: [MemberGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: MemberHavingInput
  ): [MemberAggregates!]
}

type Member {
  userId: UUID!
  organizationId: UUID!
  createdAt: Datetime
  role: Role!
  rowId: UUID!

  """Reads a single \`Organization\` that is related to this \`Member\`."""
  organization: Organization

  """Reads a single \`User\` that is related to this \`Member\`."""
  user: User
}

type User {
  rowId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
  hidraId: UUID!
  username: String
  firstName: String
  lastName: String
  email: String!

  """Reads and enables pagination through a set of \`Post\`."""
  posts(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter
  ): PostConnection!

  """Reads and enables pagination through a set of \`Upvote\`."""
  upvotes(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Upvote\`."""
    orderBy: [UpvoteOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UpvoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UpvoteFilter
  ): UpvoteConnection!

  """Reads and enables pagination through a set of \`Member\`."""
  members(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Member\`."""
    orderBy: [MemberOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MemberFilter
  ): MemberConnection!

  """Reads and enables pagination through a set of \`Comment\`."""
  comments(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Comment\`."""
    orderBy: [CommentOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CommentFilter
  ): CommentConnection!

  """Reads and enables pagination through a set of \`Downvote\`."""
  downvotes(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Downvote\`."""
    orderBy: [DownvoteOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DownvoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DownvoteFilter
  ): DownvoteConnection!
}

"""A connection to a list of \`Post\` values."""
type PostConnection {
  """A list of \`Post\` objects."""
  nodes: [Post]!

  """
  A list of edges which contains the \`Post\` and cursor to aid in pagination.
  """
  edges: [PostEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Post\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: PostAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Post\` for these aggregates."""
    groupBy: [PostGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: PostHavingInput
  ): [PostAggregates!]
}

"""A \`Post\` edge in the connection."""
type PostEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Post\` at the end of the edge."""
  node: Post
}

type PostAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: PostDistinctCountAggregates
}

type PostDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of title across the matching connection"""
  title: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of statusId across the matching connection"""
  statusId: BigInt

  """Distinct count of statusUpdatedAt across the matching connection"""
  statusUpdatedAt: BigInt
}

"""Grouping methods for \`Post\` for usage during aggregation."""
enum PostGroupBy {
  TITLE
  DESCRIPTION
  PROJECT_ID
  USER_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  STATUS_ID
  STATUS_UPDATED_AT
  STATUS_UPDATED_AT_TRUNCATED_TO_HOUR
  STATUS_UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`Post\` aggregates."""
input PostHavingInput {
  AND: [PostHavingInput!]
  OR: [PostHavingInput!]
  sum: PostHavingSumInput
  distinctCount: PostHavingDistinctCountInput
  min: PostHavingMinInput
  max: PostHavingMaxInput
  average: PostHavingAverageInput
  stddevSample: PostHavingStddevSampleInput
  stddevPopulation: PostHavingStddevPopulationInput
  varianceSample: PostHavingVarianceSampleInput
  variancePopulation: PostHavingVariancePopulationInput
}

input PostHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering \`Post\`."""
enum PostOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  STATUS_ID_ASC
  STATUS_ID_DESC
  STATUS_UPDATED_AT_ASC
  STATUS_UPDATED_AT_DESC
  UPVOTES_COUNT_ASC
  UPVOTES_COUNT_DESC
  UPVOTES_DISTINCT_COUNT_ROW_ID_ASC
  UPVOTES_DISTINCT_COUNT_ROW_ID_DESC
  UPVOTES_DISTINCT_COUNT_POST_ID_ASC
  UPVOTES_DISTINCT_COUNT_POST_ID_DESC
  UPVOTES_DISTINCT_COUNT_USER_ID_ASC
  UPVOTES_DISTINCT_COUNT_USER_ID_DESC
  UPVOTES_DISTINCT_COUNT_CREATED_AT_ASC
  UPVOTES_DISTINCT_COUNT_CREATED_AT_DESC
  UPVOTES_DISTINCT_COUNT_UPDATED_AT_ASC
  UPVOTES_DISTINCT_COUNT_UPDATED_AT_DESC
  COMMENTS_COUNT_ASC
  COMMENTS_COUNT_DESC
  COMMENTS_DISTINCT_COUNT_ROW_ID_ASC
  COMMENTS_DISTINCT_COUNT_ROW_ID_DESC
  COMMENTS_DISTINCT_COUNT_MESSAGE_ASC
  COMMENTS_DISTINCT_COUNT_MESSAGE_DESC
  COMMENTS_DISTINCT_COUNT_POST_ID_ASC
  COMMENTS_DISTINCT_COUNT_POST_ID_DESC
  COMMENTS_DISTINCT_COUNT_USER_ID_ASC
  COMMENTS_DISTINCT_COUNT_USER_ID_DESC
  COMMENTS_DISTINCT_COUNT_CREATED_AT_ASC
  COMMENTS_DISTINCT_COUNT_CREATED_AT_DESC
  COMMENTS_DISTINCT_COUNT_UPDATED_AT_ASC
  COMMENTS_DISTINCT_COUNT_UPDATED_AT_DESC
  DOWNVOTES_COUNT_ASC
  DOWNVOTES_COUNT_DESC
  DOWNVOTES_DISTINCT_COUNT_ROW_ID_ASC
  DOWNVOTES_DISTINCT_COUNT_ROW_ID_DESC
  DOWNVOTES_DISTINCT_COUNT_POST_ID_ASC
  DOWNVOTES_DISTINCT_COUNT_POST_ID_DESC
  DOWNVOTES_DISTINCT_COUNT_USER_ID_ASC
  DOWNVOTES_DISTINCT_COUNT_USER_ID_DESC
  DOWNVOTES_DISTINCT_COUNT_CREATED_AT_ASC
  DOWNVOTES_DISTINCT_COUNT_CREATED_AT_DESC
  DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_ASC
  DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""
A condition to be used against \`Post\` object types. All fields are tested for equality and combined with a logical and.
"""
input PostCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`title\` field."""
  title: String

  """Checks for equality with the objects \`description\` field."""
  description: String

  """Checks for equality with the objects \`projectId\` field."""
  projectId: UUID

  """Checks for equality with the objects \`userId\` field."""
  userId: UUID

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime

  """Checks for equality with the objects \`statusId\` field."""
  statusId: UUID

  """Checks for equality with the objects \`statusUpdatedAt\` field."""
  statusUpdatedAt: Datetime
}

"""A connection to a list of \`Upvote\` values."""
type UpvoteConnection {
  """A list of \`Upvote\` objects."""
  nodes: [Upvote]!

  """
  A list of edges which contains the \`Upvote\` and cursor to aid in pagination.
  """
  edges: [UpvoteEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Upvote\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: UpvoteAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Upvote\` for these aggregates."""
    groupBy: [UpvoteGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: UpvoteHavingInput
  ): [UpvoteAggregates!]
}

type Upvote {
  rowId: UUID!
  postId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Post\` that is related to this \`Upvote\`."""
  post: Post

  """Reads a single \`User\` that is related to this \`Upvote\`."""
  user: User
}

"""A \`Upvote\` edge in the connection."""
type UpvoteEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Upvote\` at the end of the edge."""
  node: Upvote
}

type UpvoteAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: UpvoteDistinctCountAggregates
}

type UpvoteDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of postId across the matching connection"""
  postId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for \`Upvote\` for usage during aggregation."""
enum UpvoteGroupBy {
  POST_ID
  USER_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`Upvote\` aggregates."""
input UpvoteHavingInput {
  AND: [UpvoteHavingInput!]
  OR: [UpvoteHavingInput!]
  sum: UpvoteHavingSumInput
  distinctCount: UpvoteHavingDistinctCountInput
  min: UpvoteHavingMinInput
  max: UpvoteHavingMaxInput
  average: UpvoteHavingAverageInput
  stddevSample: UpvoteHavingStddevSampleInput
  stddevPopulation: UpvoteHavingStddevPopulationInput
  varianceSample: UpvoteHavingVarianceSampleInput
  variancePopulation: UpvoteHavingVariancePopulationInput
}

input UpvoteHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering \`Upvote\`."""
enum UpvoteOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  POST_ID_ASC
  POST_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""
A condition to be used against \`Upvote\` object types. All fields are tested for equality and combined with a logical and.
"""
input UpvoteCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`postId\` field."""
  postId: UUID

  """Checks for equality with the objects \`userId\` field."""
  userId: UUID

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering \`Member\`."""
enum MemberOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ROLE_ASC
  ROLE_DESC
  ROW_ID_ASC
  ROW_ID_DESC
}

"""
A condition to be used against \`Member\` object types. All fields are tested for equality and combined with a logical and.
"""
input MemberCondition {
  """Checks for equality with the objects \`userId\` field."""
  userId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`role\` field."""
  role: Role

  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID
}

"""A connection to a list of \`Comment\` values."""
type CommentConnection {
  """A list of \`Comment\` objects."""
  nodes: [Comment]!

  """
  A list of edges which contains the \`Comment\` and cursor to aid in pagination.
  """
  edges: [CommentEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Comment\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: CommentAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Comment\` for these aggregates."""
    groupBy: [CommentGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: CommentHavingInput
  ): [CommentAggregates!]
}

type Comment {
  rowId: UUID!
  message: String
  postId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Post\` that is related to this \`Comment\`."""
  post: Post

  """Reads a single \`User\` that is related to this \`Comment\`."""
  user: User
}

"""A \`Comment\` edge in the connection."""
type CommentEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Comment\` at the end of the edge."""
  node: Comment
}

type CommentAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: CommentDistinctCountAggregates
}

type CommentDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of message across the matching connection"""
  message: BigInt

  """Distinct count of postId across the matching connection"""
  postId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for \`Comment\` for usage during aggregation."""
enum CommentGroupBy {
  MESSAGE
  POST_ID
  USER_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`Comment\` aggregates."""
input CommentHavingInput {
  AND: [CommentHavingInput!]
  OR: [CommentHavingInput!]
  sum: CommentHavingSumInput
  distinctCount: CommentHavingDistinctCountInput
  min: CommentHavingMinInput
  max: CommentHavingMaxInput
  average: CommentHavingAverageInput
  stddevSample: CommentHavingStddevSampleInput
  stddevPopulation: CommentHavingStddevPopulationInput
  varianceSample: CommentHavingVarianceSampleInput
  variancePopulation: CommentHavingVariancePopulationInput
}

input CommentHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering \`Comment\`."""
enum CommentOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  MESSAGE_ASC
  MESSAGE_DESC
  POST_ID_ASC
  POST_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""
A condition to be used against \`Comment\` object types. All fields are tested for equality and combined with a logical and.
"""
input CommentCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`message\` field."""
  message: String

  """Checks for equality with the objects \`postId\` field."""
  postId: UUID

  """Checks for equality with the objects \`userId\` field."""
  userId: UUID

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime
}

"""A connection to a list of \`Downvote\` values."""
type DownvoteConnection {
  """A list of \`Downvote\` objects."""
  nodes: [Downvote]!

  """
  A list of edges which contains the \`Downvote\` and cursor to aid in pagination.
  """
  edges: [DownvoteEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Downvote\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: DownvoteAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Downvote\` for these aggregates."""
    groupBy: [DownvoteGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: DownvoteHavingInput
  ): [DownvoteAggregates!]
}

"""A \`Downvote\` edge in the connection."""
type DownvoteEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Downvote\` at the end of the edge."""
  node: Downvote
}

type DownvoteAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: DownvoteDistinctCountAggregates
}

type DownvoteDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of postId across the matching connection"""
  postId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for \`Downvote\` for usage during aggregation."""
enum DownvoteGroupBy {
  POST_ID
  USER_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`Downvote\` aggregates."""
input DownvoteHavingInput {
  AND: [DownvoteHavingInput!]
  OR: [DownvoteHavingInput!]
  sum: DownvoteHavingSumInput
  distinctCount: DownvoteHavingDistinctCountInput
  min: DownvoteHavingMinInput
  max: DownvoteHavingMaxInput
  average: DownvoteHavingAverageInput
  stddevSample: DownvoteHavingStddevSampleInput
  stddevPopulation: DownvoteHavingStddevPopulationInput
  varianceSample: DownvoteHavingVarianceSampleInput
  variancePopulation: DownvoteHavingVariancePopulationInput
}

input DownvoteHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering \`Downvote\`."""
enum DownvoteOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  POST_ID_ASC
  POST_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""
A condition to be used against \`Downvote\` object types. All fields are tested
for equality and combined with a logical and.
"""
input DownvoteCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`postId\` field."""
  postId: UUID

  """Checks for equality with the objects \`userId\` field."""
  userId: UUID

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime
}

"""A \`Member\` edge in the connection."""
type MemberEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Member\` at the end of the edge."""
  node: Member
}

type MemberAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: MemberDistinctCountAggregates
}

type MemberDistinctCountAggregates {
  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of role across the matching connection"""
  role: BigInt

  """Distinct count of rowId across the matching connection"""
  rowId: BigInt
}

"""Grouping methods for \`Member\` for usage during aggregation."""
enum MemberGroupBy {
  USER_ID
  ORGANIZATION_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  ROLE
}

"""Conditions for \`Member\` aggregates."""
input MemberHavingInput {
  AND: [MemberHavingInput!]
  OR: [MemberHavingInput!]
  sum: MemberHavingSumInput
  distinctCount: MemberHavingDistinctCountInput
  min: MemberHavingMinInput
  max: MemberHavingMaxInput
  average: MemberHavingAverageInput
  stddevSample: MemberHavingStddevSampleInput
  stddevPopulation: MemberHavingStddevPopulationInput
  varianceSample: MemberHavingVarianceSampleInput
  variancePopulation: MemberHavingVariancePopulationInput
}

input MemberHavingSumInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingMinInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingMaxInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingAverageInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
}

"""A connection to a list of \`Invitation\` values."""
type InvitationConnection {
  """A list of \`Invitation\` objects."""
  nodes: [Invitation]!

  """
  A list of edges which contains the \`Invitation\` and cursor to aid in pagination.
  """
  edges: [InvitationEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Invitation\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: InvitationAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Invitation\` for these aggregates."""
    groupBy: [InvitationGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: InvitationHavingInput
  ): [InvitationAggregates!]
}

type Invitation {
  rowId: UUID!
  organizationId: UUID!
  email: String!
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Organization\` that is related to this \`Invitation\`."""
  organization: Organization
}

"""A \`Invitation\` edge in the connection."""
type InvitationEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Invitation\` at the end of the edge."""
  node: Invitation
}

type InvitationAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: InvitationDistinctCountAggregates
}

type InvitationDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of email across the matching connection"""
  email: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for \`Invitation\` for usage during aggregation."""
enum InvitationGroupBy {
  ORGANIZATION_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`Invitation\` aggregates."""
input InvitationHavingInput {
  AND: [InvitationHavingInput!]
  OR: [InvitationHavingInput!]
  sum: InvitationHavingSumInput
  distinctCount: InvitationHavingDistinctCountInput
  min: InvitationHavingMinInput
  max: InvitationHavingMaxInput
  average: InvitationHavingAverageInput
  stddevSample: InvitationHavingStddevSampleInput
  stddevPopulation: InvitationHavingStddevPopulationInput
  varianceSample: InvitationHavingVarianceSampleInput
  variancePopulation: InvitationHavingVariancePopulationInput
}

input InvitationHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering \`Invitation\`."""
enum InvitationOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""
A condition to be used against \`Invitation\` object types. All fields are tested
for equality and combined with a logical and.
"""
input InvitationCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`email\` field."""
  email: String

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime
}

"""A connection to a list of \`PostStatus\` values."""
type PostStatusConnection {
  """A list of \`PostStatus\` objects."""
  nodes: [PostStatus]!

  """
  A list of edges which contains the \`PostStatus\` and cursor to aid in pagination.
  """
  edges: [PostStatusEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`PostStatus\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: PostStatusAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`PostStatus\` for these aggregates."""
    groupBy: [PostStatusGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: PostStatusHavingInput
  ): [PostStatusAggregates!]
}

type PostStatus {
  rowId: UUID!
  status: String!
  description: String
  color: String
  projectId: UUID!
  isDefault: Boolean!
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Project\` that is related to this \`PostStatus\`."""
  project: Project

  """Reads and enables pagination through a set of \`Post\`."""
  postsByStatusId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter
  ): PostConnection!
}

"""A \`PostStatus\` edge in the connection."""
type PostStatusEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`PostStatus\` at the end of the edge."""
  node: PostStatus
}

type PostStatusAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: PostStatusDistinctCountAggregates
}

type PostStatusDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of status across the matching connection"""
  status: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of color across the matching connection"""
  color: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of isDefault across the matching connection"""
  isDefault: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for \`PostStatus\` for usage during aggregation."""
enum PostStatusGroupBy {
  STATUS
  DESCRIPTION
  COLOR
  PROJECT_ID
  IS_DEFAULT
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`PostStatus\` aggregates."""
input PostStatusHavingInput {
  AND: [PostStatusHavingInput!]
  OR: [PostStatusHavingInput!]
  sum: PostStatusHavingSumInput
  distinctCount: PostStatusHavingDistinctCountInput
  min: PostStatusHavingMinInput
  max: PostStatusHavingMaxInput
  average: PostStatusHavingAverageInput
  stddevSample: PostStatusHavingStddevSampleInput
  stddevPopulation: PostStatusHavingStddevPopulationInput
  varianceSample: PostStatusHavingVarianceSampleInput
  variancePopulation: PostStatusHavingVariancePopulationInput
}

input PostStatusHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering \`PostStatus\`."""
enum PostStatusOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  STATUS_ASC
  STATUS_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  COLOR_ASC
  COLOR_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  IS_DEFAULT_ASC
  IS_DEFAULT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  POSTS_BY_STATUS_ID_COUNT_ASC
  POSTS_BY_STATUS_ID_COUNT_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_ROW_ID_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_ROW_ID_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_TITLE_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_TITLE_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_DESCRIPTION_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_DESCRIPTION_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_PROJECT_ID_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_PROJECT_ID_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_USER_ID_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_USER_ID_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_CREATED_AT_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_CREATED_AT_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_UPDATED_AT_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_UPDATED_AT_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_ID_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_ID_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_UPDATED_AT_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_UPDATED_AT_DESC
}

"""
A condition to be used against \`PostStatus\` object types. All fields are tested
for equality and combined with a logical and.
"""
input PostStatusCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`status\` field."""
  status: String

  """Checks for equality with the objects \`description\` field."""
  description: String

  """Checks for equality with the objects \`color\` field."""
  color: String

  """Checks for equality with the objects \`projectId\` field."""
  projectId: UUID

  """Checks for equality with the objects \`isDefault\` field."""
  isDefault: Boolean

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime
}

"""A connection to a list of \`Organization\` values."""
type OrganizationConnection {
  """A list of \`Organization\` objects."""
  nodes: [Organization]!

  """
  A list of edges which contains the \`Organization\` and cursor to aid in pagination.
  """
  edges: [OrganizationEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Organization\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: OrganizationAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Organization\` for these aggregates."""
    groupBy: [OrganizationGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: OrganizationHavingInput
  ): [OrganizationAggregates!]
}

"""A \`Organization\` edge in the connection."""
type OrganizationEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Organization\` at the end of the edge."""
  node: Organization
}

type OrganizationAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: OrganizationDistinctCountAggregates
}

type OrganizationDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of slug across the matching connection"""
  slug: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for \`Organization\` for usage during aggregation."""
enum OrganizationGroupBy {
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`Organization\` aggregates."""
input OrganizationHavingInput {
  AND: [OrganizationHavingInput!]
  OR: [OrganizationHavingInput!]
  sum: OrganizationHavingSumInput
  distinctCount: OrganizationHavingDistinctCountInput
  min: OrganizationHavingMinInput
  max: OrganizationHavingMaxInput
  average: OrganizationHavingAverageInput
  stddevSample: OrganizationHavingStddevSampleInput
  stddevPopulation: OrganizationHavingStddevPopulationInput
  varianceSample: OrganizationHavingVarianceSampleInput
  variancePopulation: OrganizationHavingVariancePopulationInput
}

input OrganizationHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering \`Organization\`."""
enum OrganizationOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  NAME_ASC
  NAME_DESC
  SLUG_ASC
  SLUG_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PROJECTS_COUNT_ASC
  PROJECTS_COUNT_DESC
  PROJECTS_DISTINCT_COUNT_ROW_ID_ASC
  PROJECTS_DISTINCT_COUNT_ROW_ID_DESC
  PROJECTS_DISTINCT_COUNT_NAME_ASC
  PROJECTS_DISTINCT_COUNT_NAME_DESC
  PROJECTS_DISTINCT_COUNT_IMAGE_ASC
  PROJECTS_DISTINCT_COUNT_IMAGE_DESC
  PROJECTS_DISTINCT_COUNT_SLUG_ASC
  PROJECTS_DISTINCT_COUNT_SLUG_DESC
  PROJECTS_DISTINCT_COUNT_DESCRIPTION_ASC
  PROJECTS_DISTINCT_COUNT_DESCRIPTION_DESC
  PROJECTS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  PROJECTS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  PROJECTS_DISTINCT_COUNT_CREATED_AT_ASC
  PROJECTS_DISTINCT_COUNT_CREATED_AT_DESC
  PROJECTS_DISTINCT_COUNT_UPDATED_AT_ASC
  PROJECTS_DISTINCT_COUNT_UPDATED_AT_DESC
  MEMBERS_COUNT_ASC
  MEMBERS_COUNT_DESC
  MEMBERS_DISTINCT_COUNT_USER_ID_ASC
  MEMBERS_DISTINCT_COUNT_USER_ID_DESC
  MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  MEMBERS_DISTINCT_COUNT_CREATED_AT_ASC
  MEMBERS_DISTINCT_COUNT_CREATED_AT_DESC
  MEMBERS_DISTINCT_COUNT_ROLE_ASC
  MEMBERS_DISTINCT_COUNT_ROLE_DESC
  MEMBERS_DISTINCT_COUNT_ROW_ID_ASC
  MEMBERS_DISTINCT_COUNT_ROW_ID_DESC
  INVITATIONS_COUNT_ASC
  INVITATIONS_COUNT_DESC
  INVITATIONS_DISTINCT_COUNT_ROW_ID_ASC
  INVITATIONS_DISTINCT_COUNT_ROW_ID_DESC
  INVITATIONS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  INVITATIONS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  INVITATIONS_DISTINCT_COUNT_EMAIL_ASC
  INVITATIONS_DISTINCT_COUNT_EMAIL_DESC
  INVITATIONS_DISTINCT_COUNT_CREATED_AT_ASC
  INVITATIONS_DISTINCT_COUNT_CREATED_AT_DESC
  INVITATIONS_DISTINCT_COUNT_UPDATED_AT_ASC
  INVITATIONS_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""
A condition to be used against \`Organization\` object types. All fields are
tested for equality and combined with a logical and.
"""
input OrganizationCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`name\` field."""
  name: String

  """Checks for equality with the objects \`slug\` field."""
  slug: String

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime
}

"""A connection to a list of \`User\` values."""
type UserConnection {
  """A list of \`User\` objects."""
  nodes: [User]!

  """
  A list of edges which contains the \`User\` and cursor to aid in pagination.
  """
  edges: [UserEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`User\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: UserAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`User\` for these aggregates."""
    groupBy: [UserGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: UserHavingInput
  ): [UserAggregates!]
}

"""A \`User\` edge in the connection."""
type UserEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`User\` at the end of the edge."""
  node: User
}

type UserAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: UserDistinctCountAggregates
}

type UserDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of hidraId across the matching connection"""
  hidraId: BigInt

  """Distinct count of username across the matching connection"""
  username: BigInt

  """Distinct count of firstName across the matching connection"""
  firstName: BigInt

  """Distinct count of lastName across the matching connection"""
  lastName: BigInt

  """Distinct count of email across the matching connection"""
  email: BigInt
}

"""Grouping methods for \`User\` for usage during aggregation."""
enum UserGroupBy {
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  FIRST_NAME
  LAST_NAME
}

"""Conditions for \`User\` aggregates."""
input UserHavingInput {
  AND: [UserHavingInput!]
  OR: [UserHavingInput!]
  sum: UserHavingSumInput
  distinctCount: UserHavingDistinctCountInput
  min: UserHavingMinInput
  max: UserHavingMaxInput
  average: UserHavingAverageInput
  stddevSample: UserHavingStddevSampleInput
  stddevPopulation: UserHavingStddevPopulationInput
  varianceSample: UserHavingVarianceSampleInput
  variancePopulation: UserHavingVariancePopulationInput
}

input UserHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""Methods to use when ordering \`User\`."""
enum UserOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  HIDRA_ID_ASC
  HIDRA_ID_DESC
  USERNAME_ASC
  USERNAME_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  POSTS_COUNT_ASC
  POSTS_COUNT_DESC
  POSTS_DISTINCT_COUNT_ROW_ID_ASC
  POSTS_DISTINCT_COUNT_ROW_ID_DESC
  POSTS_DISTINCT_COUNT_TITLE_ASC
  POSTS_DISTINCT_COUNT_TITLE_DESC
  POSTS_DISTINCT_COUNT_DESCRIPTION_ASC
  POSTS_DISTINCT_COUNT_DESCRIPTION_DESC
  POSTS_DISTINCT_COUNT_PROJECT_ID_ASC
  POSTS_DISTINCT_COUNT_PROJECT_ID_DESC
  POSTS_DISTINCT_COUNT_USER_ID_ASC
  POSTS_DISTINCT_COUNT_USER_ID_DESC
  POSTS_DISTINCT_COUNT_CREATED_AT_ASC
  POSTS_DISTINCT_COUNT_CREATED_AT_DESC
  POSTS_DISTINCT_COUNT_UPDATED_AT_ASC
  POSTS_DISTINCT_COUNT_UPDATED_AT_DESC
  POSTS_DISTINCT_COUNT_STATUS_ID_ASC
  POSTS_DISTINCT_COUNT_STATUS_ID_DESC
  POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_ASC
  POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_DESC
  UPVOTES_COUNT_ASC
  UPVOTES_COUNT_DESC
  UPVOTES_DISTINCT_COUNT_ROW_ID_ASC
  UPVOTES_DISTINCT_COUNT_ROW_ID_DESC
  UPVOTES_DISTINCT_COUNT_POST_ID_ASC
  UPVOTES_DISTINCT_COUNT_POST_ID_DESC
  UPVOTES_DISTINCT_COUNT_USER_ID_ASC
  UPVOTES_DISTINCT_COUNT_USER_ID_DESC
  UPVOTES_DISTINCT_COUNT_CREATED_AT_ASC
  UPVOTES_DISTINCT_COUNT_CREATED_AT_DESC
  UPVOTES_DISTINCT_COUNT_UPDATED_AT_ASC
  UPVOTES_DISTINCT_COUNT_UPDATED_AT_DESC
  MEMBERS_COUNT_ASC
  MEMBERS_COUNT_DESC
  MEMBERS_DISTINCT_COUNT_USER_ID_ASC
  MEMBERS_DISTINCT_COUNT_USER_ID_DESC
  MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  MEMBERS_DISTINCT_COUNT_CREATED_AT_ASC
  MEMBERS_DISTINCT_COUNT_CREATED_AT_DESC
  MEMBERS_DISTINCT_COUNT_ROLE_ASC
  MEMBERS_DISTINCT_COUNT_ROLE_DESC
  MEMBERS_DISTINCT_COUNT_ROW_ID_ASC
  MEMBERS_DISTINCT_COUNT_ROW_ID_DESC
  COMMENTS_COUNT_ASC
  COMMENTS_COUNT_DESC
  COMMENTS_DISTINCT_COUNT_ROW_ID_ASC
  COMMENTS_DISTINCT_COUNT_ROW_ID_DESC
  COMMENTS_DISTINCT_COUNT_MESSAGE_ASC
  COMMENTS_DISTINCT_COUNT_MESSAGE_DESC
  COMMENTS_DISTINCT_COUNT_POST_ID_ASC
  COMMENTS_DISTINCT_COUNT_POST_ID_DESC
  COMMENTS_DISTINCT_COUNT_USER_ID_ASC
  COMMENTS_DISTINCT_COUNT_USER_ID_DESC
  COMMENTS_DISTINCT_COUNT_CREATED_AT_ASC
  COMMENTS_DISTINCT_COUNT_CREATED_AT_DESC
  COMMENTS_DISTINCT_COUNT_UPDATED_AT_ASC
  COMMENTS_DISTINCT_COUNT_UPDATED_AT_DESC
  DOWNVOTES_COUNT_ASC
  DOWNVOTES_COUNT_DESC
  DOWNVOTES_DISTINCT_COUNT_ROW_ID_ASC
  DOWNVOTES_DISTINCT_COUNT_ROW_ID_DESC
  DOWNVOTES_DISTINCT_COUNT_POST_ID_ASC
  DOWNVOTES_DISTINCT_COUNT_POST_ID_DESC
  DOWNVOTES_DISTINCT_COUNT_USER_ID_ASC
  DOWNVOTES_DISTINCT_COUNT_USER_ID_DESC
  DOWNVOTES_DISTINCT_COUNT_CREATED_AT_ASC
  DOWNVOTES_DISTINCT_COUNT_CREATED_AT_DESC
  DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_ASC
  DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""
A condition to be used against \`User\` object types. All fields are tested for equality and combined with a logical and.
"""
input UserCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime

  """Checks for equality with the objects \`hidraId\` field."""
  hidraId: UUID

  """Checks for equality with the objects \`username\` field."""
  username: String

  """Checks for equality with the objects \`firstName\` field."""
  firstName: String

  """Checks for equality with the objects \`lastName\` field."""
  lastName: String

  """Checks for equality with the objects \`email\` field."""
  email: String
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single \`Downvote\`."""
  createDownvote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateDownvoteInput!
  ): CreateDownvotePayload

  """Creates a single \`Upvote\`."""
  createUpvote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUpvoteInput!
  ): CreateUpvotePayload

  """Creates a single \`Invitation\`."""
  createInvitation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateInvitationInput!
  ): CreateInvitationPayload

  """Creates a single \`Organization\`."""
  createOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateOrganizationInput!
  ): CreateOrganizationPayload

  """Creates a single \`Comment\`."""
  createComment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateCommentInput!
  ): CreateCommentPayload

  """Creates a single \`Project\`."""
  createProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateProjectInput!
  ): CreateProjectPayload

  """Creates a single \`User\`."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """Creates a single \`Member\`."""
  createMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateMemberInput!
  ): CreateMemberPayload

  """Creates a single \`Post\`."""
  createPost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreatePostInput!
  ): CreatePostPayload

  """Creates a single \`PostStatus\`."""
  createPostStatus(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreatePostStatusInput!
  ): CreatePostStatusPayload

  """Updates a single \`Downvote\` using a unique key and a patch."""
  updateDownvote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateDownvoteInput!
  ): UpdateDownvotePayload

  """Updates a single \`Upvote\` using a unique key and a patch."""
  updateUpvote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUpvoteInput!
  ): UpdateUpvotePayload

  """Updates a single \`Invitation\` using a unique key and a patch."""
  updateInvitation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateInvitationInput!
  ): UpdateInvitationPayload

  """Updates a single \`Organization\` using a unique key and a patch."""
  updateOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateOrganizationInput!
  ): UpdateOrganizationPayload

  """Updates a single \`Comment\` using a unique key and a patch."""
  updateComment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateCommentInput!
  ): UpdateCommentPayload

  """Updates a single \`Project\` using a unique key and a patch."""
  updateProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateProjectInput!
  ): UpdateProjectPayload

  """Updates a single \`User\` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """Updates a single \`Member\` using a unique key and a patch."""
  updateMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateMemberInput!
  ): UpdateMemberPayload

  """Updates a single \`Post\` using a unique key and a patch."""
  updatePost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePostInput!
  ): UpdatePostPayload

  """Updates a single \`PostStatus\` using a unique key and a patch."""
  updatePostStatus(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePostStatusInput!
  ): UpdatePostStatusPayload

  """Deletes a single \`Downvote\` using a unique key."""
  deleteDownvote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteDownvoteInput!
  ): DeleteDownvotePayload

  """Deletes a single \`Upvote\` using a unique key."""
  deleteUpvote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUpvoteInput!
  ): DeleteUpvotePayload

  """Deletes a single \`Invitation\` using a unique key."""
  deleteInvitation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteInvitationInput!
  ): DeleteInvitationPayload

  """Deletes a single \`Organization\` using a unique key."""
  deleteOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteOrganizationInput!
  ): DeleteOrganizationPayload

  """Deletes a single \`Comment\` using a unique key."""
  deleteComment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteCommentInput!
  ): DeleteCommentPayload

  """Deletes a single \`Project\` using a unique key."""
  deleteProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteProjectInput!
  ): DeleteProjectPayload

  """Deletes a single \`User\` using a unique key."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload

  """Deletes a single \`Member\` using a unique key."""
  deleteMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteMemberInput!
  ): DeleteMemberPayload

  """Deletes a single \`Post\` using a unique key."""
  deletePost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePostInput!
  ): DeletePostPayload

  """Deletes a single \`PostStatus\` using a unique key."""
  deletePostStatus(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePostStatusInput!
  ): DeletePostStatusPayload
}

"""The output of our create \`Downvote\` mutation."""
type CreateDownvotePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Downvote\` that was created by this mutation."""
  downvote: Downvote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Downvote\`. May be used by Relay 1."""
  downvoteEdge(
    """The method to use when ordering \`Downvote\`."""
    orderBy: [DownvoteOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DownvoteEdge
}

"""All input for the create \`Downvote\` mutation."""
input CreateDownvoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Downvote\` to be created by this mutation."""
  downvote: DownvoteInput!
}

"""An input for mutations affecting \`Downvote\`"""
input DownvoteInput {
  rowId: UUID
  postId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`Upvote\` mutation."""
type CreateUpvotePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Upvote\` that was created by this mutation."""
  upvote: Upvote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Upvote\`. May be used by Relay 1."""
  upvoteEdge(
    """The method to use when ordering \`Upvote\`."""
    orderBy: [UpvoteOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UpvoteEdge
}

"""All input for the create \`Upvote\` mutation."""
input CreateUpvoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Upvote\` to be created by this mutation."""
  upvote: UpvoteInput!
}

"""An input for mutations affecting \`Upvote\`"""
input UpvoteInput {
  rowId: UUID
  postId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`Invitation\` mutation."""
type CreateInvitationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Invitation\` that was created by this mutation."""
  invitation: Invitation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Invitation\`. May be used by Relay 1."""
  invitationEdge(
    """The method to use when ordering \`Invitation\`."""
    orderBy: [InvitationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): InvitationEdge
}

"""All input for the create \`Invitation\` mutation."""
input CreateInvitationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Invitation\` to be created by this mutation."""
  invitation: InvitationInput!
}

"""An input for mutations affecting \`Invitation\`"""
input InvitationInput {
  rowId: UUID
  organizationId: UUID!
  email: String!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`Organization\` mutation."""
type CreateOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Organization\` that was created by this mutation."""
  organization: Organization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Organization\`. May be used by Relay 1."""
  organizationEdge(
    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): OrganizationEdge
}

"""All input for the create \`Organization\` mutation."""
input CreateOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Organization\` to be created by this mutation."""
  organization: OrganizationInput!
}

"""An input for mutations affecting \`Organization\`"""
input OrganizationInput {
  rowId: UUID
  name: String
  slug: String!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`Comment\` mutation."""
type CreateCommentPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Comment\` that was created by this mutation."""
  comment: Comment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Comment\`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering \`Comment\`."""
    orderBy: [CommentOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CommentEdge
}

"""All input for the create \`Comment\` mutation."""
input CreateCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Comment\` to be created by this mutation."""
  comment: CommentInput!
}

"""An input for mutations affecting \`Comment\`"""
input CommentInput {
  rowId: UUID
  message: String
  postId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`Project\` mutation."""
type CreateProjectPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Project\` that was created by this mutation."""
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Project\`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering \`Project\`."""
    orderBy: [ProjectOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectEdge
}

"""All input for the create \`Project\` mutation."""
input CreateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Project\` to be created by this mutation."""
  project: ProjectInput!
}

"""An input for mutations affecting \`Project\`"""
input ProjectInput {
  rowId: UUID
  name: String
  image: String
  slug: String!
  description: String
  organizationId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`User\` mutation."""
type CreateUserPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`User\` that was created by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`User\`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering \`User\`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the create \`User\` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`User\` to be created by this mutation."""
  user: UserInput!
}

"""An input for mutations affecting \`User\`"""
input UserInput {
  rowId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  hidraId: UUID!
  username: String
  firstName: String
  lastName: String
  email: String!
}

"""The output of our create \`Member\` mutation."""
type CreateMemberPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Member\` that was created by this mutation."""
  member: Member

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Member\`. May be used by Relay 1."""
  memberEdge(
    """The method to use when ordering \`Member\`."""
    orderBy: [MemberOrderBy!]! = [PRIMARY_KEY_ASC]
  ): MemberEdge
}

"""All input for the create \`Member\` mutation."""
input CreateMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Member\` to be created by this mutation."""
  member: MemberInput!
}

"""An input for mutations affecting \`Member\`"""
input MemberInput {
  userId: UUID!
  organizationId: UUID!
  createdAt: Datetime
  role: Role!
  rowId: UUID
}

"""The output of our create \`Post\` mutation."""
type CreatePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was created by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the create \`Post\` mutation."""
input CreatePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Post\` to be created by this mutation."""
  post: PostInput!
}

"""An input for mutations affecting \`Post\`"""
input PostInput {
  rowId: UUID
  title: String
  description: String
  projectId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
  statusId: UUID
  statusUpdatedAt: Datetime
}

"""The output of our create \`PostStatus\` mutation."""
type CreatePostStatusPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`PostStatus\` that was created by this mutation."""
  postStatus: PostStatus

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`PostStatus\`. May be used by Relay 1."""
  postStatusEdge(
    """The method to use when ordering \`PostStatus\`."""
    orderBy: [PostStatusOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostStatusEdge
}

"""All input for the create \`PostStatus\` mutation."""
input CreatePostStatusInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`PostStatus\` to be created by this mutation."""
  postStatus: PostStatusInput!
}

"""An input for mutations affecting \`PostStatus\`"""
input PostStatusInput {
  rowId: UUID
  status: String!
  description: String
  color: String
  projectId: UUID!
  isDefault: Boolean
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update \`Downvote\` mutation."""
type UpdateDownvotePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Downvote\` that was updated by this mutation."""
  downvote: Downvote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Downvote\`. May be used by Relay 1."""
  downvoteEdge(
    """The method to use when ordering \`Downvote\`."""
    orderBy: [DownvoteOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DownvoteEdge
}

"""All input for the \`updateDownvote\` mutation."""
input UpdateDownvoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Downvote\` being updated.
  """
  patch: DownvotePatch!
}

"""
Represents an update to a \`Downvote\`. Fields that are set will be updated.
"""
input DownvotePatch {
  rowId: UUID
  postId: UUID
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update \`Upvote\` mutation."""
type UpdateUpvotePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Upvote\` that was updated by this mutation."""
  upvote: Upvote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Upvote\`. May be used by Relay 1."""
  upvoteEdge(
    """The method to use when ordering \`Upvote\`."""
    orderBy: [UpvoteOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UpvoteEdge
}

"""All input for the \`updateUpvote\` mutation."""
input UpdateUpvoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Upvote\` being updated.
  """
  patch: UpvotePatch!
}

"""
Represents an update to a \`Upvote\`. Fields that are set will be updated.
"""
input UpvotePatch {
  rowId: UUID
  postId: UUID
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update \`Invitation\` mutation."""
type UpdateInvitationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Invitation\` that was updated by this mutation."""
  invitation: Invitation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Invitation\`. May be used by Relay 1."""
  invitationEdge(
    """The method to use when ordering \`Invitation\`."""
    orderBy: [InvitationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): InvitationEdge
}

"""All input for the \`updateInvitation\` mutation."""
input UpdateInvitationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Invitation\` being updated.
  """
  patch: InvitationPatch!
}

"""
Represents an update to a \`Invitation\`. Fields that are set will be updated.
"""
input InvitationPatch {
  rowId: UUID
  organizationId: UUID
  email: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update \`Organization\` mutation."""
type UpdateOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Organization\` that was updated by this mutation."""
  organization: Organization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Organization\`. May be used by Relay 1."""
  organizationEdge(
    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): OrganizationEdge
}

"""All input for the \`updateOrganization\` mutation."""
input UpdateOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Organization\` being updated.
  """
  patch: OrganizationPatch!
}

"""
Represents an update to a \`Organization\`. Fields that are set will be updated.
"""
input OrganizationPatch {
  rowId: UUID
  name: String
  slug: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update \`Comment\` mutation."""
type UpdateCommentPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Comment\` that was updated by this mutation."""
  comment: Comment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Comment\`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering \`Comment\`."""
    orderBy: [CommentOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CommentEdge
}

"""All input for the \`updateComment\` mutation."""
input UpdateCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Comment\` being updated.
  """
  patch: CommentPatch!
}

"""
Represents an update to a \`Comment\`. Fields that are set will be updated.
"""
input CommentPatch {
  rowId: UUID
  message: String
  postId: UUID
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update \`Project\` mutation."""
type UpdateProjectPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Project\` that was updated by this mutation."""
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Project\`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering \`Project\`."""
    orderBy: [ProjectOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectEdge
}

"""All input for the \`updateProject\` mutation."""
input UpdateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Project\` being updated.
  """
  patch: ProjectPatch!
}

"""
Represents an update to a \`Project\`. Fields that are set will be updated.
"""
input ProjectPatch {
  rowId: UUID
  name: String
  image: String
  slug: String
  description: String
  organizationId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update \`User\` mutation."""
type UpdateUserPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`User\` that was updated by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`User\`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering \`User\`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the \`updateUser\` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`User\` being updated.
  """
  patch: UserPatch!
}

"""Represents an update to a \`User\`. Fields that are set will be updated."""
input UserPatch {
  rowId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  hidraId: UUID
  username: String
  firstName: String
  lastName: String
  email: String
}

"""The output of our update \`Member\` mutation."""
type UpdateMemberPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Member\` that was updated by this mutation."""
  member: Member

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Member\`. May be used by Relay 1."""
  memberEdge(
    """The method to use when ordering \`Member\`."""
    orderBy: [MemberOrderBy!]! = [PRIMARY_KEY_ASC]
  ): MemberEdge
}

"""All input for the \`updateMember\` mutation."""
input UpdateMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Member\` being updated.
  """
  patch: MemberPatch!
}

"""
Represents an update to a \`Member\`. Fields that are set will be updated.
"""
input MemberPatch {
  userId: UUID
  organizationId: UUID
  createdAt: Datetime
  role: Role
  rowId: UUID
}

"""The output of our update \`Post\` mutation."""
type UpdatePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was updated by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the \`updatePost\` mutation."""
input UpdatePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Post\` being updated.
  """
  patch: PostPatch!
}

"""Represents an update to a \`Post\`. Fields that are set will be updated."""
input PostPatch {
  rowId: UUID
  title: String
  description: String
  projectId: UUID
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  statusId: UUID
  statusUpdatedAt: Datetime
}

"""The output of our update \`PostStatus\` mutation."""
type UpdatePostStatusPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`PostStatus\` that was updated by this mutation."""
  postStatus: PostStatus

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`PostStatus\`. May be used by Relay 1."""
  postStatusEdge(
    """The method to use when ordering \`PostStatus\`."""
    orderBy: [PostStatusOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostStatusEdge
}

"""All input for the \`updatePostStatus\` mutation."""
input UpdatePostStatusInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`PostStatus\` being updated.
  """
  patch: PostStatusPatch!
}

"""
Represents an update to a \`PostStatus\`. Fields that are set will be updated.
"""
input PostStatusPatch {
  rowId: UUID
  status: String
  description: String
  color: String
  projectId: UUID
  isDefault: Boolean
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our delete \`Downvote\` mutation."""
type DeleteDownvotePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Downvote\` that was deleted by this mutation."""
  downvote: Downvote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Downvote\`. May be used by Relay 1."""
  downvoteEdge(
    """The method to use when ordering \`Downvote\`."""
    orderBy: [DownvoteOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DownvoteEdge
}

"""All input for the \`deleteDownvote\` mutation."""
input DeleteDownvoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Upvote\` mutation."""
type DeleteUpvotePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Upvote\` that was deleted by this mutation."""
  upvote: Upvote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Upvote\`. May be used by Relay 1."""
  upvoteEdge(
    """The method to use when ordering \`Upvote\`."""
    orderBy: [UpvoteOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UpvoteEdge
}

"""All input for the \`deleteUpvote\` mutation."""
input DeleteUpvoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Invitation\` mutation."""
type DeleteInvitationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Invitation\` that was deleted by this mutation."""
  invitation: Invitation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Invitation\`. May be used by Relay 1."""
  invitationEdge(
    """The method to use when ordering \`Invitation\`."""
    orderBy: [InvitationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): InvitationEdge
}

"""All input for the \`deleteInvitation\` mutation."""
input DeleteInvitationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Organization\` mutation."""
type DeleteOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Organization\` that was deleted by this mutation."""
  organization: Organization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Organization\`. May be used by Relay 1."""
  organizationEdge(
    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): OrganizationEdge
}

"""All input for the \`deleteOrganization\` mutation."""
input DeleteOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Comment\` mutation."""
type DeleteCommentPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Comment\` that was deleted by this mutation."""
  comment: Comment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Comment\`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering \`Comment\`."""
    orderBy: [CommentOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CommentEdge
}

"""All input for the \`deleteComment\` mutation."""
input DeleteCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Project\` mutation."""
type DeleteProjectPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Project\` that was deleted by this mutation."""
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Project\`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering \`Project\`."""
    orderBy: [ProjectOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectEdge
}

"""All input for the \`deleteProject\` mutation."""
input DeleteProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`User\` mutation."""
type DeleteUserPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`User\` that was deleted by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`User\`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering \`User\`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the \`deleteUser\` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Member\` mutation."""
type DeleteMemberPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Member\` that was deleted by this mutation."""
  member: Member

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Member\`. May be used by Relay 1."""
  memberEdge(
    """The method to use when ordering \`Member\`."""
    orderBy: [MemberOrderBy!]! = [PRIMARY_KEY_ASC]
  ): MemberEdge
}

"""All input for the \`deleteMember\` mutation."""
input DeleteMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Post\` mutation."""
type DeletePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was deleted by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the \`deletePost\` mutation."""
input DeletePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`PostStatus\` mutation."""
type DeletePostStatusPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`PostStatus\` that was deleted by this mutation."""
  postStatus: PostStatus

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`PostStatus\`. May be used by Relay 1."""
  postStatusEdge(
    """The method to use when ordering \`PostStatus\`."""
    orderBy: [PostStatusOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostStatusEdge
}

"""All input for the \`deletePostStatus\` mutation."""
input DeletePostStatusInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}`;
export const plans = {
  Query: {
    __assertStep() {
      return !0;
    },
    query() {
      return rootValue();
    },
    id($parent) {
      const specifier = handler.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler.codec.name].encode);
    },
    node: {
      plan(_$root, args) {
        return node(nodeIdHandlerByTypeName, args.get("id"));
      },
      args: {
        id: undefined
      }
    },
    downvote: {
      plan(_$root, args) {
        return resource_downvotePgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    downvoteByPostIdAndUserId: {
      plan(_$root, args) {
        return resource_downvotePgResource.get({
          post_id: args.get("postId"),
          user_id: args.get("userId")
        });
      },
      args: {
        postId: undefined,
        userId: undefined
      }
    },
    upvote: {
      plan(_$root, args) {
        return resource_upvotePgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    upvoteByPostIdAndUserId: {
      plan(_$root, args) {
        return resource_upvotePgResource.get({
          post_id: args.get("postId"),
          user_id: args.get("userId")
        });
      },
      args: {
        postId: undefined,
        userId: undefined
      }
    },
    invitation: {
      plan(_$root, args) {
        return resource_invitationPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    invitationByEmail: {
      plan(_$root, args) {
        return resource_invitationPgResource.get({
          email: args.get("email")
        });
      },
      args: {
        email: undefined
      }
    },
    organization: {
      plan(_$root, args) {
        return resource_organizationPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    organizationByName: {
      plan(_$root, args) {
        return resource_organizationPgResource.get({
          name: args.get("name")
        });
      },
      args: {
        name: undefined
      }
    },
    organizationBySlug: {
      plan(_$root, args) {
        return resource_organizationPgResource.get({
          slug: args.get("slug")
        });
      },
      args: {
        slug: undefined
      }
    },
    comment: {
      plan(_$root, args) {
        return resource_commentPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    project: {
      plan(_$root, args) {
        return resource_projectPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    projectByName: {
      plan(_$root, args) {
        return resource_projectPgResource.get({
          name: args.get("name")
        });
      },
      args: {
        name: undefined
      }
    },
    projectBySlugAndOrganizationId: {
      plan(_$root, args) {
        return resource_projectPgResource.get({
          slug: args.get("slug"),
          organization_id: args.get("organizationId")
        });
      },
      args: {
        slug: undefined,
        organizationId: undefined
      }
    },
    user: {
      plan(_$root, args) {
        return resource_userPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    userByEmail: {
      plan(_$root, args) {
        return resource_userPgResource.get({
          email: args.get("email")
        });
      },
      args: {
        email: undefined
      }
    },
    userByHidraId: {
      plan(_$root, args) {
        return resource_userPgResource.get({
          hidra_id: args.get("hidraId")
        });
      },
      args: {
        hidraId: undefined
      }
    },
    userByUsername: {
      plan(_$root, args) {
        return resource_userPgResource.get({
          username: args.get("username")
        });
      },
      args: {
        username: undefined
      }
    },
    member: {
      plan(_$root, args) {
        return resource_memberPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    memberByUserIdAndOrganizationId: {
      plan(_$root, args) {
        return resource_memberPgResource.get({
          user_id: args.get("userId"),
          organization_id: args.get("organizationId")
        });
      },
      args: {
        userId: undefined,
        organizationId: undefined
      }
    },
    post: {
      plan(_$root, args) {
        return resource_postPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    postStatus: {
      plan(_$root, args) {
        return resource_post_statusPgResource.get({
          id: args.get("rowId")
        });
      },
      args: {
        rowId: undefined
      }
    },
    downvotes: {
      plan() {
        return connection(resource_downvotePgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("DownvoteOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    upvotes: {
      plan() {
        return connection(resource_upvotePgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("UpvoteOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed2(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    invitations: {
      plan() {
        return connection(resource_invitationPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("InvitationOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed3(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    organizations: {
      plan() {
        return connection(resource_organizationPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("OrganizationOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed4(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    comments: {
      plan() {
        return connection(resource_commentPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CommentOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed5(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    projects: {
      plan() {
        return connection(resource_projectPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ProjectOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed6(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    users: {
      plan() {
        return connection(resource_userPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("UserOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed7(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    members: {
      plan() {
        return connection(resource_memberPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("MemberOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed8(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    posts: {
      plan() {
        return connection(resource_postPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PostOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed9(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    postStatuses: {
      plan() {
        return connection(resource_post_statusPgResource.find());
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PostStatusOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed10(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    }
  },
  Downvote: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    postId($record) {
      return $record.get("post_id");
    },
    userId($record) {
      return $record.get("user_id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    post($record) {
      return resource_postPgResource.get({
        id: $record.get("post_id")
      });
    },
    user($record) {
      return resource_userPgResource.get({
        id: $record.get("user_id")
      });
    }
  },
  UUID: {
    serialize: UUIDSerialize,
    parseValue(value) {
      return coerce("" + value);
    },
    parseLiteral(ast) {
      if (ast.kind !== Kind.STRING) throw new GraphQLError(`${"UUID" ?? "This scalar"} can only parse string values (kind = '${ast.kind}')`);
      return coerce(ast.value);
    }
  },
  Datetime: {
    serialize: UUIDSerialize,
    parseValue: UUIDSerialize,
    parseLiteral(ast) {
      if (ast.kind !== Kind.STRING) throw new GraphQLError(`${"Datetime" ?? "This scalar"} can only parse string values (kind='${ast.kind}')`);
      return ast.value;
    }
  },
  Post: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    title($record) {
      return $record.get("title");
    },
    description($record) {
      return $record.get("description");
    },
    projectId($record) {
      return $record.get("project_id");
    },
    userId($record) {
      return $record.get("user_id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    statusId($record) {
      return $record.get("status_id");
    },
    statusUpdatedAt($record) {
      return $record.get("status_updated_at");
    },
    project($record) {
      return resource_projectPgResource.get({
        id: $record.get("project_id")
      });
    },
    status($record) {
      return resource_post_statusPgResource.get({
        id: $record.get("status_id")
      });
    },
    user($record) {
      return resource_userPgResource.get({
        id: $record.get("user_id")
      });
    },
    upvotes: {
      plan($record) {
        const $records = resource_upvotePgResource.find({
          post_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("UpvoteOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed11(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    comments: {
      plan($record) {
        const $records = resource_commentPgResource.find({
          post_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CommentOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed12(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    downvotes: {
      plan($record) {
        const $records = resource_downvotePgResource.find({
          post_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("DownvoteOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed13(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    }
  },
  Project: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    name($record) {
      return $record.get("name");
    },
    image($record) {
      return $record.get("image");
    },
    slug($record) {
      return $record.get("slug");
    },
    description($record) {
      return $record.get("description");
    },
    organizationId($record) {
      return $record.get("organization_id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    organization($record) {
      return resource_organizationPgResource.get({
        id: $record.get("organization_id")
      });
    },
    posts: {
      plan($record) {
        const $records = resource_postPgResource.find({
          project_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PostOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed14(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    postStatuses: {
      plan($record) {
        const $records = resource_post_statusPgResource.find({
          project_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PostStatusOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed15(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    }
  },
  Organization: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    name($record) {
      return $record.get("name");
    },
    slug($record) {
      return $record.get("slug");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    projects: {
      plan($record) {
        const $records = resource_projectPgResource.find({
          organization_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("ProjectOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed16(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    members: {
      plan($record) {
        const $records = resource_memberPgResource.find({
          organization_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("MemberOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed17(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    invitations: {
      plan($record) {
        const $records = resource_invitationPgResource.find({
          organization_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("InvitationOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed18(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    }
  },
  ProjectConnection: {
    __assertStep: ConnectionStep,
    nodes($connection) {
      return $connection.nodes();
    },
    edges($connection) {
      return $connection.edges();
    },
    pageInfo($connection) {
      return $connection.pageInfo();
    },
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect, input) {
            var _a, _b;
            const val = input.getRaw().eval();
            if (!Array.isArray(val)) throw new Error("Invalid!");
            for (const group of val) {
              const config = getEnumValueConfig(ProjectGroupBy, group),
                plan = (_b = (_a = config === null || config === void 0 ? void 0 : config.extensions) === null || _a === void 0 ? void 0 : _a.grafast) === null || _b === void 0 ? void 0 : _b.applyPlan;
              if (typeof plan === "function") plan($pgSelect);
            }
            return null;
          }
        },
        having: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect) {
            return $pgSelect.havingPlan();
          }
        }
      }
    }
  },
  ProjectEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  Cursor: {
    serialize: UUIDSerialize,
    parseValue: UUIDSerialize,
    parseLiteral(ast) {
      if (ast.kind !== Kind.STRING) throw new GraphQLError(`${"Cursor" ?? "This scalar"} can only parse string values (kind='${ast.kind}')`);
      return ast.value;
    }
  },
  PageInfo: {
    __assertStep: assertPageInfoCapableStep,
    hasNextPage($pageInfo) {
      return $pageInfo.hasNextPage();
    },
    hasPreviousPage($pageInfo) {
      return $pageInfo.hasPreviousPage();
    },
    startCursor($pageInfo) {
      return $pageInfo.startCursor();
    },
    endCursor($pageInfo) {
      return $pageInfo.endCursor();
    }
  },
  ProjectAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const groups = $pgSelectSingle.getClassStep().getGroups();
      if (groups.length > 0) return $pgSelectSingle.select(sql`json_build_array(${sql.join(groups.map(g => g.fragment), ", ")})`, TYPES.json);else return constant(null);
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  ProjectDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    name($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("name")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    image($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("image")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    slug($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("slug")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    description($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("description")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    organizationId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("organization_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  BigInt: {
    serialize: UUIDSerialize,
    parseValue: UUIDSerialize,
    parseLiteral(ast) {
      if (ast.kind !== Kind.STRING) throw new GraphQLError(`${"BigInt" ?? "This scalar"} can only parse string values (kind='${ast.kind}')`);
      return ast.value;
    }
  },
  ProjectGroupBy: {
    IMAGE: {
      applyPlan: ProjectGroupBy_extensions_grafast_applyPlan
    },
    SLUG: {
      applyPlan: ProjectGroupBy_extensions_grafast_applyPlan2
    },
    DESCRIPTION: {
      applyPlan: ProjectGroupBy_extensions_grafast_applyPlan3
    },
    ORGANIZATION_ID: {
      applyPlan: ProjectGroupBy_extensions_grafast_applyPlan4
    },
    CREATED_AT: {
      applyPlan: ProjectGroupBy_extensions_grafast_applyPlan5
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: ProjectGroupBy_extensions_grafast_applyPlan6
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: ProjectGroupBy_extensions_grafast_applyPlan7
    },
    UPDATED_AT: {
      applyPlan: ProjectGroupBy_extensions_grafast_applyPlan8
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: ProjectGroupBy_extensions_grafast_applyPlan9
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: ProjectGroupBy_extensions_grafast_applyPlan10
    }
  },
  ProjectHavingInput: {
    AND: {
      applyPlan($where, input) {
        input.apply($where);
        return null;
      }
    },
    OR: {
      applyPlan($where, input) {
        const $or = new PgOrFilterStep($where);
        input.apply($or);
        return null;
      }
    },
    sum: {
      applyPlan($having) {
        return $having;
      }
    },
    distinctCount: {
      applyPlan($having) {
        return $having;
      }
    },
    min: {
      applyPlan($having) {
        return $having;
      }
    },
    max: {
      applyPlan($having) {
        return $having;
      }
    },
    average: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevSample: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevPopulation: {
      applyPlan($having) {
        return $having;
      }
    },
    varianceSample: {
      applyPlan($having) {
        return $having;
      }
    },
    variancePopulation: {
      applyPlan($having) {
        return $having;
      }
    }
  },
  ProjectHavingSumInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  HavingDatetimeFilter: {
    equalTo: {
      applyPlan($booleanFilter, input) {
        const val = input.get();
        $booleanFilter.having(sql`(${sql.parens($booleanFilter.expression)} ${infix()} ${$booleanFilter.placeholder(val, TYPES.timestamptz)})`);
      }
    },
    notEqualTo: {
      applyPlan($booleanFilter, input) {
        const val = input.get();
        $booleanFilter.having(sql`(${sql.parens($booleanFilter.expression)} ${infix2()} ${$booleanFilter.placeholder(val, TYPES.timestamptz)})`);
      }
    },
    greaterThan: {
      applyPlan($booleanFilter, input) {
        const val = input.get();
        $booleanFilter.having(sql`(${sql.parens($booleanFilter.expression)} ${infix3()} ${$booleanFilter.placeholder(val, TYPES.timestamptz)})`);
      }
    },
    greaterThanOrEqualTo: {
      applyPlan($booleanFilter, input) {
        const val = input.get();
        $booleanFilter.having(sql`(${sql.parens($booleanFilter.expression)} ${infix4()} ${$booleanFilter.placeholder(val, TYPES.timestamptz)})`);
      }
    },
    lessThan: {
      applyPlan($booleanFilter, input) {
        const val = input.get();
        $booleanFilter.having(sql`(${sql.parens($booleanFilter.expression)} ${infix5()} ${$booleanFilter.placeholder(val, TYPES.timestamptz)})`);
      }
    },
    lessThanOrEqualTo: {
      applyPlan($booleanFilter, input) {
        const val = input.get();
        $booleanFilter.having(sql`(${sql.parens($booleanFilter.expression)} ${infix6()} ${$booleanFilter.placeholder(val, TYPES.timestamptz)})`);
      }
    }
  },
  ProjectHavingDistinctCountInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  ProjectHavingMinInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  ProjectHavingMaxInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  ProjectHavingAverageInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  ProjectHavingStddevSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  ProjectHavingStddevPopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  ProjectHavingVarianceSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  ProjectHavingVariancePopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  ProjectOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        projectUniques[0].attributes.forEach(attributeName => {
          const attribute = projectCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        projectUniques[0].attributes.forEach(attributeName => {
          const attribute = projectCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ROW_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    ROW_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    IMAGE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "image",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    IMAGE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "image",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    SLUG_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "slug",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    SLUG_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "slug",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    DESCRIPTION_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "description",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    DESCRIPTION_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "description",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    ORGANIZATION_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "organization_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    ORGANIZATION_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "organization_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    POSTS_COUNT_ASC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "ASC"
        });
      }
    },
    POSTS_COUNT_DESC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_ROW_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_post.attributes.id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.id.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_ROW_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_post.attributes.id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.id.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_TITLE_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("title")}`, spec_post.attributes.title.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.title.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.title.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_TITLE_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("title")}`, spec_post.attributes.title.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.title.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.title.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_DESCRIPTION_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_post.attributes.description.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.description.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.description.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_DESCRIPTION_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_post.attributes.description.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.description.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.description.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_PROJECT_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_post.attributes.project_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.project_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.project_id.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_PROJECT_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_post.attributes.project_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.project_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.project_id.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_USER_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_post.attributes.user_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.user_id.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_USER_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_post.attributes.user_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.user_id.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_CREATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_post.attributes.created_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.created_at.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_CREATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_post.attributes.created_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.created_at.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_post.attributes.updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.updated_at.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_post.attributes.updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.updated_at.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_STATUS_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_id")}`, spec_post.attributes.status_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.status_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.status_id.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_STATUS_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_id")}`, spec_post.attributes.status_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.status_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.status_id.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_updated_at")}`, spec_post.attributes.status_updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.status_updated_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.status_updated_at.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_updated_at")}`, spec_post.attributes.status_updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.status_updated_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.status_updated_at.codec,
          direction: "DESC"
        });
      }
    },
    POST_STATUSES_COUNT_ASC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "ASC"
        });
      }
    },
    POST_STATUSES_COUNT_DESC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "DESC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_ROW_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_postStatus.attributes.id.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.id.codec,
          direction: "ASC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_ROW_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_postStatus.attributes.id.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.id.codec,
          direction: "DESC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_STATUS_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status")}`, spec_postStatus.attributes.status.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.status.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.status.codec,
          direction: "ASC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_STATUS_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status")}`, spec_postStatus.attributes.status.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.status.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.status.codec,
          direction: "DESC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_DESCRIPTION_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_postStatus.attributes.description.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.description.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.description.codec,
          direction: "ASC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_DESCRIPTION_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_postStatus.attributes.description.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.description.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.description.codec,
          direction: "DESC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_COLOR_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("color")}`, spec_postStatus.attributes.color.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.color.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.color.codec,
          direction: "ASC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_COLOR_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("color")}`, spec_postStatus.attributes.color.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.color.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.color.codec,
          direction: "DESC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_PROJECT_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_postStatus.attributes.project_id.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.project_id.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.project_id.codec,
          direction: "ASC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_PROJECT_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_postStatus.attributes.project_id.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.project_id.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.project_id.codec,
          direction: "DESC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_IS_DEFAULT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("is_default")}`, spec_postStatus.attributes.is_default.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.is_default.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.is_default.codec,
          direction: "ASC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_IS_DEFAULT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("is_default")}`, spec_postStatus.attributes.is_default.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.is_default.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.is_default.codec,
          direction: "DESC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_CREATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_postStatus.attributes.created_at.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.created_at.codec,
          direction: "ASC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_CREATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_postStatus.attributes.created_at.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.created_at.codec,
          direction: "DESC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_postStatus.attributes.updated_at.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.updated_at.codec,
          direction: "ASC"
        });
      }
    },
    POST_STATUSES_DISTINCT_COUNT_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
        relation2.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation2.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_postStatus.attributes.updated_at.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_postStatus.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_postStatus.attributes.updated_at.codec,
          direction: "DESC"
        });
      }
    }
  },
  ProjectCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_project.attributes.id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "name",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "name",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_project.attributes.name.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    image: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "image",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "image",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_project.attributes.image.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    slug: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "slug",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "slug",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_project.attributes.slug.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    description: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "description",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "description",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_project.attributes.description.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_project.attributes.organization_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_project.attributes.created_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_project.attributes.updated_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  ProjectFilter: {
    rowId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec;
        fieldArgs.apply($col);
      }
    },
    name: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec2;
        fieldArgs.apply($col);
      }
    },
    image: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec3;
        fieldArgs.apply($col);
      }
    },
    slug: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec4;
        fieldArgs.apply($col);
      }
    },
    description: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec5;
        fieldArgs.apply($col);
      }
    },
    organizationId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec6;
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec7;
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec8;
        fieldArgs.apply($col);
      }
    },
    posts: {
      applyPlan($where, fieldArgs) {
        assertAllowed19(fieldArgs, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: postIdentifier,
          alias: resource_postPgResource.name,
          localAttributes: registryConfig.pgRelations.project.postsByTheirProjectId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.project.postsByTheirProjectId.remoteAttributes
        };
        fieldArgs.apply($rel);
      }
    },
    postsExist: {
      applyPlan($where, fieldArgs) {
        assertAllowed19(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: postIdentifier,
          alias: resource_postPgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.project.postsByTheirProjectId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.project.postsByTheirProjectId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    postStatuses: {
      applyPlan($where, fieldArgs) {
        assertAllowed19(fieldArgs, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: postStatusIdentifier,
          alias: resource_post_statusPgResource.name,
          localAttributes: registryConfig.pgRelations.project.postStatusesByTheirProjectId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.project.postStatusesByTheirProjectId.remoteAttributes
        };
        fieldArgs.apply($rel);
      }
    },
    postStatusesExist: {
      applyPlan($where, fieldArgs) {
        assertAllowed19(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: postStatusIdentifier,
          alias: resource_post_statusPgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.project.postStatusesByTheirProjectId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.project.postStatusesByTheirProjectId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    organization: {
      applyPlan($where, fieldArgs) {
        assertAllowed20(fieldArgs, "object");
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.project.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.project.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    and: {
      applyPlan($where, fieldArgs) {
        assertAllowed21(fieldArgs, "list");
        const $and = $where.andPlan();
        fieldArgs.apply($and);
      }
    },
    or: {
      applyPlan($where, fieldArgs) {
        assertAllowed21(fieldArgs, "list");
        const $or = $where.orPlan();
        fieldArgs.apply(() => $or.andPlan());
      }
    },
    not: {
      applyPlan($where, fieldArgs) {
        assertAllowed21(fieldArgs, "object");
        const $and = $where.notPlan().andPlan();
        fieldArgs.apply($and);
      }
    }
  },
  UUIDFilter: {
    isNull: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = undefined ? undefined(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec ? resolveInputCodec(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue ? resolveSqlValue($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      }
    },
    equalTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve2(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      }
    },
    notEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve3(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      }
    },
    distinctFrom: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve4(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      }
    },
    notDistinctFrom: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve5(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      }
    },
    in: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec3 ? resolveInputCodec3(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve6(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      }
    },
    notIn: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec3 ? resolveInputCodec3(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve7(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    },
    lessThan: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve8(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      }
    },
    lessThanOrEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve9(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      }
    },
    greaterThan: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve10(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      }
    },
    greaterThanOrEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve11(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      }
    }
  },
  StringFilter: {
    isNull: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = undefined ? undefined(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec4 ? resolveInputCodec4(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue2 ? resolveSqlValue2($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve12(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      }
    },
    equalTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve13(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      }
    },
    notEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve14(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      }
    },
    distinctFrom: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve15(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      }
    },
    notDistinctFrom: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve16(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      }
    },
    in: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec6 ? resolveInputCodec6(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve17(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      }
    },
    notIn: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec6 ? resolveInputCodec6(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve18(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    },
    lessThan: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve19(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      }
    },
    lessThanOrEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve20(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      }
    },
    greaterThan: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve21(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      }
    },
    greaterThanOrEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve22(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      }
    },
    includes: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = resolveInput ? lambda($input, resolveInput) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve23(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "includes"
          });
        $where.where(fragment);
      }
    },
    notIncludes: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = resolveInput2 ? lambda($input, resolveInput2) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve24(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIncludes"
          });
        $where.where(fragment);
      }
    },
    includesInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = resolveInput3 ? lambda($input, resolveInput3) : $input,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve25(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "includesInsensitive"
          });
        $where.where(fragment);
      }
    },
    notIncludesInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = resolveInput4 ? lambda($input, resolveInput4) : $input,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve26(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIncludesInsensitive"
          });
        $where.where(fragment);
      }
    },
    startsWith: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = resolveInput5 ? lambda($input, resolveInput5) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve27(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "startsWith"
          });
        $where.where(fragment);
      }
    },
    notStartsWith: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = resolveInput6 ? lambda($input, resolveInput6) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve28(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notStartsWith"
          });
        $where.where(fragment);
      }
    },
    startsWithInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = resolveInput7 ? lambda($input, resolveInput7) : $input,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve29(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "startsWithInsensitive"
          });
        $where.where(fragment);
      }
    },
    notStartsWithInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = resolveInput8 ? lambda($input, resolveInput8) : $input,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve30(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notStartsWithInsensitive"
          });
        $where.where(fragment);
      }
    },
    endsWith: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = resolveInput9 ? lambda($input, resolveInput9) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve31(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "endsWith"
          });
        $where.where(fragment);
      }
    },
    notEndsWith: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = resolveInput10 ? lambda($input, resolveInput10) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve32(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEndsWith"
          });
        $where.where(fragment);
      }
    },
    endsWithInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = resolveInput11 ? lambda($input, resolveInput11) : $input,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve33(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "endsWithInsensitive"
          });
        $where.where(fragment);
      }
    },
    notEndsWithInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = resolveInput12 ? lambda($input, resolveInput12) : $input,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve34(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEndsWithInsensitive"
          });
        $where.where(fragment);
      }
    },
    like: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve35(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "like"
          });
        $where.where(fragment);
      }
    },
    notLike: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve36(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notLike"
          });
        $where.where(fragment);
      }
    },
    likeInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve37(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "likeInsensitive"
          });
        $where.where(fragment);
      }
    },
    notLikeInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve38(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notLikeInsensitive"
          });
        $where.where(fragment);
      }
    },
    equalToInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier4 ? resolveSqlIdentifier4(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec8 ? resolveInputCodec8(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue3 ? resolveSqlValue3($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve13(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalToInsensitive"
          });
        $where.where(fragment);
      }
    },
    notEqualToInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier5 ? resolveSqlIdentifier5(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec9 ? resolveInputCodec9(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue4 ? resolveSqlValue4($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve14(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualToInsensitive"
          });
        $where.where(fragment);
      }
    },
    distinctFromInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier6 ? resolveSqlIdentifier6(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec10 ? resolveInputCodec10(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue5 ? resolveSqlValue5($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve15(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFromInsensitive"
          });
        $where.where(fragment);
      }
    },
    notDistinctFromInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier7 ? resolveSqlIdentifier7(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec11 ? resolveInputCodec11(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue6 ? resolveSqlValue6($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve16(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFromInsensitive"
          });
        $where.where(fragment);
      }
    },
    inInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier8 ? resolveSqlIdentifier8(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec12 ? resolveInputCodec12(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue7 ? resolveSqlValue7($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve17(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "inInsensitive"
          });
        $where.where(fragment);
      }
    },
    notInInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier9 ? resolveSqlIdentifier9(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec13 ? resolveInputCodec13(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue8 ? resolveSqlValue8($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve18(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notInInsensitive"
          });
        $where.where(fragment);
      }
    },
    lessThanInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier10 ? resolveSqlIdentifier10(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec14 ? resolveInputCodec14(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue9 ? resolveSqlValue9($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve19(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanInsensitive"
          });
        $where.where(fragment);
      }
    },
    lessThanOrEqualToInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier11 ? resolveSqlIdentifier11(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec15 ? resolveInputCodec15(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue10 ? resolveSqlValue10($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve20(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualToInsensitive"
          });
        $where.where(fragment);
      }
    },
    greaterThanInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier12 ? resolveSqlIdentifier12(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec16 ? resolveInputCodec16(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue11 ? resolveSqlValue11($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve21(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanInsensitive"
          });
        $where.where(fragment);
      }
    },
    greaterThanOrEqualToInsensitive: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier13 ? resolveSqlIdentifier13(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec17 ? resolveInputCodec17(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue12 ? resolveSqlValue12($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve22(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualToInsensitive"
          });
        $where.where(fragment);
      }
    }
  },
  DatetimeFilter: {
    isNull: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = undefined ? undefined(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec18 ? resolveInputCodec18(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue13 ? resolveSqlValue13($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve39(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      }
    },
    equalTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve40(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      }
    },
    notEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve41(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      }
    },
    distinctFrom: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve42(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      }
    },
    notDistinctFrom: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve43(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      }
    },
    in: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec20 ? resolveInputCodec20(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve44(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      }
    },
    notIn: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec20 ? resolveInputCodec20(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve45(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    },
    lessThan: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve46(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      }
    },
    lessThanOrEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve47(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      }
    },
    greaterThan: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve48(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      }
    },
    greaterThanOrEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve49(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      }
    }
  },
  ProjectToManyPostFilter: {
    every: {
      applyPlan($where, fieldArgs) {
        assertAllowed22(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery.notPlan().andPlan());
      }
    },
    some: {
      applyPlan($where, fieldArgs) {
        assertAllowed22(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    none: {
      applyPlan($where, fieldArgs) {
        assertAllowed22(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    aggregates: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = new PgAggregateConditionStep($where, {
            sql,
            tableExpression,
            alias
          }, pgWhereConditionSpecListToSQL);
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    }
  },
  PostFilter: {
    rowId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec9;
        fieldArgs.apply($col);
      }
    },
    title: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec10;
        fieldArgs.apply($col);
      }
    },
    description: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec11;
        fieldArgs.apply($col);
      }
    },
    projectId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec12;
        fieldArgs.apply($col);
      }
    },
    userId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec13;
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec14;
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec15;
        fieldArgs.apply($col);
      }
    },
    statusId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec16;
        fieldArgs.apply($col);
      }
    },
    statusUpdatedAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec17;
        fieldArgs.apply($col);
      }
    },
    upvotes: {
      applyPlan($where, fieldArgs) {
        assertAllowed23(fieldArgs, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: upvoteIdentifier,
          alias: resource_upvotePgResource.name,
          localAttributes: registryConfig.pgRelations.post.upvotesByTheirPostId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.post.upvotesByTheirPostId.remoteAttributes
        };
        fieldArgs.apply($rel);
      }
    },
    upvotesExist: {
      applyPlan($where, fieldArgs) {
        assertAllowed23(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: upvoteIdentifier,
          alias: resource_upvotePgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.post.upvotesByTheirPostId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.post.upvotesByTheirPostId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    comments: {
      applyPlan($where, fieldArgs) {
        assertAllowed23(fieldArgs, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: commentIdentifier,
          alias: resource_commentPgResource.name,
          localAttributes: registryConfig.pgRelations.post.commentsByTheirPostId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.post.commentsByTheirPostId.remoteAttributes
        };
        fieldArgs.apply($rel);
      }
    },
    commentsExist: {
      applyPlan($where, fieldArgs) {
        assertAllowed23(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: commentIdentifier,
          alias: resource_commentPgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.post.commentsByTheirPostId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.post.commentsByTheirPostId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    downvotes: {
      applyPlan($where, fieldArgs) {
        assertAllowed23(fieldArgs, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: downvoteIdentifier,
          alias: resource_downvotePgResource.name,
          localAttributes: registryConfig.pgRelations.post.downvotesByTheirPostId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.post.downvotesByTheirPostId.remoteAttributes
        };
        fieldArgs.apply($rel);
      }
    },
    downvotesExist: {
      applyPlan($where, fieldArgs) {
        assertAllowed23(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: downvoteIdentifier,
          alias: resource_downvotePgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.post.downvotesByTheirPostId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.post.downvotesByTheirPostId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    project: {
      applyPlan($where, fieldArgs) {
        assertAllowed24(fieldArgs, "object");
        const $subQuery = $where.existsPlan({
          tableExpression: projectIdentifier,
          alias: resource_projectPgResource.name
        });
        registryConfig.pgRelations.post.projectByMyProjectId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.post.projectByMyProjectId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    status: {
      applyPlan($where, fieldArgs) {
        assertAllowed24(fieldArgs, "object");
        const $subQuery = $where.existsPlan({
          tableExpression: postStatusIdentifier,
          alias: resource_post_statusPgResource.name
        });
        registryConfig.pgRelations.post.postStatusByMyStatusId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.post.postStatusByMyStatusId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    statusExists: {
      applyPlan($where, fieldArgs) {
        assertAllowed24(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: postStatusIdentifier,
          alias: resource_post_statusPgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.post.postStatusByMyStatusId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.post.postStatusByMyStatusId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    user: {
      applyPlan($where, fieldArgs) {
        assertAllowed24(fieldArgs, "object");
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.post.userByMyUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.post.userByMyUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    and: {
      applyPlan($where, fieldArgs) {
        assertAllowed25(fieldArgs, "list");
        const $and = $where.andPlan();
        fieldArgs.apply($and);
      }
    },
    or: {
      applyPlan($where, fieldArgs) {
        assertAllowed25(fieldArgs, "list");
        const $or = $where.orPlan();
        fieldArgs.apply(() => $or.andPlan());
      }
    },
    not: {
      applyPlan($where, fieldArgs) {
        assertAllowed25(fieldArgs, "object");
        const $and = $where.notPlan().andPlan();
        fieldArgs.apply($and);
      }
    }
  },
  PostToManyUpvoteFilter: {
    every: {
      applyPlan($where, fieldArgs) {
        assertAllowed26(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery.notPlan().andPlan());
      }
    },
    some: {
      applyPlan($where, fieldArgs) {
        assertAllowed26(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    none: {
      applyPlan($where, fieldArgs) {
        assertAllowed26(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    aggregates: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = new PgAggregateConditionStep($where, {
            sql,
            tableExpression,
            alias
          }, pgWhereConditionSpecListToSQL);
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    }
  },
  UpvoteFilter: {
    rowId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec18;
        fieldArgs.apply($col);
      }
    },
    postId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec19;
        fieldArgs.apply($col);
      }
    },
    userId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec20;
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec21;
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec22;
        fieldArgs.apply($col);
      }
    },
    post: {
      applyPlan($where, fieldArgs) {
        assertAllowed27(fieldArgs, "object");
        const $subQuery = $where.existsPlan({
          tableExpression: postIdentifier,
          alias: resource_postPgResource.name
        });
        registryConfig.pgRelations.upvote.postByMyPostId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.upvote.postByMyPostId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    user: {
      applyPlan($where, fieldArgs) {
        assertAllowed27(fieldArgs, "object");
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.upvote.userByMyUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.upvote.userByMyUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    and: {
      applyPlan($where, fieldArgs) {
        assertAllowed28(fieldArgs, "list");
        const $and = $where.andPlan();
        fieldArgs.apply($and);
      }
    },
    or: {
      applyPlan($where, fieldArgs) {
        assertAllowed28(fieldArgs, "list");
        const $or = $where.orPlan();
        fieldArgs.apply(() => $or.andPlan());
      }
    },
    not: {
      applyPlan($where, fieldArgs) {
        assertAllowed28(fieldArgs, "object");
        const $and = $where.notPlan().andPlan();
        fieldArgs.apply($and);
      }
    }
  },
  UserFilter: {
    rowId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec23;
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec24;
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec25;
        fieldArgs.apply($col);
      }
    },
    hidraId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec26;
        fieldArgs.apply($col);
      }
    },
    username: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec27;
        fieldArgs.apply($col);
      }
    },
    firstName: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec28;
        fieldArgs.apply($col);
      }
    },
    lastName: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec29;
        fieldArgs.apply($col);
      }
    },
    email: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec30;
        fieldArgs.apply($col);
      }
    },
    posts: {
      applyPlan($where, fieldArgs) {
        assertAllowed29(fieldArgs, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: postIdentifier,
          alias: resource_postPgResource.name,
          localAttributes: registryConfig.pgRelations.user.postsByTheirUserId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.postsByTheirUserId.remoteAttributes
        };
        fieldArgs.apply($rel);
      }
    },
    postsExist: {
      applyPlan($where, fieldArgs) {
        assertAllowed29(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: postIdentifier,
          alias: resource_postPgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.user.postsByTheirUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.postsByTheirUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    upvotes: {
      applyPlan($where, fieldArgs) {
        assertAllowed29(fieldArgs, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: upvoteIdentifier,
          alias: resource_upvotePgResource.name,
          localAttributes: registryConfig.pgRelations.user.upvotesByTheirUserId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.upvotesByTheirUserId.remoteAttributes
        };
        fieldArgs.apply($rel);
      }
    },
    upvotesExist: {
      applyPlan($where, fieldArgs) {
        assertAllowed29(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: upvoteIdentifier,
          alias: resource_upvotePgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.user.upvotesByTheirUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.upvotesByTheirUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    members: {
      applyPlan($where, fieldArgs) {
        assertAllowed29(fieldArgs, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: memberIdentifier,
          alias: resource_memberPgResource.name,
          localAttributes: registryConfig.pgRelations.user.membersByTheirUserId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.membersByTheirUserId.remoteAttributes
        };
        fieldArgs.apply($rel);
      }
    },
    membersExist: {
      applyPlan($where, fieldArgs) {
        assertAllowed29(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: memberIdentifier,
          alias: resource_memberPgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.user.membersByTheirUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.membersByTheirUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    comments: {
      applyPlan($where, fieldArgs) {
        assertAllowed29(fieldArgs, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: commentIdentifier,
          alias: resource_commentPgResource.name,
          localAttributes: registryConfig.pgRelations.user.commentsByTheirUserId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.commentsByTheirUserId.remoteAttributes
        };
        fieldArgs.apply($rel);
      }
    },
    commentsExist: {
      applyPlan($where, fieldArgs) {
        assertAllowed29(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: commentIdentifier,
          alias: resource_commentPgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.user.commentsByTheirUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.commentsByTheirUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    downvotes: {
      applyPlan($where, fieldArgs) {
        assertAllowed29(fieldArgs, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: downvoteIdentifier,
          alias: resource_downvotePgResource.name,
          localAttributes: registryConfig.pgRelations.user.downvotesByTheirUserId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.user.downvotesByTheirUserId.remoteAttributes
        };
        fieldArgs.apply($rel);
      }
    },
    downvotesExist: {
      applyPlan($where, fieldArgs) {
        assertAllowed29(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: downvoteIdentifier,
          alias: resource_downvotePgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.user.downvotesByTheirUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.user.downvotesByTheirUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    and: {
      applyPlan($where, fieldArgs) {
        assertAllowed30(fieldArgs, "list");
        const $and = $where.andPlan();
        fieldArgs.apply($and);
      }
    },
    or: {
      applyPlan($where, fieldArgs) {
        assertAllowed30(fieldArgs, "list");
        const $or = $where.orPlan();
        fieldArgs.apply(() => $or.andPlan());
      }
    },
    not: {
      applyPlan($where, fieldArgs) {
        assertAllowed30(fieldArgs, "object");
        const $and = $where.notPlan().andPlan();
        fieldArgs.apply($and);
      }
    }
  },
  UserToManyPostFilter: {
    every: {
      applyPlan($where, fieldArgs) {
        assertAllowed31(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery.notPlan().andPlan());
      }
    },
    some: {
      applyPlan($where, fieldArgs) {
        assertAllowed31(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    none: {
      applyPlan($where, fieldArgs) {
        assertAllowed31(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    aggregates: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = new PgAggregateConditionStep($where, {
            sql,
            tableExpression,
            alias
          }, pgWhereConditionSpecListToSQL);
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    }
  },
  PostAggregatesFilter: {
    filter: {
      applyPlan($subquery, fieldArgs) {
        const $condition = new PgConditionStep($subquery, !1, "AND");
        fieldArgs.apply($condition);
      }
    },
    distinctCount: {
      applyPlan($subquery, fieldArgs) {
        fieldArgs.apply($subquery.forAggregate(spec));
      }
    }
  },
  PostDistinctCountAggregateFilter: {
    rowId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_post.attributes.id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    title: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("title")}`, spec_post.attributes.title.codec)
        };
        fieldArgs.apply($col);
      }
    },
    description: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("description")}`, spec_post.attributes.description.codec)
        };
        fieldArgs.apply($col);
      }
    },
    projectId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("project_id")}`, spec_post.attributes.project_id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    userId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("user_id")}`, spec_post.attributes.user_id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_post.attributes.created_at.codec)
        };
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("updated_at")}`, spec_post.attributes.updated_at.codec)
        };
        fieldArgs.apply($col);
      }
    },
    statusId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("status_id")}`, spec_post.attributes.status_id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    statusUpdatedAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("status_updated_at")}`, spec_post.attributes.status_updated_at.codec)
        };
        fieldArgs.apply($col);
      }
    }
  },
  BigIntFilter: {
    isNull: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = undefined ? undefined(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec21 ? resolveInputCodec21(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue14 ? resolveSqlValue14($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve50(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      }
    },
    equalTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve51(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      }
    },
    notEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve52(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      }
    },
    distinctFrom: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve53(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      }
    },
    notDistinctFrom: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve54(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      }
    },
    in: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec23 ? resolveInputCodec23(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve55(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      }
    },
    notIn: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec23 ? resolveInputCodec23(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve56(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    },
    lessThan: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve57(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      }
    },
    lessThanOrEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve58(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      }
    },
    greaterThan: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve59(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      }
    },
    greaterThanOrEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve60(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      }
    }
  },
  UserToManyUpvoteFilter: {
    every: {
      applyPlan($where, fieldArgs) {
        assertAllowed32(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery.notPlan().andPlan());
      }
    },
    some: {
      applyPlan($where, fieldArgs) {
        assertAllowed32(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    none: {
      applyPlan($where, fieldArgs) {
        assertAllowed32(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    aggregates: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = new PgAggregateConditionStep($where, {
            sql,
            tableExpression,
            alias
          }, pgWhereConditionSpecListToSQL);
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    }
  },
  UpvoteAggregatesFilter: {
    filter: {
      applyPlan($subquery, fieldArgs) {
        const $condition = new PgConditionStep($subquery, !1, "AND");
        fieldArgs.apply($condition);
      }
    },
    distinctCount: {
      applyPlan($subquery, fieldArgs) {
        fieldArgs.apply($subquery.forAggregate(spec));
      }
    }
  },
  UpvoteDistinctCountAggregateFilter: {
    rowId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_upvote.attributes.id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    postId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("post_id")}`, spec_upvote.attributes.post_id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    userId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("user_id")}`, spec_upvote.attributes.user_id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_upvote.attributes.created_at.codec)
        };
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("updated_at")}`, spec_upvote.attributes.updated_at.codec)
        };
        fieldArgs.apply($col);
      }
    }
  },
  UserToManyMemberFilter: {
    every: {
      applyPlan($where, fieldArgs) {
        assertAllowed33(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery.notPlan().andPlan());
      }
    },
    some: {
      applyPlan($where, fieldArgs) {
        assertAllowed33(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    none: {
      applyPlan($where, fieldArgs) {
        assertAllowed33(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    aggregates: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = new PgAggregateConditionStep($where, {
            sql,
            tableExpression,
            alias
          }, pgWhereConditionSpecListToSQL);
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    }
  },
  MemberFilter: {
    userId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec31;
        fieldArgs.apply($col);
      }
    },
    organizationId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec32;
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec33;
        fieldArgs.apply($col);
      }
    },
    role: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec34;
        fieldArgs.apply($col);
      }
    },
    rowId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec35;
        fieldArgs.apply($col);
      }
    },
    organization: {
      applyPlan($where, fieldArgs) {
        assertAllowed34(fieldArgs, "object");
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.member.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.member.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    user: {
      applyPlan($where, fieldArgs) {
        assertAllowed34(fieldArgs, "object");
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.member.userByMyUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.member.userByMyUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    and: {
      applyPlan($where, fieldArgs) {
        assertAllowed35(fieldArgs, "list");
        const $and = $where.andPlan();
        fieldArgs.apply($and);
      }
    },
    or: {
      applyPlan($where, fieldArgs) {
        assertAllowed35(fieldArgs, "list");
        const $or = $where.orPlan();
        fieldArgs.apply(() => $or.andPlan());
      }
    },
    not: {
      applyPlan($where, fieldArgs) {
        assertAllowed35(fieldArgs, "object");
        const $and = $where.notPlan().andPlan();
        fieldArgs.apply($and);
      }
    }
  },
  RoleFilter: {
    isNull: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = undefined ? undefined(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec24 ? resolveInputCodec24(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue15 ? resolveSqlValue15($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve61(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      }
    },
    equalTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve62(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      }
    },
    notEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve63(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      }
    },
    distinctFrom: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve64(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      }
    },
    notDistinctFrom: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve65(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      }
    },
    in: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec26 ? resolveInputCodec26(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve66(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      }
    },
    notIn: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec26 ? resolveInputCodec26(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve67(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    },
    lessThan: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve68(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      }
    },
    lessThanOrEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve69(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      }
    },
    greaterThan: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve70(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      }
    },
    greaterThanOrEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve71(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      }
    }
  },
  OrganizationFilter: {
    rowId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec36;
        fieldArgs.apply($col);
      }
    },
    name: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec37;
        fieldArgs.apply($col);
      }
    },
    slug: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec38;
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec39;
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec40;
        fieldArgs.apply($col);
      }
    },
    projects: {
      applyPlan($where, fieldArgs) {
        assertAllowed36(fieldArgs, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: projectIdentifier,
          alias: resource_projectPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.projectsByTheirOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.projectsByTheirOrganizationId.remoteAttributes
        };
        fieldArgs.apply($rel);
      }
    },
    projectsExist: {
      applyPlan($where, fieldArgs) {
        assertAllowed36(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: projectIdentifier,
          alias: resource_projectPgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.organization.projectsByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.projectsByTheirOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    members: {
      applyPlan($where, fieldArgs) {
        assertAllowed36(fieldArgs, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: memberIdentifier,
          alias: resource_memberPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.membersByTheirOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.membersByTheirOrganizationId.remoteAttributes
        };
        fieldArgs.apply($rel);
      }
    },
    membersExist: {
      applyPlan($where, fieldArgs) {
        assertAllowed36(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: memberIdentifier,
          alias: resource_memberPgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.organization.membersByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.membersByTheirOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    invitations: {
      applyPlan($where, fieldArgs) {
        assertAllowed36(fieldArgs, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: invitationIdentifier,
          alias: resource_invitationPgResource.name,
          localAttributes: registryConfig.pgRelations.organization.invitationsByTheirOrganizationId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.organization.invitationsByTheirOrganizationId.remoteAttributes
        };
        fieldArgs.apply($rel);
      }
    },
    invitationsExist: {
      applyPlan($where, fieldArgs) {
        assertAllowed36(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: invitationIdentifier,
          alias: resource_invitationPgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.organization.invitationsByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.organization.invitationsByTheirOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    and: {
      applyPlan($where, fieldArgs) {
        assertAllowed37(fieldArgs, "list");
        const $and = $where.andPlan();
        fieldArgs.apply($and);
      }
    },
    or: {
      applyPlan($where, fieldArgs) {
        assertAllowed37(fieldArgs, "list");
        const $or = $where.orPlan();
        fieldArgs.apply(() => $or.andPlan());
      }
    },
    not: {
      applyPlan($where, fieldArgs) {
        assertAllowed37(fieldArgs, "object");
        const $and = $where.notPlan().andPlan();
        fieldArgs.apply($and);
      }
    }
  },
  OrganizationToManyProjectFilter: {
    every: {
      applyPlan($where, fieldArgs) {
        assertAllowed38(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery.notPlan().andPlan());
      }
    },
    some: {
      applyPlan($where, fieldArgs) {
        assertAllowed38(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    none: {
      applyPlan($where, fieldArgs) {
        assertAllowed38(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    aggregates: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = new PgAggregateConditionStep($where, {
            sql,
            tableExpression,
            alias
          }, pgWhereConditionSpecListToSQL);
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    }
  },
  ProjectAggregatesFilter: {
    filter: {
      applyPlan($subquery, fieldArgs) {
        const $condition = new PgConditionStep($subquery, !1, "AND");
        fieldArgs.apply($condition);
      }
    },
    distinctCount: {
      applyPlan($subquery, fieldArgs) {
        fieldArgs.apply($subquery.forAggregate(spec));
      }
    }
  },
  ProjectDistinctCountAggregateFilter: {
    rowId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_project.attributes.id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    name: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("name")}`, spec_project.attributes.name.codec)
        };
        fieldArgs.apply($col);
      }
    },
    image: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("image")}`, spec_project.attributes.image.codec)
        };
        fieldArgs.apply($col);
      }
    },
    slug: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("slug")}`, spec_project.attributes.slug.codec)
        };
        fieldArgs.apply($col);
      }
    },
    description: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("description")}`, spec_project.attributes.description.codec)
        };
        fieldArgs.apply($col);
      }
    },
    organizationId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("organization_id")}`, spec_project.attributes.organization_id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_project.attributes.created_at.codec)
        };
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("updated_at")}`, spec_project.attributes.updated_at.codec)
        };
        fieldArgs.apply($col);
      }
    }
  },
  OrganizationToManyMemberFilter: {
    every: {
      applyPlan($where, fieldArgs) {
        assertAllowed39(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery.notPlan().andPlan());
      }
    },
    some: {
      applyPlan($where, fieldArgs) {
        assertAllowed39(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    none: {
      applyPlan($where, fieldArgs) {
        assertAllowed39(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    aggregates: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = new PgAggregateConditionStep($where, {
            sql,
            tableExpression,
            alias
          }, pgWhereConditionSpecListToSQL);
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    }
  },
  MemberAggregatesFilter: {
    filter: {
      applyPlan($subquery, fieldArgs) {
        const $condition = new PgConditionStep($subquery, !1, "AND");
        fieldArgs.apply($condition);
      }
    },
    distinctCount: {
      applyPlan($subquery, fieldArgs) {
        fieldArgs.apply($subquery.forAggregate(spec));
      }
    }
  },
  MemberDistinctCountAggregateFilter: {
    userId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("user_id")}`, spec_member.attributes.user_id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    organizationId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("organization_id")}`, spec_member.attributes.organization_id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_member.attributes.created_at.codec)
        };
        fieldArgs.apply($col);
      }
    },
    role: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("role")}`, spec_member.attributes.role.codec)
        };
        fieldArgs.apply($col);
      }
    },
    rowId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_member.attributes.id.codec)
        };
        fieldArgs.apply($col);
      }
    }
  },
  OrganizationToManyInvitationFilter: {
    every: {
      applyPlan($where, fieldArgs) {
        assertAllowed40(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery.notPlan().andPlan());
      }
    },
    some: {
      applyPlan($where, fieldArgs) {
        assertAllowed40(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    none: {
      applyPlan($where, fieldArgs) {
        assertAllowed40(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    aggregates: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = new PgAggregateConditionStep($where, {
            sql,
            tableExpression,
            alias
          }, pgWhereConditionSpecListToSQL);
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    }
  },
  InvitationFilter: {
    rowId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec41;
        fieldArgs.apply($col);
      }
    },
    organizationId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec42;
        fieldArgs.apply($col);
      }
    },
    email: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec43;
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec44;
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec45;
        fieldArgs.apply($col);
      }
    },
    organization: {
      applyPlan($where, fieldArgs) {
        assertAllowed41(fieldArgs, "object");
        const $subQuery = $where.existsPlan({
          tableExpression: organizationIdentifier,
          alias: resource_organizationPgResource.name
        });
        registryConfig.pgRelations.invitation.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.invitation.organizationByMyOrganizationId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    and: {
      applyPlan($where, fieldArgs) {
        assertAllowed42(fieldArgs, "list");
        const $and = $where.andPlan();
        fieldArgs.apply($and);
      }
    },
    or: {
      applyPlan($where, fieldArgs) {
        assertAllowed42(fieldArgs, "list");
        const $or = $where.orPlan();
        fieldArgs.apply(() => $or.andPlan());
      }
    },
    not: {
      applyPlan($where, fieldArgs) {
        assertAllowed42(fieldArgs, "object");
        const $and = $where.notPlan().andPlan();
        fieldArgs.apply($and);
      }
    }
  },
  InvitationAggregatesFilter: {
    filter: {
      applyPlan($subquery, fieldArgs) {
        const $condition = new PgConditionStep($subquery, !1, "AND");
        fieldArgs.apply($condition);
      }
    },
    distinctCount: {
      applyPlan($subquery, fieldArgs) {
        fieldArgs.apply($subquery.forAggregate(spec));
      }
    }
  },
  InvitationDistinctCountAggregateFilter: {
    rowId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_invitation.attributes.id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    organizationId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("organization_id")}`, spec_invitation.attributes.organization_id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    email: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("email")}`, spec_invitation.attributes.email.codec)
        };
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_invitation.attributes.created_at.codec)
        };
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("updated_at")}`, spec_invitation.attributes.updated_at.codec)
        };
        fieldArgs.apply($col);
      }
    }
  },
  UserToManyCommentFilter: {
    every: {
      applyPlan($where, fieldArgs) {
        assertAllowed43(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery.notPlan().andPlan());
      }
    },
    some: {
      applyPlan($where, fieldArgs) {
        assertAllowed43(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    none: {
      applyPlan($where, fieldArgs) {
        assertAllowed43(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    aggregates: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = new PgAggregateConditionStep($where, {
            sql,
            tableExpression,
            alias
          }, pgWhereConditionSpecListToSQL);
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    }
  },
  CommentFilter: {
    rowId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec46;
        fieldArgs.apply($col);
      }
    },
    message: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec47;
        fieldArgs.apply($col);
      }
    },
    postId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec48;
        fieldArgs.apply($col);
      }
    },
    userId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec49;
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec50;
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec51;
        fieldArgs.apply($col);
      }
    },
    post: {
      applyPlan($where, fieldArgs) {
        assertAllowed44(fieldArgs, "object");
        const $subQuery = $where.existsPlan({
          tableExpression: postIdentifier,
          alias: resource_postPgResource.name
        });
        registryConfig.pgRelations.comment.postByMyPostId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.comment.postByMyPostId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    user: {
      applyPlan($where, fieldArgs) {
        assertAllowed44(fieldArgs, "object");
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.comment.userByMyUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.comment.userByMyUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    and: {
      applyPlan($where, fieldArgs) {
        assertAllowed45(fieldArgs, "list");
        const $and = $where.andPlan();
        fieldArgs.apply($and);
      }
    },
    or: {
      applyPlan($where, fieldArgs) {
        assertAllowed45(fieldArgs, "list");
        const $or = $where.orPlan();
        fieldArgs.apply(() => $or.andPlan());
      }
    },
    not: {
      applyPlan($where, fieldArgs) {
        assertAllowed45(fieldArgs, "object");
        const $and = $where.notPlan().andPlan();
        fieldArgs.apply($and);
      }
    }
  },
  CommentAggregatesFilter: {
    filter: {
      applyPlan($subquery, fieldArgs) {
        const $condition = new PgConditionStep($subquery, !1, "AND");
        fieldArgs.apply($condition);
      }
    },
    distinctCount: {
      applyPlan($subquery, fieldArgs) {
        fieldArgs.apply($subquery.forAggregate(spec));
      }
    }
  },
  CommentDistinctCountAggregateFilter: {
    rowId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_comment.attributes.id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    message: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("message")}`, spec_comment.attributes.message.codec)
        };
        fieldArgs.apply($col);
      }
    },
    postId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("post_id")}`, spec_comment.attributes.post_id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    userId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("user_id")}`, spec_comment.attributes.user_id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_comment.attributes.created_at.codec)
        };
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("updated_at")}`, spec_comment.attributes.updated_at.codec)
        };
        fieldArgs.apply($col);
      }
    }
  },
  UserToManyDownvoteFilter: {
    every: {
      applyPlan($where, fieldArgs) {
        assertAllowed46(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery.notPlan().andPlan());
      }
    },
    some: {
      applyPlan($where, fieldArgs) {
        assertAllowed46(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    none: {
      applyPlan($where, fieldArgs) {
        assertAllowed46(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    aggregates: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = new PgAggregateConditionStep($where, {
            sql,
            tableExpression,
            alias
          }, pgWhereConditionSpecListToSQL);
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    }
  },
  DownvoteFilter: {
    rowId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec52;
        fieldArgs.apply($col);
      }
    },
    postId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec53;
        fieldArgs.apply($col);
      }
    },
    userId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec54;
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec55;
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec56;
        fieldArgs.apply($col);
      }
    },
    post: {
      applyPlan($where, fieldArgs) {
        assertAllowed47(fieldArgs, "object");
        const $subQuery = $where.existsPlan({
          tableExpression: postIdentifier,
          alias: resource_postPgResource.name
        });
        registryConfig.pgRelations.downvote.postByMyPostId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.downvote.postByMyPostId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    user: {
      applyPlan($where, fieldArgs) {
        assertAllowed47(fieldArgs, "object");
        const $subQuery = $where.existsPlan({
          tableExpression: userIdentifier,
          alias: resource_userPgResource.name
        });
        registryConfig.pgRelations.downvote.userByMyUserId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.downvote.userByMyUserId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    and: {
      applyPlan($where, fieldArgs) {
        assertAllowed48(fieldArgs, "list");
        const $and = $where.andPlan();
        fieldArgs.apply($and);
      }
    },
    or: {
      applyPlan($where, fieldArgs) {
        assertAllowed48(fieldArgs, "list");
        const $or = $where.orPlan();
        fieldArgs.apply(() => $or.andPlan());
      }
    },
    not: {
      applyPlan($where, fieldArgs) {
        assertAllowed48(fieldArgs, "object");
        const $and = $where.notPlan().andPlan();
        fieldArgs.apply($and);
      }
    }
  },
  DownvoteAggregatesFilter: {
    filter: {
      applyPlan($subquery, fieldArgs) {
        const $condition = new PgConditionStep($subquery, !1, "AND");
        fieldArgs.apply($condition);
      }
    },
    distinctCount: {
      applyPlan($subquery, fieldArgs) {
        fieldArgs.apply($subquery.forAggregate(spec));
      }
    }
  },
  DownvoteDistinctCountAggregateFilter: {
    rowId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_downvote.attributes.id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    postId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("post_id")}`, spec_downvote.attributes.post_id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    userId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("user_id")}`, spec_downvote.attributes.user_id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_downvote.attributes.created_at.codec)
        };
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("updated_at")}`, spec_downvote.attributes.updated_at.codec)
        };
        fieldArgs.apply($col);
      }
    }
  },
  PostToManyCommentFilter: {
    every: {
      applyPlan($where, fieldArgs) {
        assertAllowed49(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery.notPlan().andPlan());
      }
    },
    some: {
      applyPlan($where, fieldArgs) {
        assertAllowed49(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    none: {
      applyPlan($where, fieldArgs) {
        assertAllowed49(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    aggregates: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = new PgAggregateConditionStep($where, {
            sql,
            tableExpression,
            alias
          }, pgWhereConditionSpecListToSQL);
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    }
  },
  PostToManyDownvoteFilter: {
    every: {
      applyPlan($where, fieldArgs) {
        assertAllowed50(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery.notPlan().andPlan());
      }
    },
    some: {
      applyPlan($where, fieldArgs) {
        assertAllowed50(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    none: {
      applyPlan($where, fieldArgs) {
        assertAllowed50(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    aggregates: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = new PgAggregateConditionStep($where, {
            sql,
            tableExpression,
            alias
          }, pgWhereConditionSpecListToSQL);
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    }
  },
  PostStatusFilter: {
    rowId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec57;
        fieldArgs.apply($col);
      }
    },
    status: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec58;
        fieldArgs.apply($col);
      }
    },
    description: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec59;
        fieldArgs.apply($col);
      }
    },
    color: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec60;
        fieldArgs.apply($col);
      }
    },
    projectId: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec61;
        fieldArgs.apply($col);
      }
    },
    isDefault: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec62;
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec63;
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($where, fieldArgs) {
        const $raw = fieldArgs.getRaw();
        if ($raw.evalIs(void 0)) return;
        if (!false && "evalIsEmpty" in $raw && $raw.evalIsEmpty()) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
        if (!false && $raw.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $col = new PgConditionStep($where);
        $col.extensions.pgFilterAttribute = colSpec64;
        fieldArgs.apply($col);
      }
    },
    postsByStatusId: {
      applyPlan($where, fieldArgs) {
        assertAllowed51(fieldArgs, "object");
        const $rel = $where.andPlan();
        $rel.extensions.pgFilterRelation = {
          tableExpression: postIdentifier,
          alias: resource_postPgResource.name,
          localAttributes: registryConfig.pgRelations.postStatus.postsByTheirStatusId.localAttributes,
          remoteAttributes: registryConfig.pgRelations.postStatus.postsByTheirStatusId.remoteAttributes
        };
        fieldArgs.apply($rel);
      }
    },
    postsByStatusIdExist: {
      applyPlan($where, fieldArgs) {
        assertAllowed51(fieldArgs, "scalar");
        const $subQuery = $where.existsPlan({
          tableExpression: postIdentifier,
          alias: resource_postPgResource.name,
          $equals: fieldArgs.get()
        });
        registryConfig.pgRelations.postStatus.postsByTheirStatusId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.postStatus.postsByTheirStatusId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
      }
    },
    project: {
      applyPlan($where, fieldArgs) {
        assertAllowed52(fieldArgs, "object");
        const $subQuery = $where.existsPlan({
          tableExpression: projectIdentifier,
          alias: resource_projectPgResource.name
        });
        registryConfig.pgRelations.postStatus.projectByMyProjectId.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = registryConfig.pgRelations.postStatus.projectByMyProjectId.remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    and: {
      applyPlan($where, fieldArgs) {
        assertAllowed53(fieldArgs, "list");
        const $and = $where.andPlan();
        fieldArgs.apply($and);
      }
    },
    or: {
      applyPlan($where, fieldArgs) {
        assertAllowed53(fieldArgs, "list");
        const $or = $where.orPlan();
        fieldArgs.apply(() => $or.andPlan());
      }
    },
    not: {
      applyPlan($where, fieldArgs) {
        assertAllowed53(fieldArgs, "object");
        const $and = $where.notPlan().andPlan();
        fieldArgs.apply($and);
      }
    }
  },
  BooleanFilter: {
    isNull: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = undefined ? undefined(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec27 ? resolveInputCodec27(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = resolveSqlValue16 ? resolveSqlValue16($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve72(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "isNull"
          });
        $where.where(fragment);
      }
    },
    equalTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve73(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "equalTo"
          });
        $where.where(fragment);
      }
    },
    notEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve74(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notEqualTo"
          });
        $where.where(fragment);
      }
    },
    distinctFrom: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve75(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "distinctFrom"
          });
        $where.where(fragment);
      }
    },
    notDistinctFrom: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve76(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notDistinctFrom"
          });
        $where.where(fragment);
      }
    },
    in: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec29 ? resolveInputCodec29(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve77(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "in"
          });
        $where.where(fragment);
      }
    },
    notIn: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec29 ? resolveInputCodec29(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve78(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "notIn"
          });
        $where.where(fragment);
      }
    },
    lessThan: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve79(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThan"
          });
        $where.where(fragment);
      }
    },
    lessThanOrEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve80(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "lessThanOrEqualTo"
          });
        $where.where(fragment);
      }
    },
    greaterThan: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve81(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThan"
          });
        $where.where(fragment);
      }
    },
    greaterThanOrEqualTo: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
        const $input = fieldArgs.getRaw();
        if ($input.evalIs(void 0)) return;
        const {
            fieldName: parentFieldName,
            attributeName,
            attribute,
            codec,
            expression
          } = $where.extensions.pgFilterAttribute,
          sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
          sourceCodec = codec ?? attribute.codec,
          [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
        if (false && $input.evalIs(null)) return;
        if (!false && $input.evalIs(null)) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
        const $resolvedInput = undefined ? lambda($input, undefined) : $input,
          inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
          sqlValue = undefined ? undefined($where, $input, inputCodec) : $where.placeholder($resolvedInput, inputCodec),
          fragment = resolve82(sqlIdentifier, sqlValue, $input, $where, {
            fieldName: parentFieldName ?? null,
            operatorName: "greaterThanOrEqualTo"
          });
        $where.where(fragment);
      }
    }
  },
  PostStatusToManyPostFilter: {
    every: {
      applyPlan($where, fieldArgs) {
        assertAllowed54(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery.notPlan().andPlan());
      }
    },
    some: {
      applyPlan($where, fieldArgs) {
        assertAllowed54(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    none: {
      applyPlan($where, fieldArgs) {
        assertAllowed54(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    aggregates: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = new PgAggregateConditionStep($where, {
            sql,
            tableExpression,
            alias
          }, pgWhereConditionSpecListToSQL);
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    }
  },
  ProjectToManyPostStatusFilter: {
    every: {
      applyPlan($where, fieldArgs) {
        assertAllowed55(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery.notPlan().andPlan());
      }
    },
    some: {
      applyPlan($where, fieldArgs) {
        assertAllowed55(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    none: {
      applyPlan($where, fieldArgs) {
        assertAllowed55(fieldArgs, "object");
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = $where.notPlan().existsPlan({
            tableExpression,
            alias
          });
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    },
    aggregates: {
      applyPlan($where, fieldArgs) {
        if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
        const {
            localAttributes,
            remoteAttributes,
            tableExpression,
            alias
          } = $where.extensions.pgFilterRelation,
          $subQuery = new PgAggregateConditionStep($where, {
            sql,
            tableExpression,
            alias
          }, pgWhereConditionSpecListToSQL);
        localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = remoteAttributes[i];
          $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
        });
        fieldArgs.apply($subQuery);
      }
    }
  },
  PostStatusAggregatesFilter: {
    filter: {
      applyPlan($subquery, fieldArgs) {
        const $condition = new PgConditionStep($subquery, !1, "AND");
        fieldArgs.apply($condition);
      }
    },
    distinctCount: {
      applyPlan($subquery, fieldArgs) {
        fieldArgs.apply($subquery.forAggregate(spec));
      }
    }
  },
  PostStatusDistinctCountAggregateFilter: {
    rowId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_postStatus.attributes.id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    status: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("status")}`, spec_postStatus.attributes.status.codec)
        };
        fieldArgs.apply($col);
      }
    },
    description: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("description")}`, spec_postStatus.attributes.description.codec)
        };
        fieldArgs.apply($col);
      }
    },
    color: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("color")}`, spec_postStatus.attributes.color.codec)
        };
        fieldArgs.apply($col);
      }
    },
    projectId: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("project_id")}`, spec_postStatus.attributes.project_id.codec)
        };
        fieldArgs.apply($col);
      }
    },
    isDefault: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("is_default")}`, spec_postStatus.attributes.is_default.codec)
        };
        fieldArgs.apply($col);
      }
    },
    createdAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_postStatus.attributes.created_at.codec)
        };
        fieldArgs.apply($col);
      }
    },
    updatedAt: {
      applyPlan($parent, fieldArgs) {
        const $col = new PgConditionStep($parent);
        $col.extensions.pgFilterAttribute = {
          codec: TYPES.bigint,
          expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("updated_at")}`, spec_postStatus.attributes.updated_at.codec)
        };
        fieldArgs.apply($col);
      }
    }
  },
  MemberConnection: {
    __assertStep: ConnectionStep,
    nodes($connection) {
      return $connection.nodes();
    },
    edges($connection) {
      return $connection.edges();
    },
    pageInfo($connection) {
      return $connection.pageInfo();
    },
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect, input) {
            var _a, _b;
            const val = input.getRaw().eval();
            if (!Array.isArray(val)) throw new Error("Invalid!");
            for (const group of val) {
              const config = getEnumValueConfig(MemberGroupBy, group),
                plan = (_b = (_a = config === null || config === void 0 ? void 0 : config.extensions) === null || _a === void 0 ? void 0 : _a.grafast) === null || _b === void 0 ? void 0 : _b.applyPlan;
              if (typeof plan === "function") plan($pgSelect);
            }
            return null;
          }
        },
        having: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect) {
            return $pgSelect.havingPlan();
          }
        }
      }
    }
  },
  Member: {
    __assertStep: assertPgClassSingleStep,
    userId($record) {
      return $record.get("user_id");
    },
    organizationId($record) {
      return $record.get("organization_id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    role($record) {
      return $record.get("role");
    },
    rowId($record) {
      return $record.get("id");
    },
    organization($record) {
      return resource_organizationPgResource.get({
        id: $record.get("organization_id")
      });
    },
    user($record) {
      return resource_userPgResource.get({
        id: $record.get("user_id")
      });
    }
  },
  User: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    hidraId($record) {
      return $record.get("hidra_id");
    },
    username($record) {
      return $record.get("username");
    },
    firstName($record) {
      return $record.get("first_name");
    },
    lastName($record) {
      return $record.get("last_name");
    },
    email($record) {
      return $record.get("email");
    },
    posts: {
      plan($record) {
        const $records = resource_postPgResource.find({
          user_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PostOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed56(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    upvotes: {
      plan($record) {
        const $records = resource_upvotePgResource.find({
          user_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("UpvoteOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed57(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    members: {
      plan($record) {
        const $records = resource_memberPgResource.find({
          user_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("MemberOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed58(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    comments: {
      plan($record) {
        const $records = resource_commentPgResource.find({
          user_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("CommentOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed59(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    },
    downvotes: {
      plan($record) {
        const $records = resource_downvotePgResource.find({
          user_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("DownvoteOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed60(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    }
  },
  PostConnection: {
    __assertStep: ConnectionStep,
    nodes($connection) {
      return $connection.nodes();
    },
    edges($connection) {
      return $connection.edges();
    },
    pageInfo($connection) {
      return $connection.pageInfo();
    },
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect, input) {
            var _a, _b;
            const val = input.getRaw().eval();
            if (!Array.isArray(val)) throw new Error("Invalid!");
            for (const group of val) {
              const config = getEnumValueConfig(PostGroupBy, group),
                plan = (_b = (_a = config === null || config === void 0 ? void 0 : config.extensions) === null || _a === void 0 ? void 0 : _a.grafast) === null || _b === void 0 ? void 0 : _b.applyPlan;
              if (typeof plan === "function") plan($pgSelect);
            }
            return null;
          }
        },
        having: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect) {
            return $pgSelect.havingPlan();
          }
        }
      }
    }
  },
  PostEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PostAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const groups = $pgSelectSingle.getClassStep().getGroups();
      if (groups.length > 0) return $pgSelectSingle.select(sql`json_build_array(${sql.join(groups.map(g => g.fragment), ", ")})`, TYPES.json);else return constant(null);
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  PostDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    title($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("title")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    description($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("description")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    projectId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("project_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    userId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("user_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    statusId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("status_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    statusUpdatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("status_updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  PostGroupBy: {
    TITLE: {
      applyPlan: PostGroupBy_extensions_grafast_applyPlan
    },
    DESCRIPTION: {
      applyPlan: PostGroupBy_extensions_grafast_applyPlan2
    },
    PROJECT_ID: {
      applyPlan: PostGroupBy_extensions_grafast_applyPlan3
    },
    USER_ID: {
      applyPlan: PostGroupBy_extensions_grafast_applyPlan4
    },
    CREATED_AT: {
      applyPlan: PostGroupBy_extensions_grafast_applyPlan5
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: PostGroupBy_extensions_grafast_applyPlan6
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: PostGroupBy_extensions_grafast_applyPlan7
    },
    UPDATED_AT: {
      applyPlan: PostGroupBy_extensions_grafast_applyPlan8
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: PostGroupBy_extensions_grafast_applyPlan9
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: PostGroupBy_extensions_grafast_applyPlan10
    },
    STATUS_ID: {
      applyPlan: PostGroupBy_extensions_grafast_applyPlan11
    },
    STATUS_UPDATED_AT: {
      applyPlan: PostGroupBy_extensions_grafast_applyPlan12
    },
    STATUS_UPDATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: PostGroupBy_extensions_grafast_applyPlan13
    },
    STATUS_UPDATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: PostGroupBy_extensions_grafast_applyPlan14
    }
  },
  PostHavingInput: {
    AND: {
      applyPlan($where, input) {
        input.apply($where);
        return null;
      }
    },
    OR: {
      applyPlan($where, input) {
        const $or = new PgOrFilterStep($where);
        input.apply($or);
        return null;
      }
    },
    sum: {
      applyPlan($having) {
        return $having;
      }
    },
    distinctCount: {
      applyPlan($having) {
        return $having;
      }
    },
    min: {
      applyPlan($having) {
        return $having;
      }
    },
    max: {
      applyPlan($having) {
        return $having;
      }
    },
    average: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevSample: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevPopulation: {
      applyPlan($having) {
        return $having;
      }
    },
    varianceSample: {
      applyPlan($having) {
        return $having;
      }
    },
    variancePopulation: {
      applyPlan($having) {
        return $having;
      }
    }
  },
  PostHavingSumInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    statusUpdatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostHavingDistinctCountInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    statusUpdatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostHavingMinInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    statusUpdatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostHavingMaxInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    statusUpdatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostHavingAverageInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    statusUpdatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostHavingStddevSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    statusUpdatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostHavingStddevPopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    statusUpdatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostHavingVarianceSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    statusUpdatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostHavingVariancePopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    statusUpdatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        postUniques[0].attributes.forEach(attributeName => {
          const attribute = postCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        postUniques[0].attributes.forEach(attributeName => {
          const attribute = postCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ROW_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    ROW_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    TITLE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "title",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    TITLE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "title",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    DESCRIPTION_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "description",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    DESCRIPTION_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "description",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    PROJECT_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "project_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    PROJECT_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "project_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    USER_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "user_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    USER_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "user_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    STATUS_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "status_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    STATUS_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "status_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    STATUS_UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "status_updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    STATUS_UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "status_updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPVOTES_COUNT_ASC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation3.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation3.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "ASC"
        });
      }
    },
    UPVOTES_COUNT_DESC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation3.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation3.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "DESC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_ROW_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation3.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation3.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_upvote.attributes.id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.id.codec,
          direction: "ASC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_ROW_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation3.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation3.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_upvote.attributes.id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.id.codec,
          direction: "DESC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_POST_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation3.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation3.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_upvote.attributes.post_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.post_id.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.post_id.codec,
          direction: "ASC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_POST_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation3.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation3.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_upvote.attributes.post_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.post_id.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.post_id.codec,
          direction: "DESC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_USER_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation3.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation3.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_upvote.attributes.user_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.user_id.codec,
          direction: "ASC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_USER_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation3.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation3.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_upvote.attributes.user_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.user_id.codec,
          direction: "DESC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_CREATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation3.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation3.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_upvote.attributes.created_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.created_at.codec,
          direction: "ASC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_CREATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation3.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation3.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_upvote.attributes.created_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.created_at.codec,
          direction: "DESC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation3.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation3.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_upvote.attributes.updated_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.updated_at.codec,
          direction: "ASC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation3.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation3.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_upvote.attributes.updated_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.updated_at.codec,
          direction: "DESC"
        });
      }
    },
    COMMENTS_COUNT_ASC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation4.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation4.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "ASC"
        });
      }
    },
    COMMENTS_COUNT_DESC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation4.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation4.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "DESC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_ROW_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation4.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation4.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_comment.attributes.id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.id.codec,
          direction: "ASC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_ROW_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation4.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation4.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_comment.attributes.id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.id.codec,
          direction: "DESC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_MESSAGE_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation4.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation4.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("message")}`, spec_comment.attributes.message.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.message.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.message.codec,
          direction: "ASC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_MESSAGE_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation4.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation4.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("message")}`, spec_comment.attributes.message.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.message.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.message.codec,
          direction: "DESC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_POST_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation4.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation4.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_comment.attributes.post_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.post_id.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.post_id.codec,
          direction: "ASC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_POST_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation4.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation4.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_comment.attributes.post_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.post_id.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.post_id.codec,
          direction: "DESC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_USER_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation4.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation4.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_comment.attributes.user_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.user_id.codec,
          direction: "ASC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_USER_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation4.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation4.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_comment.attributes.user_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.user_id.codec,
          direction: "DESC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_CREATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation4.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation4.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_comment.attributes.created_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.created_at.codec,
          direction: "ASC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_CREATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation4.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation4.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_comment.attributes.created_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.created_at.codec,
          direction: "DESC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation4.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation4.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_comment.attributes.updated_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.updated_at.codec,
          direction: "ASC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation4.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation4.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_comment.attributes.updated_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.updated_at.codec,
          direction: "DESC"
        });
      }
    },
    DOWNVOTES_COUNT_ASC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation5.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation5.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "ASC"
        });
      }
    },
    DOWNVOTES_COUNT_DESC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation5.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation5.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "DESC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_ROW_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation5.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation5.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_downvote.attributes.id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.id.codec,
          direction: "ASC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_ROW_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation5.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation5.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_downvote.attributes.id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.id.codec,
          direction: "DESC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_POST_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation5.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation5.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_downvote.attributes.post_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.post_id.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.post_id.codec,
          direction: "ASC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_POST_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation5.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation5.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_downvote.attributes.post_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.post_id.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.post_id.codec,
          direction: "DESC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_USER_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation5.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation5.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_downvote.attributes.user_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.user_id.codec,
          direction: "ASC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_USER_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation5.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation5.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_downvote.attributes.user_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.user_id.codec,
          direction: "DESC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_CREATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation5.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation5.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_downvote.attributes.created_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.created_at.codec,
          direction: "ASC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_CREATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation5.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation5.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_downvote.attributes.created_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.created_at.codec,
          direction: "DESC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation5.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation5.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_downvote.attributes.updated_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.updated_at.codec,
          direction: "ASC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation5.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation5.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_downvote.attributes.updated_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.updated_at.codec,
          direction: "DESC"
        });
      }
    }
  },
  PostCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_post.attributes.id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    title: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "title",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "title",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_post.attributes.title.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    description: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "description",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "description",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_post.attributes.description.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    projectId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "project_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "project_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_post.attributes.project_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "user_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "user_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_post.attributes.user_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_post.attributes.created_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_post.attributes.updated_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    statusId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "status_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "status_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_post.attributes.status_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    statusUpdatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "status_updated_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "status_updated_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_post.attributes.status_updated_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpvoteConnection: {
    __assertStep: ConnectionStep,
    nodes($connection) {
      return $connection.nodes();
    },
    edges($connection) {
      return $connection.edges();
    },
    pageInfo($connection) {
      return $connection.pageInfo();
    },
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect, input) {
            var _a, _b;
            const val = input.getRaw().eval();
            if (!Array.isArray(val)) throw new Error("Invalid!");
            for (const group of val) {
              const config = getEnumValueConfig(UpvoteGroupBy, group),
                plan = (_b = (_a = config === null || config === void 0 ? void 0 : config.extensions) === null || _a === void 0 ? void 0 : _a.grafast) === null || _b === void 0 ? void 0 : _b.applyPlan;
              if (typeof plan === "function") plan($pgSelect);
            }
            return null;
          }
        },
        having: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect) {
            return $pgSelect.havingPlan();
          }
        }
      }
    }
  },
  Upvote: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    postId($record) {
      return $record.get("post_id");
    },
    userId($record) {
      return $record.get("user_id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    post($record) {
      return resource_postPgResource.get({
        id: $record.get("post_id")
      });
    },
    user($record) {
      return resource_userPgResource.get({
        id: $record.get("user_id")
      });
    }
  },
  UpvoteEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  UpvoteAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const groups = $pgSelectSingle.getClassStep().getGroups();
      if (groups.length > 0) return $pgSelectSingle.select(sql`json_build_array(${sql.join(groups.map(g => g.fragment), ", ")})`, TYPES.json);else return constant(null);
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  UpvoteDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    postId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("post_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    userId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("user_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  UpvoteGroupBy: {
    POST_ID: {
      applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan
    },
    USER_ID: {
      applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan2
    },
    CREATED_AT: {
      applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan3
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan4
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan5
    },
    UPDATED_AT: {
      applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan6
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan7
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: UpvoteGroupBy_extensions_grafast_applyPlan8
    }
  },
  UpvoteHavingInput: {
    AND: {
      applyPlan($where, input) {
        input.apply($where);
        return null;
      }
    },
    OR: {
      applyPlan($where, input) {
        const $or = new PgOrFilterStep($where);
        input.apply($or);
        return null;
      }
    },
    sum: {
      applyPlan($having) {
        return $having;
      }
    },
    distinctCount: {
      applyPlan($having) {
        return $having;
      }
    },
    min: {
      applyPlan($having) {
        return $having;
      }
    },
    max: {
      applyPlan($having) {
        return $having;
      }
    },
    average: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevSample: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevPopulation: {
      applyPlan($having) {
        return $having;
      }
    },
    varianceSample: {
      applyPlan($having) {
        return $having;
      }
    },
    variancePopulation: {
      applyPlan($having) {
        return $having;
      }
    }
  },
  UpvoteHavingSumInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UpvoteHavingDistinctCountInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UpvoteHavingMinInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UpvoteHavingMaxInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UpvoteHavingAverageInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UpvoteHavingStddevSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UpvoteHavingStddevPopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UpvoteHavingVarianceSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UpvoteHavingVariancePopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UpvoteOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        upvoteUniques[0].attributes.forEach(attributeName => {
          const attribute = upvoteCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        upvoteUniques[0].attributes.forEach(attributeName => {
          const attribute = upvoteCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ROW_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    ROW_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    POST_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "post_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    POST_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "post_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    USER_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "user_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    USER_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "user_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    }
  },
  UpvoteCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_upvote.attributes.id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    postId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "post_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "post_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_upvote.attributes.post_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "user_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "user_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_upvote.attributes.user_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_upvote.attributes.created_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_upvote.attributes.updated_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MemberOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        memberUniques[0].attributes.forEach(attributeName => {
          const attribute = memberCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        memberUniques[0].attributes.forEach(attributeName => {
          const attribute = memberCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    USER_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "user_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    USER_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "user_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    ORGANIZATION_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "organization_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    ORGANIZATION_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "organization_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    ROLE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "role",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    ROLE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "role",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    ROW_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    ROW_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    }
  },
  MemberCondition: {
    userId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "user_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "user_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_member.attributes.user_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_member.attributes.organization_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_member.attributes.created_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    role: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "role",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "role",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_member.attributes.role.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_member.attributes.id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CommentConnection: {
    __assertStep: ConnectionStep,
    nodes($connection) {
      return $connection.nodes();
    },
    edges($connection) {
      return $connection.edges();
    },
    pageInfo($connection) {
      return $connection.pageInfo();
    },
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect, input) {
            var _a, _b;
            const val = input.getRaw().eval();
            if (!Array.isArray(val)) throw new Error("Invalid!");
            for (const group of val) {
              const config = getEnumValueConfig(CommentGroupBy, group),
                plan = (_b = (_a = config === null || config === void 0 ? void 0 : config.extensions) === null || _a === void 0 ? void 0 : _a.grafast) === null || _b === void 0 ? void 0 : _b.applyPlan;
              if (typeof plan === "function") plan($pgSelect);
            }
            return null;
          }
        },
        having: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect) {
            return $pgSelect.havingPlan();
          }
        }
      }
    }
  },
  Comment: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    message($record) {
      return $record.get("message");
    },
    postId($record) {
      return $record.get("post_id");
    },
    userId($record) {
      return $record.get("user_id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    post($record) {
      return resource_postPgResource.get({
        id: $record.get("post_id")
      });
    },
    user($record) {
      return resource_userPgResource.get({
        id: $record.get("user_id")
      });
    }
  },
  CommentEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CommentAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const groups = $pgSelectSingle.getClassStep().getGroups();
      if (groups.length > 0) return $pgSelectSingle.select(sql`json_build_array(${sql.join(groups.map(g => g.fragment), ", ")})`, TYPES.json);else return constant(null);
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  CommentDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    message($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("message")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    postId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("post_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    userId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("user_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  CommentGroupBy: {
    MESSAGE: {
      applyPlan: CommentGroupBy_extensions_grafast_applyPlan
    },
    POST_ID: {
      applyPlan: CommentGroupBy_extensions_grafast_applyPlan2
    },
    USER_ID: {
      applyPlan: CommentGroupBy_extensions_grafast_applyPlan3
    },
    CREATED_AT: {
      applyPlan: CommentGroupBy_extensions_grafast_applyPlan4
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: CommentGroupBy_extensions_grafast_applyPlan5
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: CommentGroupBy_extensions_grafast_applyPlan6
    },
    UPDATED_AT: {
      applyPlan: CommentGroupBy_extensions_grafast_applyPlan7
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: CommentGroupBy_extensions_grafast_applyPlan8
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: CommentGroupBy_extensions_grafast_applyPlan9
    }
  },
  CommentHavingInput: {
    AND: {
      applyPlan($where, input) {
        input.apply($where);
        return null;
      }
    },
    OR: {
      applyPlan($where, input) {
        const $or = new PgOrFilterStep($where);
        input.apply($or);
        return null;
      }
    },
    sum: {
      applyPlan($having) {
        return $having;
      }
    },
    distinctCount: {
      applyPlan($having) {
        return $having;
      }
    },
    min: {
      applyPlan($having) {
        return $having;
      }
    },
    max: {
      applyPlan($having) {
        return $having;
      }
    },
    average: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevSample: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevPopulation: {
      applyPlan($having) {
        return $having;
      }
    },
    varianceSample: {
      applyPlan($having) {
        return $having;
      }
    },
    variancePopulation: {
      applyPlan($having) {
        return $having;
      }
    }
  },
  CommentHavingSumInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  CommentHavingDistinctCountInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  CommentHavingMinInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  CommentHavingMaxInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  CommentHavingAverageInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  CommentHavingStddevSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  CommentHavingStddevPopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  CommentHavingVarianceSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  CommentHavingVariancePopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  CommentOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        commentUniques[0].attributes.forEach(attributeName => {
          const attribute = commentCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        commentUniques[0].attributes.forEach(attributeName => {
          const attribute = commentCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ROW_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    ROW_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    MESSAGE_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "message",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    MESSAGE_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "message",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    POST_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "post_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    POST_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "post_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    USER_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "user_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    USER_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "user_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    }
  },
  CommentCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_comment.attributes.id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    message: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "message",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "message",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_comment.attributes.message.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    postId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "post_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "post_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_comment.attributes.post_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "user_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "user_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_comment.attributes.user_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_comment.attributes.created_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_comment.attributes.updated_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  DownvoteConnection: {
    __assertStep: ConnectionStep,
    nodes($connection) {
      return $connection.nodes();
    },
    edges($connection) {
      return $connection.edges();
    },
    pageInfo($connection) {
      return $connection.pageInfo();
    },
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect, input) {
            var _a, _b;
            const val = input.getRaw().eval();
            if (!Array.isArray(val)) throw new Error("Invalid!");
            for (const group of val) {
              const config = getEnumValueConfig(DownvoteGroupBy, group),
                plan = (_b = (_a = config === null || config === void 0 ? void 0 : config.extensions) === null || _a === void 0 ? void 0 : _a.grafast) === null || _b === void 0 ? void 0 : _b.applyPlan;
              if (typeof plan === "function") plan($pgSelect);
            }
            return null;
          }
        },
        having: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect) {
            return $pgSelect.havingPlan();
          }
        }
      }
    }
  },
  DownvoteEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  DownvoteAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const groups = $pgSelectSingle.getClassStep().getGroups();
      if (groups.length > 0) return $pgSelectSingle.select(sql`json_build_array(${sql.join(groups.map(g => g.fragment), ", ")})`, TYPES.json);else return constant(null);
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  DownvoteDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    postId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("post_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    userId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("user_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  DownvoteGroupBy: {
    POST_ID: {
      applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan
    },
    USER_ID: {
      applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan2
    },
    CREATED_AT: {
      applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan3
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan4
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan5
    },
    UPDATED_AT: {
      applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan6
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan7
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: DownvoteGroupBy_extensions_grafast_applyPlan8
    }
  },
  DownvoteHavingInput: {
    AND: {
      applyPlan($where, input) {
        input.apply($where);
        return null;
      }
    },
    OR: {
      applyPlan($where, input) {
        const $or = new PgOrFilterStep($where);
        input.apply($or);
        return null;
      }
    },
    sum: {
      applyPlan($having) {
        return $having;
      }
    },
    distinctCount: {
      applyPlan($having) {
        return $having;
      }
    },
    min: {
      applyPlan($having) {
        return $having;
      }
    },
    max: {
      applyPlan($having) {
        return $having;
      }
    },
    average: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevSample: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevPopulation: {
      applyPlan($having) {
        return $having;
      }
    },
    varianceSample: {
      applyPlan($having) {
        return $having;
      }
    },
    variancePopulation: {
      applyPlan($having) {
        return $having;
      }
    }
  },
  DownvoteHavingSumInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  DownvoteHavingDistinctCountInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  DownvoteHavingMinInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  DownvoteHavingMaxInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  DownvoteHavingAverageInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  DownvoteHavingStddevSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  DownvoteHavingStddevPopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  DownvoteHavingVarianceSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  DownvoteHavingVariancePopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  DownvoteOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        downvoteUniques[0].attributes.forEach(attributeName => {
          const attribute = downvoteCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        downvoteUniques[0].attributes.forEach(attributeName => {
          const attribute = downvoteCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ROW_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    ROW_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    POST_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "post_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    POST_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "post_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    USER_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "user_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    USER_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "user_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    }
  },
  DownvoteCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_downvote.attributes.id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    postId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "post_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "post_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_downvote.attributes.post_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "user_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "user_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_downvote.attributes.user_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_downvote.attributes.created_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_downvote.attributes.updated_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  MemberEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  MemberAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const groups = $pgSelectSingle.getClassStep().getGroups();
      if (groups.length > 0) return $pgSelectSingle.select(sql`json_build_array(${sql.join(groups.map(g => g.fragment), ", ")})`, TYPES.json);else return constant(null);
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  MemberDistinctCountAggregates: {
    userId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("user_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    organizationId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("organization_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    role($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("role")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, roleCodec);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  MemberGroupBy: {
    USER_ID: {
      applyPlan: MemberGroupBy_extensions_grafast_applyPlan
    },
    ORGANIZATION_ID: {
      applyPlan: MemberGroupBy_extensions_grafast_applyPlan2
    },
    CREATED_AT: {
      applyPlan: MemberGroupBy_extensions_grafast_applyPlan3
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: MemberGroupBy_extensions_grafast_applyPlan4
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: MemberGroupBy_extensions_grafast_applyPlan5
    },
    ROLE: {
      applyPlan: MemberGroupBy_extensions_grafast_applyPlan6
    }
  },
  MemberHavingInput: {
    AND: {
      applyPlan($where, input) {
        input.apply($where);
        return null;
      }
    },
    OR: {
      applyPlan($where, input) {
        const $or = new PgOrFilterStep($where);
        input.apply($or);
        return null;
      }
    },
    sum: {
      applyPlan($having) {
        return $having;
      }
    },
    distinctCount: {
      applyPlan($having) {
        return $having;
      }
    },
    min: {
      applyPlan($having) {
        return $having;
      }
    },
    max: {
      applyPlan($having) {
        return $having;
      }
    },
    average: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevSample: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevPopulation: {
      applyPlan($having) {
        return $having;
      }
    },
    varianceSample: {
      applyPlan($having) {
        return $having;
      }
    },
    variancePopulation: {
      applyPlan($having) {
        return $having;
      }
    }
  },
  MemberHavingSumInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  MemberHavingDistinctCountInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  MemberHavingMinInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  MemberHavingMaxInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  MemberHavingAverageInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  MemberHavingStddevSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  MemberHavingStddevPopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  MemberHavingVarianceSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  MemberHavingVariancePopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  InvitationConnection: {
    __assertStep: ConnectionStep,
    nodes($connection) {
      return $connection.nodes();
    },
    edges($connection) {
      return $connection.edges();
    },
    pageInfo($connection) {
      return $connection.pageInfo();
    },
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect, input) {
            var _a, _b;
            const val = input.getRaw().eval();
            if (!Array.isArray(val)) throw new Error("Invalid!");
            for (const group of val) {
              const config = getEnumValueConfig(InvitationGroupBy, group),
                plan = (_b = (_a = config === null || config === void 0 ? void 0 : config.extensions) === null || _a === void 0 ? void 0 : _a.grafast) === null || _b === void 0 ? void 0 : _b.applyPlan;
              if (typeof plan === "function") plan($pgSelect);
            }
            return null;
          }
        },
        having: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect) {
            return $pgSelect.havingPlan();
          }
        }
      }
    }
  },
  Invitation: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    organizationId($record) {
      return $record.get("organization_id");
    },
    email($record) {
      return $record.get("email");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    organization($record) {
      return resource_organizationPgResource.get({
        id: $record.get("organization_id")
      });
    }
  },
  InvitationEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  InvitationAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const groups = $pgSelectSingle.getClassStep().getGroups();
      if (groups.length > 0) return $pgSelectSingle.select(sql`json_build_array(${sql.join(groups.map(g => g.fragment), ", ")})`, TYPES.json);else return constant(null);
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  InvitationDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    organizationId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("organization_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    email($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("email")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  InvitationGroupBy: {
    ORGANIZATION_ID: {
      applyPlan: InvitationGroupBy_extensions_grafast_applyPlan
    },
    CREATED_AT: {
      applyPlan: InvitationGroupBy_extensions_grafast_applyPlan2
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: InvitationGroupBy_extensions_grafast_applyPlan3
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: InvitationGroupBy_extensions_grafast_applyPlan4
    },
    UPDATED_AT: {
      applyPlan: InvitationGroupBy_extensions_grafast_applyPlan5
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: InvitationGroupBy_extensions_grafast_applyPlan6
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: InvitationGroupBy_extensions_grafast_applyPlan7
    }
  },
  InvitationHavingInput: {
    AND: {
      applyPlan($where, input) {
        input.apply($where);
        return null;
      }
    },
    OR: {
      applyPlan($where, input) {
        const $or = new PgOrFilterStep($where);
        input.apply($or);
        return null;
      }
    },
    sum: {
      applyPlan($having) {
        return $having;
      }
    },
    distinctCount: {
      applyPlan($having) {
        return $having;
      }
    },
    min: {
      applyPlan($having) {
        return $having;
      }
    },
    max: {
      applyPlan($having) {
        return $having;
      }
    },
    average: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevSample: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevPopulation: {
      applyPlan($having) {
        return $having;
      }
    },
    varianceSample: {
      applyPlan($having) {
        return $having;
      }
    },
    variancePopulation: {
      applyPlan($having) {
        return $having;
      }
    }
  },
  InvitationHavingSumInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  InvitationHavingDistinctCountInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  InvitationHavingMinInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  InvitationHavingMaxInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  InvitationHavingAverageInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  InvitationHavingStddevSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  InvitationHavingStddevPopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  InvitationHavingVarianceSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  InvitationHavingVariancePopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  InvitationOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        invitationUniques[0].attributes.forEach(attributeName => {
          const attribute = invitationCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        invitationUniques[0].attributes.forEach(attributeName => {
          const attribute = invitationCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ROW_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    ROW_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    ORGANIZATION_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "organization_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    ORGANIZATION_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "organization_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    EMAIL_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "email",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    EMAIL_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "email",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    }
  },
  InvitationCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_invitation.attributes.id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "organization_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_invitation.attributes.organization_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    email: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "email",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "email",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_invitation.attributes.email.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_invitation.attributes.created_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_invitation.attributes.updated_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  PostStatusConnection: {
    __assertStep: ConnectionStep,
    nodes($connection) {
      return $connection.nodes();
    },
    edges($connection) {
      return $connection.edges();
    },
    pageInfo($connection) {
      return $connection.pageInfo();
    },
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect, input) {
            var _a, _b;
            const val = input.getRaw().eval();
            if (!Array.isArray(val)) throw new Error("Invalid!");
            for (const group of val) {
              const config = getEnumValueConfig(PostStatusGroupBy, group),
                plan = (_b = (_a = config === null || config === void 0 ? void 0 : config.extensions) === null || _a === void 0 ? void 0 : _a.grafast) === null || _b === void 0 ? void 0 : _b.applyPlan;
              if (typeof plan === "function") plan($pgSelect);
            }
            return null;
          }
        },
        having: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect) {
            return $pgSelect.havingPlan();
          }
        }
      }
    }
  },
  PostStatus: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    status($record) {
      return $record.get("status");
    },
    description($record) {
      return $record.get("description");
    },
    color($record) {
      return $record.get("color");
    },
    projectId($record) {
      return $record.get("project_id");
    },
    isDefault($record) {
      return $record.get("is_default");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    project($record) {
      return resource_projectPgResource.get({
        id: $record.get("project_id")
      });
    },
    postsByStatusId: {
      plan($record) {
        const $records = resource_postPgResource.find({
          status_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, arg) {
            $connection.setFirst(arg.getRaw());
          }
        },
        last: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setLast(val.getRaw());
          }
        },
        offset: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setOffset(val.getRaw());
          }
        },
        before: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setBefore(val.getRaw());
          }
        },
        after: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val) {
            $connection.setAfter(val.getRaw());
          }
        },
        orderBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, val, info) {
            const $value = val.getRaw(),
              $select = $connection.getSubplan();
            applyOrderToPlan($select, $value, info.schema.getType("PostOrderBy"));
            return null;
          }
        },
        condition: {
          autoApplyAfterParentPlan: true,
          applyPlan(_condition, $connection) {
            return $connection.getSubplan().wherePlan();
          }
        },
        filter: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $connection, fieldArgs) {
            assertAllowed61(fieldArgs, "object");
            const $where = $connection.getSubplan().wherePlan();
            if (null) $where.extensions.pgFilterAttribute = {
              codec: null
            };
            fieldArgs.apply($where);
          }
        }
      }
    }
  },
  PostStatusEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PostStatusAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const groups = $pgSelectSingle.getClassStep().getGroups();
      if (groups.length > 0) return $pgSelectSingle.select(sql`json_build_array(${sql.join(groups.map(g => g.fragment), ", ")})`, TYPES.json);else return constant(null);
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  PostStatusDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    status($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("status")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    description($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("description")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    color($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("color")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    projectId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("project_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    isDefault($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("is_default")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.boolean);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  PostStatusGroupBy: {
    STATUS: {
      applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan
    },
    DESCRIPTION: {
      applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan2
    },
    COLOR: {
      applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan3
    },
    PROJECT_ID: {
      applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan4
    },
    IS_DEFAULT: {
      applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan5
    },
    CREATED_AT: {
      applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan6
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan7
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan8
    },
    UPDATED_AT: {
      applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan9
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan10
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: PostStatusGroupBy_extensions_grafast_applyPlan11
    }
  },
  PostStatusHavingInput: {
    AND: {
      applyPlan($where, input) {
        input.apply($where);
        return null;
      }
    },
    OR: {
      applyPlan($where, input) {
        const $or = new PgOrFilterStep($where);
        input.apply($or);
        return null;
      }
    },
    sum: {
      applyPlan($having) {
        return $having;
      }
    },
    distinctCount: {
      applyPlan($having) {
        return $having;
      }
    },
    min: {
      applyPlan($having) {
        return $having;
      }
    },
    max: {
      applyPlan($having) {
        return $having;
      }
    },
    average: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevSample: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevPopulation: {
      applyPlan($having) {
        return $having;
      }
    },
    varianceSample: {
      applyPlan($having) {
        return $having;
      }
    },
    variancePopulation: {
      applyPlan($having) {
        return $having;
      }
    }
  },
  PostStatusHavingSumInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostStatusHavingDistinctCountInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostStatusHavingMinInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostStatusHavingMaxInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostStatusHavingAverageInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostStatusHavingStddevSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostStatusHavingStddevPopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostStatusHavingVarianceSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostStatusHavingVariancePopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  PostStatusOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        post_statusUniques[0].attributes.forEach(attributeName => {
          const attribute = postStatusCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        post_statusUniques[0].attributes.forEach(attributeName => {
          const attribute = postStatusCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ROW_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    ROW_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    STATUS_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "status",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    STATUS_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "status",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    DESCRIPTION_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "description",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    DESCRIPTION_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "description",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    COLOR_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "color",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    COLOR_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "color",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    PROJECT_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "project_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    PROJECT_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "project_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    IS_DEFAULT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "is_default",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    IS_DEFAULT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "is_default",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    POSTS_BY_STATUS_ID_COUNT_ASC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "ASC"
        });
      }
    },
    POSTS_BY_STATUS_ID_COUNT_DESC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "DESC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_ROW_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_post.attributes.id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.id.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_ROW_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_post.attributes.id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.id.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_TITLE_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("title")}`, spec_post.attributes.title.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.title.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.title.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_TITLE_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("title")}`, spec_post.attributes.title.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.title.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.title.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_DESCRIPTION_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_post.attributes.description.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.description.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.description.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_DESCRIPTION_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_post.attributes.description.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.description.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.description.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_PROJECT_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_post.attributes.project_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.project_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.project_id.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_PROJECT_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_post.attributes.project_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.project_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.project_id.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_USER_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_post.attributes.user_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.user_id.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_USER_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_post.attributes.user_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.user_id.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_CREATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_post.attributes.created_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.created_at.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_CREATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_post.attributes.created_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.created_at.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_post.attributes.updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.updated_at.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_post.attributes.updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.updated_at.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_id")}`, spec_post.attributes.status_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.status_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.status_id.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_id")}`, spec_post.attributes.status_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.status_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.status_id.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_updated_at")}`, spec_post.attributes.status_updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.status_updated_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.status_updated_at.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation6.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation6.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_updated_at")}`, spec_post.attributes.status_updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.status_updated_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.status_updated_at.codec,
          direction: "DESC"
        });
      }
    }
  },
  PostStatusCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_postStatus.attributes.id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    status: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "status",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "status",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_postStatus.attributes.status.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    description: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "description",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "description",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_postStatus.attributes.description.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    color: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "color",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "color",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_postStatus.attributes.color.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    projectId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "project_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "project_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_postStatus.attributes.project_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    isDefault: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "is_default",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "is_default",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_postStatus.attributes.is_default.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_postStatus.attributes.created_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_postStatus.attributes.updated_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  OrganizationConnection: {
    __assertStep: ConnectionStep,
    nodes($connection) {
      return $connection.nodes();
    },
    edges($connection) {
      return $connection.edges();
    },
    pageInfo($connection) {
      return $connection.pageInfo();
    },
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect, input) {
            var _a, _b;
            const val = input.getRaw().eval();
            if (!Array.isArray(val)) throw new Error("Invalid!");
            for (const group of val) {
              const config = getEnumValueConfig(OrganizationGroupBy, group),
                plan = (_b = (_a = config === null || config === void 0 ? void 0 : config.extensions) === null || _a === void 0 ? void 0 : _a.grafast) === null || _b === void 0 ? void 0 : _b.applyPlan;
              if (typeof plan === "function") plan($pgSelect);
            }
            return null;
          }
        },
        having: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect) {
            return $pgSelect.havingPlan();
          }
        }
      }
    }
  },
  OrganizationEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  OrganizationAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const groups = $pgSelectSingle.getClassStep().getGroups();
      if (groups.length > 0) return $pgSelectSingle.select(sql`json_build_array(${sql.join(groups.map(g => g.fragment), ", ")})`, TYPES.json);else return constant(null);
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  OrganizationDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    name($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("name")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    slug($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("slug")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  OrganizationGroupBy: {
    CREATED_AT: {
      applyPlan: OrganizationGroupBy_extensions_grafast_applyPlan
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: OrganizationGroupBy_extensions_grafast_applyPlan2
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: OrganizationGroupBy_extensions_grafast_applyPlan3
    },
    UPDATED_AT: {
      applyPlan: OrganizationGroupBy_extensions_grafast_applyPlan4
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: OrganizationGroupBy_extensions_grafast_applyPlan5
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: OrganizationGroupBy_extensions_grafast_applyPlan6
    }
  },
  OrganizationHavingInput: {
    AND: {
      applyPlan($where, input) {
        input.apply($where);
        return null;
      }
    },
    OR: {
      applyPlan($where, input) {
        const $or = new PgOrFilterStep($where);
        input.apply($or);
        return null;
      }
    },
    sum: {
      applyPlan($having) {
        return $having;
      }
    },
    distinctCount: {
      applyPlan($having) {
        return $having;
      }
    },
    min: {
      applyPlan($having) {
        return $having;
      }
    },
    max: {
      applyPlan($having) {
        return $having;
      }
    },
    average: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevSample: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevPopulation: {
      applyPlan($having) {
        return $having;
      }
    },
    varianceSample: {
      applyPlan($having) {
        return $having;
      }
    },
    variancePopulation: {
      applyPlan($having) {
        return $having;
      }
    }
  },
  OrganizationHavingSumInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  OrganizationHavingDistinctCountInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  OrganizationHavingMinInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  OrganizationHavingMaxInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  OrganizationHavingAverageInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  OrganizationHavingStddevSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  OrganizationHavingStddevPopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  OrganizationHavingVarianceSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  OrganizationHavingVariancePopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  OrganizationOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        organizationUniques[0].attributes.forEach(attributeName => {
          const attribute = organizationCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        organizationUniques[0].attributes.forEach(attributeName => {
          const attribute = organizationCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ROW_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    ROW_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    SLUG_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "slug",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    SLUG_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "slug",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    PROJECTS_COUNT_ASC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "ASC"
        });
      }
    },
    PROJECTS_COUNT_DESC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "DESC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_ROW_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_project.attributes.id.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.id.codec,
          direction: "ASC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_ROW_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_project.attributes.id.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.id.codec,
          direction: "DESC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_NAME_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("name")}`, spec_project.attributes.name.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.name.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.name.codec,
          direction: "ASC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_NAME_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("name")}`, spec_project.attributes.name.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.name.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.name.codec,
          direction: "DESC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_IMAGE_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("image")}`, spec_project.attributes.image.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.image.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.image.codec,
          direction: "ASC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_IMAGE_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("image")}`, spec_project.attributes.image.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.image.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.image.codec,
          direction: "DESC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_SLUG_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("slug")}`, spec_project.attributes.slug.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.slug.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.slug.codec,
          direction: "ASC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_SLUG_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("slug")}`, spec_project.attributes.slug.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.slug.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.slug.codec,
          direction: "DESC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_DESCRIPTION_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_project.attributes.description.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.description.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.description.codec,
          direction: "ASC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_DESCRIPTION_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_project.attributes.description.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.description.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.description.codec,
          direction: "DESC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_ORGANIZATION_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_project.attributes.organization_id.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.organization_id.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.organization_id.codec,
          direction: "ASC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_ORGANIZATION_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_project.attributes.organization_id.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.organization_id.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.organization_id.codec,
          direction: "DESC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_CREATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_project.attributes.created_at.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.created_at.codec,
          direction: "ASC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_CREATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_project.attributes.created_at.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.created_at.codec,
          direction: "DESC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_project.attributes.updated_at.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.updated_at.codec,
          direction: "ASC"
        });
      }
    },
    PROJECTS_DISTINCT_COUNT_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
        relation7.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation7.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_project.attributes.updated_at.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_project.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_project.attributes.updated_at.codec,
          direction: "DESC"
        });
      }
    },
    MEMBERS_COUNT_ASC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation8.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation8.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "ASC"
        });
      }
    },
    MEMBERS_COUNT_DESC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation8.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation8.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "DESC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_USER_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation8.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation8.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_member.attributes.user_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.user_id.codec,
          direction: "ASC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_USER_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation8.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation8.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_member.attributes.user_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.user_id.codec,
          direction: "DESC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation8.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation8.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_member.attributes.organization_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.organization_id.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.organization_id.codec,
          direction: "ASC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation8.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation8.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_member.attributes.organization_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.organization_id.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.organization_id.codec,
          direction: "DESC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_CREATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation8.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation8.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_member.attributes.created_at.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.created_at.codec,
          direction: "ASC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_CREATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation8.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation8.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_member.attributes.created_at.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.created_at.codec,
          direction: "DESC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_ROLE_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation8.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation8.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("role")}`, spec_member.attributes.role.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.role.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.role.codec,
          direction: "ASC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_ROLE_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation8.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation8.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("role")}`, spec_member.attributes.role.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.role.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.role.codec,
          direction: "DESC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_ROW_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation8.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation8.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_member.attributes.id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.id.codec,
          direction: "ASC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_ROW_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation8.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation8.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_member.attributes.id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.id.codec,
          direction: "DESC"
        });
      }
    },
    INVITATIONS_COUNT_ASC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
        relation9.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation9.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "ASC"
        });
      }
    },
    INVITATIONS_COUNT_DESC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
        relation9.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation9.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "DESC"
        });
      }
    },
    INVITATIONS_DISTINCT_COUNT_ROW_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
        relation9.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation9.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_invitation.attributes.id.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_invitation.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_invitation.attributes.id.codec,
          direction: "ASC"
        });
      }
    },
    INVITATIONS_DISTINCT_COUNT_ROW_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
        relation9.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation9.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_invitation.attributes.id.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_invitation.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_invitation.attributes.id.codec,
          direction: "DESC"
        });
      }
    },
    INVITATIONS_DISTINCT_COUNT_ORGANIZATION_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
        relation9.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation9.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_invitation.attributes.organization_id.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_invitation.attributes.organization_id.codec)) !== null && _b !== void 0 ? _b : spec_invitation.attributes.organization_id.codec,
          direction: "ASC"
        });
      }
    },
    INVITATIONS_DISTINCT_COUNT_ORGANIZATION_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
        relation9.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation9.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_invitation.attributes.organization_id.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_invitation.attributes.organization_id.codec)) !== null && _b !== void 0 ? _b : spec_invitation.attributes.organization_id.codec,
          direction: "DESC"
        });
      }
    },
    INVITATIONS_DISTINCT_COUNT_EMAIL_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
        relation9.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation9.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("email")}`, spec_invitation.attributes.email.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_invitation.attributes.email.codec)) !== null && _b !== void 0 ? _b : spec_invitation.attributes.email.codec,
          direction: "ASC"
        });
      }
    },
    INVITATIONS_DISTINCT_COUNT_EMAIL_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
        relation9.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation9.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("email")}`, spec_invitation.attributes.email.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_invitation.attributes.email.codec)) !== null && _b !== void 0 ? _b : spec_invitation.attributes.email.codec,
          direction: "DESC"
        });
      }
    },
    INVITATIONS_DISTINCT_COUNT_CREATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
        relation9.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation9.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_invitation.attributes.created_at.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_invitation.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_invitation.attributes.created_at.codec,
          direction: "ASC"
        });
      }
    },
    INVITATIONS_DISTINCT_COUNT_CREATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
        relation9.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation9.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_invitation.attributes.created_at.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_invitation.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_invitation.attributes.created_at.codec,
          direction: "DESC"
        });
      }
    },
    INVITATIONS_DISTINCT_COUNT_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
        relation9.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation9.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_invitation.attributes.updated_at.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_invitation.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_invitation.attributes.updated_at.codec,
          direction: "ASC"
        });
      }
    },
    INVITATIONS_DISTINCT_COUNT_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
        relation9.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation9.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_invitation.attributes.updated_at.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_invitation.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_invitation.attributes.updated_at.codec,
          direction: "DESC"
        });
      }
    }
  },
  OrganizationCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_organization.attributes.id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "name",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "name",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_organization.attributes.name.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    slug: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "slug",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "slug",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_organization.attributes.slug.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_organization.attributes.created_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_organization.attributes.updated_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UserConnection: {
    __assertStep: ConnectionStep,
    nodes($connection) {
      return $connection.nodes();
    },
    edges($connection) {
      return $connection.edges();
    },
    pageInfo($connection) {
      return $connection.pageInfo();
    },
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect, input) {
            var _a, _b;
            const val = input.getRaw().eval();
            if (!Array.isArray(val)) throw new Error("Invalid!");
            for (const group of val) {
              const config = getEnumValueConfig(UserGroupBy, group),
                plan = (_b = (_a = config === null || config === void 0 ? void 0 : config.extensions) === null || _a === void 0 ? void 0 : _a.grafast) === null || _b === void 0 ? void 0 : _b.applyPlan;
              if (typeof plan === "function") plan($pgSelect);
            }
            return null;
          }
        },
        having: {
          autoApplyAfterParentPlan: true,
          applyPlan(_$parent, $pgSelect) {
            return $pgSelect.havingPlan();
          }
        }
      }
    }
  },
  UserEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  UserAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const groups = $pgSelectSingle.getClassStep().getGroups();
      if (groups.length > 0) return $pgSelectSingle.select(sql`json_build_array(${sql.join(groups.map(g => g.fragment), ", ")})`, TYPES.json);else return constant(null);
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  UserDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    hidraId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("hidra_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    username($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("username")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    firstName($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("first_name")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    lastName($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("last_name")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    email($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("email")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  UserGroupBy: {
    CREATED_AT: {
      applyPlan: UserGroupBy_extensions_grafast_applyPlan
    },
    CREATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: UserGroupBy_extensions_grafast_applyPlan2
    },
    CREATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: UserGroupBy_extensions_grafast_applyPlan3
    },
    UPDATED_AT: {
      applyPlan: UserGroupBy_extensions_grafast_applyPlan4
    },
    UPDATED_AT_TRUNCATED_TO_HOUR: {
      applyPlan: UserGroupBy_extensions_grafast_applyPlan5
    },
    UPDATED_AT_TRUNCATED_TO_DAY: {
      applyPlan: UserGroupBy_extensions_grafast_applyPlan6
    },
    FIRST_NAME: {
      applyPlan: UserGroupBy_extensions_grafast_applyPlan7
    },
    LAST_NAME: {
      applyPlan: UserGroupBy_extensions_grafast_applyPlan8
    }
  },
  UserHavingInput: {
    AND: {
      applyPlan($where, input) {
        input.apply($where);
        return null;
      }
    },
    OR: {
      applyPlan($where, input) {
        const $or = new PgOrFilterStep($where);
        input.apply($or);
        return null;
      }
    },
    sum: {
      applyPlan($having) {
        return $having;
      }
    },
    distinctCount: {
      applyPlan($having) {
        return $having;
      }
    },
    min: {
      applyPlan($having) {
        return $having;
      }
    },
    max: {
      applyPlan($having) {
        return $having;
      }
    },
    average: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevSample: {
      applyPlan($having) {
        return $having;
      }
    },
    stddevPopulation: {
      applyPlan($having) {
        return $having;
      }
    },
    varianceSample: {
      applyPlan($having) {
        return $having;
      }
    },
    variancePopulation: {
      applyPlan($having) {
        return $having;
      }
    }
  },
  UserHavingSumInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UserHavingDistinctCountInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UserHavingMinInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UserHavingMaxInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UserHavingAverageInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UserHavingStddevSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UserHavingStddevPopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UserHavingVarianceSampleInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UserHavingVariancePopulationInput: {
    createdAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    },
    updatedAt: {
      applyPlan($having) {
        const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
          aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
        return new PgBooleanFilterStep($having, aggregateExpression);
      }
    }
  },
  UserOrderBy: {
    NATURAL: {
      applyPlan() {}
    },
    PRIMARY_KEY_ASC: {
      applyPlan(step) {
        userUniques[0].attributes.forEach(attributeName => {
          const attribute = userCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "ASC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    PRIMARY_KEY_DESC: {
      applyPlan(step) {
        userUniques[0].attributes.forEach(attributeName => {
          const attribute = userCodec.attributes[attributeName];
          step.orderBy({
            codec: attribute.codec,
            fragment: sql`${step}.${sql.identifier(attributeName)}`,
            direction: "DESC",
            ...(undefined != null ? {
              nulls: undefined ? "LAST" : "FIRST"
            } : null)
          });
        });
        step.setOrderIsUnique();
      }
    },
    ROW_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    ROW_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    CREATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "created_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    UPDATED_AT_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "updated_at",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    HIDRA_ID_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "hidra_id",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    HIDRA_ID_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "hidra_id",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    USERNAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "username",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    USERNAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "username",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    FIRST_NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "first_name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    FIRST_NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "first_name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    LAST_NAME_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "last_name",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    LAST_NAME_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "last_name",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (false) plan.setOrderIsUnique();
      }
    },
    EMAIL_ASC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "email",
          direction: "ASC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    EMAIL_DESC: {
      applyPlan(plan) {
        if (!(plan instanceof PgSelectStep) && !(plan instanceof PgUnionAllStep)) throw new Error("Expected a PgSelectStep or PgUnionAllStep when applying ordering value");
        plan.orderBy({
          attribute: "email",
          direction: "DESC",
          ...(undefined != null ? {
            nulls: undefined ? "LAST" : "FIRST"
          } : null)
        });
        if (true) plan.setOrderIsUnique();
      }
    },
    POSTS_COUNT_ASC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "ASC"
        });
      }
    },
    POSTS_COUNT_DESC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_ROW_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_post.attributes.id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.id.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_ROW_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_post.attributes.id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.id.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_TITLE_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("title")}`, spec_post.attributes.title.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.title.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.title.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_TITLE_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("title")}`, spec_post.attributes.title.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.title.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.title.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_DESCRIPTION_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_post.attributes.description.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.description.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.description.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_DESCRIPTION_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_post.attributes.description.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.description.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.description.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_PROJECT_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_post.attributes.project_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.project_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.project_id.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_PROJECT_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_post.attributes.project_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.project_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.project_id.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_USER_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_post.attributes.user_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.user_id.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_USER_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_post.attributes.user_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.user_id.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_CREATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_post.attributes.created_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.created_at.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_CREATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_post.attributes.created_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.created_at.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_post.attributes.updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.updated_at.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_post.attributes.updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.updated_at.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_STATUS_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_id")}`, spec_post.attributes.status_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.status_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.status_id.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_STATUS_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_id")}`, spec_post.attributes.status_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.status_id.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.status_id.codec,
          direction: "DESC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_updated_at")}`, spec_post.attributes.status_updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.status_updated_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.status_updated_at.codec,
          direction: "ASC"
        });
      }
    },
    POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
        relation10.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation10.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_updated_at")}`, spec_post.attributes.status_updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_post.attributes.status_updated_at.codec)) !== null && _b !== void 0 ? _b : spec_post.attributes.status_updated_at.codec,
          direction: "DESC"
        });
      }
    },
    UPVOTES_COUNT_ASC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation11.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation11.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "ASC"
        });
      }
    },
    UPVOTES_COUNT_DESC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation11.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation11.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "DESC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_ROW_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation11.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation11.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_upvote.attributes.id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.id.codec,
          direction: "ASC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_ROW_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation11.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation11.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_upvote.attributes.id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.id.codec,
          direction: "DESC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_POST_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation11.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation11.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_upvote.attributes.post_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.post_id.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.post_id.codec,
          direction: "ASC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_POST_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation11.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation11.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_upvote.attributes.post_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.post_id.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.post_id.codec,
          direction: "DESC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_USER_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation11.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation11.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_upvote.attributes.user_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.user_id.codec,
          direction: "ASC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_USER_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation11.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation11.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_upvote.attributes.user_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.user_id.codec,
          direction: "DESC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_CREATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation11.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation11.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_upvote.attributes.created_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.created_at.codec,
          direction: "ASC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_CREATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation11.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation11.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_upvote.attributes.created_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.created_at.codec,
          direction: "DESC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation11.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation11.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_upvote.attributes.updated_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.updated_at.codec,
          direction: "ASC"
        });
      }
    },
    UPVOTES_DISTINCT_COUNT_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
        relation11.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation11.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_upvote.attributes.updated_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_upvote.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_upvote.attributes.updated_at.codec,
          direction: "DESC"
        });
      }
    },
    MEMBERS_COUNT_ASC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation12.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation12.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "ASC"
        });
      }
    },
    MEMBERS_COUNT_DESC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation12.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation12.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "DESC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_USER_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation12.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation12.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_member.attributes.user_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.user_id.codec,
          direction: "ASC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_USER_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation12.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation12.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_member.attributes.user_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.user_id.codec,
          direction: "DESC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation12.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation12.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_member.attributes.organization_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.organization_id.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.organization_id.codec,
          direction: "ASC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation12.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation12.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_member.attributes.organization_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.organization_id.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.organization_id.codec,
          direction: "DESC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_CREATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation12.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation12.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_member.attributes.created_at.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.created_at.codec,
          direction: "ASC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_CREATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation12.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation12.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_member.attributes.created_at.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.created_at.codec,
          direction: "DESC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_ROLE_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation12.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation12.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("role")}`, spec_member.attributes.role.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.role.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.role.codec,
          direction: "ASC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_ROLE_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation12.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation12.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("role")}`, spec_member.attributes.role.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.role.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.role.codec,
          direction: "DESC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_ROW_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation12.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation12.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_member.attributes.id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.id.codec,
          direction: "ASC"
        });
      }
    },
    MEMBERS_DISTINCT_COUNT_ROW_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
        relation12.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation12.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_member.attributes.id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_member.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_member.attributes.id.codec,
          direction: "DESC"
        });
      }
    },
    COMMENTS_COUNT_ASC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation13.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation13.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "ASC"
        });
      }
    },
    COMMENTS_COUNT_DESC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation13.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation13.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "DESC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_ROW_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation13.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation13.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_comment.attributes.id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.id.codec,
          direction: "ASC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_ROW_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation13.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation13.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_comment.attributes.id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.id.codec,
          direction: "DESC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_MESSAGE_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation13.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation13.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("message")}`, spec_comment.attributes.message.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.message.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.message.codec,
          direction: "ASC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_MESSAGE_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation13.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation13.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("message")}`, spec_comment.attributes.message.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.message.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.message.codec,
          direction: "DESC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_POST_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation13.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation13.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_comment.attributes.post_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.post_id.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.post_id.codec,
          direction: "ASC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_POST_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation13.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation13.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_comment.attributes.post_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.post_id.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.post_id.codec,
          direction: "DESC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_USER_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation13.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation13.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_comment.attributes.user_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.user_id.codec,
          direction: "ASC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_USER_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation13.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation13.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_comment.attributes.user_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.user_id.codec,
          direction: "DESC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_CREATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation13.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation13.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_comment.attributes.created_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.created_at.codec,
          direction: "ASC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_CREATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation13.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation13.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_comment.attributes.created_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.created_at.codec,
          direction: "DESC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation13.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation13.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_comment.attributes.updated_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.updated_at.codec,
          direction: "ASC"
        });
      }
    },
    COMMENTS_DISTINCT_COUNT_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
        relation13.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation13.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_comment.attributes.updated_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_comment.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_comment.attributes.updated_at.codec,
          direction: "DESC"
        });
      }
    },
    DOWNVOTES_COUNT_ASC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation14.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation14.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "ASC"
        });
      }
    },
    DOWNVOTES_COUNT_DESC: {
      applyPlan($select) {
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation14.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation14.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`select count(*)
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
        $select.orderBy({
          fragment,
          codec: TYPES.bigint,
          direction: "DESC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_ROW_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation14.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation14.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_downvote.attributes.id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.id.codec,
          direction: "ASC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_ROW_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation14.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation14.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_downvote.attributes.id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.id.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.id.codec,
          direction: "DESC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_POST_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation14.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation14.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_downvote.attributes.post_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.post_id.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.post_id.codec,
          direction: "ASC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_POST_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation14.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation14.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_downvote.attributes.post_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.post_id.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.post_id.codec,
          direction: "DESC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_USER_ID_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation14.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation14.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_downvote.attributes.user_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.user_id.codec,
          direction: "ASC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_USER_ID_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation14.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation14.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_downvote.attributes.user_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.user_id.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.user_id.codec,
          direction: "DESC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_CREATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation14.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation14.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_downvote.attributes.created_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.created_at.codec,
          direction: "ASC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_CREATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation14.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation14.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_downvote.attributes.created_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.created_at.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.created_at.codec,
          direction: "DESC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_ASC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation14.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation14.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_downvote.attributes.updated_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.updated_at.codec,
          direction: "ASC"
        });
      }
    },
    DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_DESC: {
      applyPlan($select) {
        var _a, _b;
        const foreignTableAlias = $select.alias,
          conditions = [],
          tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
        relation14.localAttributes.forEach((localAttribute, i) => {
          const remoteAttribute = relation14.remoteAttributes[i];
          conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
        });
        if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
        const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_downvote.attributes.updated_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
        $select.orderBy({
          fragment,
          codec: (_b = (_a = spec.pgTypeCodecModifier) === null || _a === void 0 ? void 0 : _a.call(spec, spec_downvote.attributes.updated_at.codec)) !== null && _b !== void 0 ? _b : spec_downvote.attributes.updated_at.codec,
          direction: "DESC"
        });
      }
    }
  },
  UserCondition: {
    rowId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_user.attributes.id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "created_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_user.attributes.created_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "updated_at",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_user.attributes.updated_at.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    hidraId: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "hidra_id",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "hidra_id",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_user.attributes.hidra_id.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    username: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "username",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "username",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_user.attributes.username.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    firstName: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "first_name",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "first_name",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_user.attributes.first_name.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastName: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "last_name",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "last_name",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_user.attributes.last_name.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    email: {
      applyPlan($condition, val) {
        if (val.getRaw().evalIs(null)) $condition.where({
          type: "attribute",
          attribute: "email",
          callback(expression) {
            return sql`${expression} is null`;
          }
        });else $condition.where({
          type: "attribute",
          attribute: "email",
          callback(expression) {
            return sql`${expression} = ${$condition.placeholder(val.get(), spec_user.attributes.email.codec)}`;
          }
        });
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  Mutation: {
    __assertStep: __ValueStep,
    createDownvote: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_downvotePgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    createUpvote: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_upvotePgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    createInvitation: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_invitationPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    createOrganization: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_organizationPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    createComment: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_commentPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    createProject: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"createProject"}, but that function did not return a step!
${String(oldPlan)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    createUser: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_userPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    createMember: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan2(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"createMember"}, but that function did not return a step!
${String(oldPlan2)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper2(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    createPost: {
      plan(_, args) {
        const plan = object({
          result: pgInsertSingle(resource_postPgResource, Object.create(null))
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    createPostStatus: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan3(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"createPostStatus"}, but that function did not return a step!
${String(oldPlan3)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper3(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          autoApplyAfterParentPlan: true,
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    updateDownvote: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan4(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updateDownvote"}, but that function did not return a step!
${String(oldPlan4)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper4(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    updateUpvote: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan5(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updateUpvote"}, but that function did not return a step!
${String(oldPlan5)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper5(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    updateInvitation: {
      plan(_$root, args) {
        const plan = object({
          result: pgUpdateSingle(resource_invitationPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    updateOrganization: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan6(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updateOrganization"}, but that function did not return a step!
${String(oldPlan6)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper6(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    updateComment: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan7(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updateComment"}, but that function did not return a step!
${String(oldPlan7)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper7(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    updateProject: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan8(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updateProject"}, but that function did not return a step!
${String(oldPlan8)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper8(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    updateUser: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan9(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updateUser"}, but that function did not return a step!
${String(oldPlan9)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper9(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    updateMember: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan10(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updateMember"}, but that function did not return a step!
${String(oldPlan10)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper10(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    updatePost: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan11(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updatePost"}, but that function did not return a step!
${String(oldPlan11)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper11(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    updatePostStatus: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan12(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updatePostStatus"}, but that function did not return a step!
${String(oldPlan12)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper12(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    deleteDownvote: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan13(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deleteDownvote"}, but that function did not return a step!
${String(oldPlan13)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper13(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    deleteUpvote: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan14(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deleteUpvote"}, but that function did not return a step!
${String(oldPlan14)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper14(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    deleteInvitation: {
      plan(_$root, args) {
        const plan = object({
          result: pgDeleteSingle(resource_invitationPgResource, {
            id: args.get(['input', "rowId"])
          })
        });
        args.apply(plan);
        return plan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    deleteOrganization: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan15(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deleteOrganization"}, but that function did not return a step!
${String(oldPlan15)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper15(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    deleteComment: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan16(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deleteComment"}, but that function did not return a step!
${String(oldPlan16)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper16(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    deleteProject: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan17(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deleteProject"}, but that function did not return a step!
${String(oldPlan17)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper17(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    deleteUser: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan18(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deleteUser"}, but that function did not return a step!
${String(oldPlan18)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper18(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    deleteMember: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan19(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deleteMember"}, but that function did not return a step!
${String(oldPlan19)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper19(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    deletePost: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan20(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deletePost"}, but that function did not return a step!
${String(oldPlan20)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper20(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    },
    deletePostStatus: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan21(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deletePostStatus"}, but that function did not return a step!
${String(oldPlan21)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper21(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input: {
          applyPlan(_, $object) {
            return $object;
          }
        }
      }
    }
  },
  CreateDownvotePayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    downvote($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    downvoteEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = downvoteUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_downvotePgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("DownvoteOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateDownvoteInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      },
      autoApplyAfterParentApplyPlan: true
    },
    downvote: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      },
      autoApplyAfterParentApplyPlan: true
    }
  },
  DownvoteInput: {
    "__inputPlan": function DownvoteInput_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    postId: {
      applyPlan($insert, val) {
        $insert.set("post_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userId: {
      applyPlan($insert, val) {
        $insert.set("user_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateUpvotePayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    upvote($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    upvoteEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = upvoteUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_upvotePgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("UpvoteOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateUpvoteInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      },
      autoApplyAfterParentApplyPlan: true
    },
    upvote: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      },
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpvoteInput: {
    "__inputPlan": function UpvoteInput_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    postId: {
      applyPlan($insert, val) {
        $insert.set("post_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userId: {
      applyPlan($insert, val) {
        $insert.set("user_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateInvitationPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    invitation($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    invitationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = invitationUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_invitationPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("InvitationOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateInvitationInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      },
      autoApplyAfterParentApplyPlan: true
    },
    invitation: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      },
      autoApplyAfterParentApplyPlan: true
    }
  },
  InvitationInput: {
    "__inputPlan": function InvitationInput_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($insert, val) {
        $insert.set("organization_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    email: {
      applyPlan($insert, val) {
        $insert.set("email", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateOrganizationPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    organization($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    organizationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = organizationUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_organizationPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("OrganizationOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateOrganizationInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      },
      autoApplyAfterParentApplyPlan: true
    },
    organization: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      },
      autoApplyAfterParentApplyPlan: true
    }
  },
  OrganizationInput: {
    "__inputPlan": function OrganizationInput_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    slug: {
      applyPlan($insert, val) {
        $insert.set("slug", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateCommentPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    comment($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    commentEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = commentUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_commentPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CommentOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateCommentInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      },
      autoApplyAfterParentApplyPlan: true
    },
    comment: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      },
      autoApplyAfterParentApplyPlan: true
    }
  },
  CommentInput: {
    "__inputPlan": function CommentInput_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    message: {
      applyPlan($insert, val) {
        $insert.set("message", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    postId: {
      applyPlan($insert, val) {
        $insert.set("post_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userId: {
      applyPlan($insert, val) {
        $insert.set("user_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateProjectPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    project($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    projectEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = projectUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_projectPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ProjectOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateProjectInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      },
      autoApplyAfterParentApplyPlan: true
    },
    project: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      },
      autoApplyAfterParentApplyPlan: true
    }
  },
  ProjectInput: {
    "__inputPlan": function ProjectInput_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    image: {
      applyPlan($insert, val) {
        $insert.set("image", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    slug: {
      applyPlan($insert, val) {
        $insert.set("slug", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    description: {
      applyPlan($insert, val) {
        $insert.set("description", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($insert, val) {
        $insert.set("organization_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateUserPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    user($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    userEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = userUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_userPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("UserOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateUserInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      },
      autoApplyAfterParentApplyPlan: true
    },
    user: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      },
      autoApplyAfterParentApplyPlan: true
    }
  },
  UserInput: {
    "__inputPlan": function UserInput_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    hidraId: {
      applyPlan($insert, val) {
        $insert.set("hidra_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    username: {
      applyPlan($insert, val) {
        $insert.set("username", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    firstName: {
      applyPlan($insert, val) {
        $insert.set("first_name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastName: {
      applyPlan($insert, val) {
        $insert.set("last_name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    email: {
      applyPlan($insert, val) {
        $insert.set("email", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreateMemberPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    member($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    memberEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = memberUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_memberPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("MemberOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreateMemberInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      },
      autoApplyAfterParentApplyPlan: true
    },
    member: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      },
      autoApplyAfterParentApplyPlan: true
    }
  },
  MemberInput: {
    "__inputPlan": function MemberInput_inputPlan() {
      return object(Object.create(null));
    },
    userId: {
      applyPlan($insert, val) {
        $insert.set("user_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($insert, val) {
        $insert.set("organization_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    role: {
      applyPlan($insert, val) {
        $insert.set("role", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreatePostPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    post($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    postEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = postUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_postPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreatePostInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      },
      autoApplyAfterParentApplyPlan: true
    },
    post: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      },
      autoApplyAfterParentApplyPlan: true
    }
  },
  PostInput: {
    "__inputPlan": function PostInput_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    title: {
      applyPlan($insert, val) {
        $insert.set("title", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    description: {
      applyPlan($insert, val) {
        $insert.set("description", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    projectId: {
      applyPlan($insert, val) {
        $insert.set("project_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userId: {
      applyPlan($insert, val) {
        $insert.set("user_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    statusId: {
      applyPlan($insert, val) {
        $insert.set("status_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    statusUpdatedAt: {
      applyPlan($insert, val) {
        $insert.set("status_updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  CreatePostStatusPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    postStatus($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    postStatusEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = post_statusUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_post_statusPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostStatusOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  CreatePostStatusInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      },
      autoApplyAfterParentApplyPlan: true
    },
    postStatus: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      },
      autoApplyAfterParentApplyPlan: true
    }
  },
  PostStatusInput: {
    "__inputPlan": function PostStatusInput_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    status: {
      applyPlan($insert, val) {
        $insert.set("status", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    description: {
      applyPlan($insert, val) {
        $insert.set("description", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    color: {
      applyPlan($insert, val) {
        $insert.set("color", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    projectId: {
      applyPlan($insert, val) {
        $insert.set("project_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    isDefault: {
      applyPlan($insert, val) {
        $insert.set("is_default", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateDownvotePayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    downvote($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    downvoteEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = downvoteUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_downvotePgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("DownvoteOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateDownvoteInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined,
    patch: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      }
    }
  },
  DownvotePatch: {
    "__inputPlan": function DownvotePatch_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    postId: {
      applyPlan($insert, val) {
        $insert.set("post_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userId: {
      applyPlan($insert, val) {
        $insert.set("user_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateUpvotePayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    upvote($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    upvoteEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = upvoteUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_upvotePgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("UpvoteOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateUpvoteInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined,
    patch: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      }
    }
  },
  UpvotePatch: {
    "__inputPlan": function UpvotePatch_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    postId: {
      applyPlan($insert, val) {
        $insert.set("post_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userId: {
      applyPlan($insert, val) {
        $insert.set("user_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateInvitationPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    invitation($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    invitationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = invitationUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_invitationPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("InvitationOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateInvitationInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined,
    patch: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      }
    }
  },
  InvitationPatch: {
    "__inputPlan": function InvitationPatch_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($insert, val) {
        $insert.set("organization_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    email: {
      applyPlan($insert, val) {
        $insert.set("email", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateOrganizationPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    organization($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    organizationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = organizationUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_organizationPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("OrganizationOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateOrganizationInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined,
    patch: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      }
    }
  },
  OrganizationPatch: {
    "__inputPlan": function OrganizationPatch_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    slug: {
      applyPlan($insert, val) {
        $insert.set("slug", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateCommentPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    comment($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    commentEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = commentUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_commentPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CommentOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateCommentInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined,
    patch: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      }
    }
  },
  CommentPatch: {
    "__inputPlan": function CommentPatch_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    message: {
      applyPlan($insert, val) {
        $insert.set("message", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    postId: {
      applyPlan($insert, val) {
        $insert.set("post_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userId: {
      applyPlan($insert, val) {
        $insert.set("user_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateProjectPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    project($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    projectEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = projectUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_projectPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ProjectOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateProjectInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined,
    patch: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      }
    }
  },
  ProjectPatch: {
    "__inputPlan": function ProjectPatch_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    name: {
      applyPlan($insert, val) {
        $insert.set("name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    image: {
      applyPlan($insert, val) {
        $insert.set("image", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    slug: {
      applyPlan($insert, val) {
        $insert.set("slug", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    description: {
      applyPlan($insert, val) {
        $insert.set("description", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($insert, val) {
        $insert.set("organization_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateUserPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    user($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    userEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = userUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_userPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("UserOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateUserInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined,
    patch: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      }
    }
  },
  UserPatch: {
    "__inputPlan": function UserPatch_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    hidraId: {
      applyPlan($insert, val) {
        $insert.set("hidra_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    username: {
      applyPlan($insert, val) {
        $insert.set("username", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    firstName: {
      applyPlan($insert, val) {
        $insert.set("first_name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    lastName: {
      applyPlan($insert, val) {
        $insert.set("last_name", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    email: {
      applyPlan($insert, val) {
        $insert.set("email", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdateMemberPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    member($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    memberEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = memberUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_memberPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("MemberOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdateMemberInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined,
    patch: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      }
    }
  },
  MemberPatch: {
    "__inputPlan": function MemberPatch_inputPlan() {
      return object(Object.create(null));
    },
    userId: {
      applyPlan($insert, val) {
        $insert.set("user_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    organizationId: {
      applyPlan($insert, val) {
        $insert.set("organization_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    role: {
      applyPlan($insert, val) {
        $insert.set("role", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdatePostPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    post($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    postEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = postUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_postPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdatePostInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined,
    patch: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      }
    }
  },
  PostPatch: {
    "__inputPlan": function PostPatch_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    title: {
      applyPlan($insert, val) {
        $insert.set("title", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    description: {
      applyPlan($insert, val) {
        $insert.set("description", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    projectId: {
      applyPlan($insert, val) {
        $insert.set("project_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    userId: {
      applyPlan($insert, val) {
        $insert.set("user_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    statusId: {
      applyPlan($insert, val) {
        $insert.set("status_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    statusUpdatedAt: {
      applyPlan($insert, val) {
        $insert.set("status_updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  UpdatePostStatusPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    postStatus($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    postStatusEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = post_statusUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_post_statusPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostStatusOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  UpdatePostStatusInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined,
    patch: {
      applyPlan($object) {
        return $object.getStepForKey("result").setPlan();
      }
    }
  },
  PostStatusPatch: {
    "__inputPlan": function PostStatusPatch_inputPlan() {
      return object(Object.create(null));
    },
    rowId: {
      applyPlan($insert, val) {
        $insert.set("id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    status: {
      applyPlan($insert, val) {
        $insert.set("status", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    description: {
      applyPlan($insert, val) {
        $insert.set("description", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    color: {
      applyPlan($insert, val) {
        $insert.set("color", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    projectId: {
      applyPlan($insert, val) {
        $insert.set("project_id", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    isDefault: {
      applyPlan($insert, val) {
        $insert.set("is_default", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    createdAt: {
      applyPlan($insert, val) {
        $insert.set("created_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    },
    updatedAt: {
      applyPlan($insert, val) {
        $insert.set("updated_at", val.get());
      },
      autoApplyAfterParentInputPlan: true,
      autoApplyAfterParentApplyPlan: true
    }
  },
  DeleteDownvotePayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    downvote($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    downvoteEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = downvoteUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_downvotePgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("DownvoteOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteDownvoteInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined
  },
  DeleteUpvotePayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    upvote($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    upvoteEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = upvoteUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_upvotePgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("UpvoteOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteUpvoteInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined
  },
  DeleteInvitationPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    invitation($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    invitationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = invitationUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_invitationPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("InvitationOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteInvitationInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined
  },
  DeleteOrganizationPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    organization($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    organizationEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = organizationUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_organizationPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("OrganizationOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteOrganizationInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined
  },
  DeleteCommentPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    comment($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    commentEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = commentUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_commentPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("CommentOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteCommentInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined
  },
  DeleteProjectPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    project($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    projectEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = projectUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_projectPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("ProjectOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteProjectInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined
  },
  DeleteUserPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    user($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    userEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = userUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_userPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("UserOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteUserInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined
  },
  DeleteMemberPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    member($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    memberEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = memberUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_memberPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("MemberOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeleteMemberInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined
  },
  DeletePostPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    post($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    postEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = postUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_postPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeletePostInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined
  },
  DeletePostStatusPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("clientMutationId", !0) ?? constant(null);
    },
    postStatus($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    postStatusEdge: {
      plan($mutation, args, info) {
        const $result = $mutation.getStepForKey("result", !0);
        if (!$result) return constant(null);
        const $select = (() => {
            if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
              const spec = post_statusUniques[0].attributes.reduce((memo, attributeName) => {
                memo[attributeName] = $result.get(attributeName);
                return memo;
              }, Object.create(null));
              return resource_post_statusPgResource.find(spec);
            }
          })(),
          $value = args.getRaw("orderBy");
        applyOrderToPlan($select, $value, info.schema.getType("PostStatusOrderBy"));
        const $connection = connection($select),
          $single = $select.row(first($select));
        return new EdgeStep($connection, $single);
      },
      args: {
        orderBy: undefined
      }
    }
  },
  DeletePostStatusInput: {
    clientMutationId: {
      applyPlan($input, val) {
        $input.set("clientMutationId", val.get());
      }
    },
    rowId: undefined
  }
};
export const schema = makeGrafastSchema({
  typeDefs: typeDefs,
  plans: plans
});