// @ts-nocheck
import { PgBooleanFilter, PgCondition, PgDeleteSingleStep, PgExecutor, PgOrFilter, TYPES, assertPgClassSingleStep, enumCodec, listOfCodec, makeRegistry, pgDeleteSingle, pgInsertSingle, pgSelectFromRecord, pgUpdateSingle, pgWhereConditionSpecListToSQL, recordCodec, sqlValueWithCodec } from "@dataplan/pg";
import { and, count, eq } from "drizzle-orm";
import { ConnectionStep, EdgeStep, ExecutableStep, Modifier, ObjectStep, __ValueStep, assertEdgeCapableStep, assertExecutableStep, assertPageInfoCapableStep, bakedInputRuntime, connection, constant, context, createObjectAndApplyChildren, first, isExecutableStep, lambda, makeGrafastSchema, node, object, rootValue, sideEffect } from "grafast";
import { GraphQLError, Kind } from "graphql";
import * as lib_drizzle_schema from "lib/drizzle/schema";
import { sql } from "pg-sql2";
import { inspect } from "util";
const handler = {
  typeName: "Query",
  codec: {
    name: "raw",
    encode: Object.assign(function rawEncode(value) {
      return typeof value === "string" ? value : null;
    }, {
      isSyncAndSafe: true
    }),
    decode: Object.assign(function rawDecode(value) {
      return typeof value === "string" ? value : null;
    }, {
      isSyncAndSafe: true
    })
  },
  match(specifier) {
    return specifier === "query";
  },
  getIdentifiers(_value) {
    return [];
  },
  getSpec() {
    return "irrelevant";
  },
  get() {
    return rootValue();
  },
  plan() {
    return constant`query`;
  }
};
const nodeIdCodecs = {
  __proto__: null,
  raw: handler.codec,
  base64JSON: {
    name: "base64JSON",
    encode: (() => {
      function base64JSONEncode(value) {
        return Buffer.from(JSON.stringify(value), "utf8").toString("base64");
      }
      base64JSONEncode.isSyncAndSafe = !0;
      return base64JSONEncode;
    })(),
    decode: (() => {
      function base64JSONDecode(value) {
        return JSON.parse(Buffer.from(value, "base64").toString("utf8"));
      }
      base64JSONDecode.isSyncAndSafe = !0;
      return base64JSONDecode;
    })()
  },
  pipeString: {
    name: "pipeString",
    encode: Object.assign(function pipeStringEncode(value) {
      return Array.isArray(value) ? value.join("|") : null;
    }, {
      isSyncAndSafe: true
    }),
    decode: Object.assign(function pipeStringDecode(value) {
      return typeof value === "string" ? value.split("|") : null;
    }, {
      isSyncAndSafe: true
    })
  }
};
const nodeIdHandlerByTypeName = {
  __proto__: null,
  Query: handler
};
const executor = new PgExecutor({
  name: "main",
  context() {
    const ctx = context();
    return object({
      pgSettings: "pgSettings" != null ? ctx.get("pgSettings") : constant(null),
      withPgClient: ctx.get("withPgClient")
    });
  }
});
const downvoteIdentifier = sql.identifier("public", "downvote");
const spec_downvote = {
  name: "downvote",
  identifier: downvoteIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    post_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "230322",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "downvote"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const downvoteCodec = recordCodec(spec_downvote);
const upvoteIdentifier = sql.identifier("public", "upvote");
const spec_upvote = {
  name: "upvote",
  identifier: upvoteIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    post_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "230235",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "upvote"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const upvoteCodec = recordCodec(spec_upvote);
const invitationIdentifier = sql.identifier("public", "invitation");
const spec_invitation = {
  name: "invitation",
  identifier: invitationIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    email: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "230421",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "invitation"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const invitationCodec = recordCodec(spec_invitation);
const organizationIdentifier = sql.identifier("public", "organization");
const spec_organization = {
  name: "organization",
  identifier: organizationIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    name: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    slug: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "230197",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "organization"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const organizationCodec = recordCodec(spec_organization);
const commentIdentifier = sql.identifier("public", "comment");
const spec_comment = {
  name: "comment",
  identifier: commentIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    message: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    post_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    parent_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "230302",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "comment"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const commentCodec = recordCodec(spec_comment);
const projectIdentifier = sql.identifier("public", "project");
const spec_project = {
  name: "project",
  identifier: projectIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    name: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    image: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    slug: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "230221",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "project"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const projectCodec = recordCodec(spec_project);
const memberIdentifier = sql.identifier("public", "member");
const roleCodec = enumCodec({
  name: "role",
  identifier: sql.identifier("public", "role"),
  values: ["owner", "admin", "member"],
  description: undefined,
  extensions: {
    oid: "230341",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "role"
    },
    tags: {
      __proto__: null
    }
  }
});
const spec_member = {
  name: "member",
  identifier: memberIdentifier,
  attributes: {
    __proto__: null,
    user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    organization_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    role: {
      description: undefined,
      codec: roleCodec,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "230257",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "member"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const memberCodec = recordCodec(spec_member);
const postIdentifier = sql.identifier("public", "post");
const spec_post = {
  name: "post",
  identifier: postIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    title: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    project_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    user_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    status_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    status_updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "230211",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "post"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const postCodec = recordCodec(spec_post);
const postStatusIdentifier = sql.identifier("public", "post_status");
const spec_postStatus = {
  name: "postStatus",
  identifier: postStatusIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    status: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    description: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    color: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    project_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    is_default: {
      description: undefined,
      codec: TYPES.boolean,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "230395",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "post_status"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const postStatusCodec = recordCodec(spec_postStatus);
const userIdentifier = sql.identifier("public", "user");
const tierCodec = enumCodec({
  name: "tier",
  identifier: sql.identifier("public", "tier"),
  values: ["free", "basic", "team", "enterprise"],
  description: undefined,
  extensions: {
    oid: "230444",
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "tier"
    },
    tags: {
      __proto__: null
    }
  }
});
const spec_user = {
  name: "user",
  identifier: userIdentifier,
  attributes: {
    __proto__: null,
    id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    created_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    updated_at: {
      description: undefined,
      codec: TYPES.timestamptz,
      notNull: false,
      hasDefault: true,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    hidra_id: {
      description: undefined,
      codec: TYPES.uuid,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    username: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    first_name: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    last_name: {
      description: undefined,
      codec: TYPES.text,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    email: {
      description: undefined,
      codec: TYPES.text,
      notNull: true,
      hasDefault: false,
      extensions: {
        tags: {},
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    },
    tier: {
      description: undefined,
      codec: tierCodec,
      notNull: false,
      hasDefault: false,
      extensions: {
        tags: {
          behavior: "-insert -update"
        },
        canSelect: true,
        canInsert: true,
        canUpdate: true
      }
    }
  },
  description: undefined,
  extensions: {
    oid: "230245",
    isTableLike: true,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "user"
    },
    tags: {
      __proto__: null
    }
  },
  executor: executor
};
const userCodec = recordCodec(spec_user);
const downvoteUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}, {
  isPrimary: false,
  attributes: ["post_id", "user_id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null,
      behavior: ["-update", "-delete"]
    }
  }
}];
const registryConfig_pgResources_downvote_downvote = {
  executor: executor,
  name: "downvote",
  identifier: "main.public.downvote",
  from: downvoteIdentifier,
  codec: downvoteCodec,
  uniques: downvoteUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "downvote"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const upvoteUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}, {
  isPrimary: false,
  attributes: ["post_id", "user_id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null,
      behavior: ["-update", "-delete"]
    }
  }
}];
const registryConfig_pgResources_upvote_upvote = {
  executor: executor,
  name: "upvote",
  identifier: "main.public.upvote",
  from: upvoteIdentifier,
  codec: upvoteCodec,
  uniques: upvoteUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "upvote"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const invitationUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}, {
  isPrimary: false,
  attributes: ["organization_id", "email"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null,
      behavior: ["-update", "-delete"]
    }
  }
}];
const registryConfig_pgResources_invitation_invitation = {
  executor: executor,
  name: "invitation",
  identifier: "main.public.invitation",
  from: invitationIdentifier,
  codec: invitationCodec,
  uniques: invitationUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "invitation"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const organizationUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}, {
  isPrimary: false,
  attributes: ["name"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null,
      behavior: ["-update", "-delete"]
    }
  }
}, {
  isPrimary: false,
  attributes: ["slug"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null,
      behavior: ["-update", "-delete"]
    }
  }
}];
const registryConfig_pgResources_organization_organization = {
  executor: executor,
  name: "organization",
  identifier: "main.public.organization",
  from: organizationIdentifier,
  codec: organizationCodec,
  uniques: organizationUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "organization"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const commentUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_comment_comment = {
  executor: executor,
  name: "comment",
  identifier: "main.public.comment",
  from: commentIdentifier,
  codec: commentCodec,
  uniques: commentUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "comment"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const projectUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}, {
  isPrimary: false,
  attributes: ["slug", "organization_id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null,
      behavior: ["-update", "-delete"]
    }
  }
}];
const registryConfig_pgResources_project_project = {
  executor: executor,
  name: "project",
  identifier: "main.public.project",
  from: projectIdentifier,
  codec: projectCodec,
  uniques: projectUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "project"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const memberUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}, {
  isPrimary: false,
  attributes: ["user_id", "organization_id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null,
      behavior: ["-update", "-delete"]
    }
  }
}];
const registryConfig_pgResources_member_member = {
  executor: executor,
  name: "member",
  identifier: "main.public.member",
  from: memberIdentifier,
  codec: memberCodec,
  uniques: memberUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "member"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const postUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_post_post = {
  executor: executor,
  name: "post",
  identifier: "main.public.post",
  from: postIdentifier,
  codec: postCodec,
  uniques: postUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "post"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const post_statusUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}];
const registryConfig_pgResources_post_status_post_status = {
  executor: executor,
  name: "post_status",
  identifier: "main.public.post_status",
  from: postStatusIdentifier,
  codec: postStatusCodec,
  uniques: post_statusUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "post_status"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const userUniques = [{
  isPrimary: true,
  attributes: ["id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null
    }
  }
}, {
  isPrimary: false,
  attributes: ["email"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null,
      behavior: ["-update", "-delete"]
    }
  }
}, {
  isPrimary: false,
  attributes: ["hidra_id"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null,
      behavior: ["-update", "-delete"]
    }
  }
}, {
  isPrimary: false,
  attributes: ["username"],
  description: undefined,
  extensions: {
    tags: {
      __proto__: null,
      behavior: ["-update", "-delete"]
    }
  }
}];
const registryConfig_pgResources_user_user = {
  executor: executor,
  name: "user",
  identifier: "main.public.user",
  from: userIdentifier,
  codec: userCodec,
  uniques: userUniques,
  isVirtual: false,
  description: undefined,
  extensions: {
    description: undefined,
    pg: {
      serviceName: "main",
      schemaName: "public",
      name: "user"
    },
    isInsertable: true,
    isUpdatable: true,
    isDeletable: true,
    tags: {},
    canSelect: true,
    canInsert: true,
    canUpdate: true,
    canDelete: true
  }
};
const registryConfig = {
  pgExecutors: {
    __proto__: null,
    main: executor
  },
  pgCodecs: {
    __proto__: null,
    downvote: downvoteCodec,
    uuid: TYPES.uuid,
    timestamptz: TYPES.timestamptz,
    upvote: upvoteCodec,
    invitation: invitationCodec,
    text: TYPES.text,
    organization: organizationCodec,
    comment: commentCodec,
    project: projectCodec,
    member: memberCodec,
    role: roleCodec,
    post: postCodec,
    postStatus: postStatusCodec,
    bool: TYPES.boolean,
    user: userCodec,
    tier: tierCodec
  },
  pgResources: {
    __proto__: null,
    downvote: registryConfig_pgResources_downvote_downvote,
    upvote: registryConfig_pgResources_upvote_upvote,
    invitation: registryConfig_pgResources_invitation_invitation,
    organization: registryConfig_pgResources_organization_organization,
    comment: registryConfig_pgResources_comment_comment,
    project: registryConfig_pgResources_project_project,
    member: registryConfig_pgResources_member_member,
    post: registryConfig_pgResources_post_post,
    post_status: registryConfig_pgResources_post_status_post_status,
    user: registryConfig_pgResources_user_user
  },
  pgRelations: {
    __proto__: null,
    comment: {
      __proto__: null,
      commentByMyParentId: {
        localCodec: commentCodec,
        remoteResourceOptions: registryConfig_pgResources_comment_comment,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["parent_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      postByMyPostId: {
        localCodec: commentCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["post_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyUserId: {
        localCodec: commentCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      commentsByTheirParentId: {
        localCodec: commentCodec,
        remoteResourceOptions: registryConfig_pgResources_comment_comment,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["parent_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    downvote: {
      __proto__: null,
      postByMyPostId: {
        localCodec: downvoteCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["post_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyUserId: {
        localCodec: downvoteCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    invitation: {
      __proto__: null,
      organizationByMyOrganizationId: {
        localCodec: invitationCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    member: {
      __proto__: null,
      organizationByMyOrganizationId: {
        localCodec: memberCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyUserId: {
        localCodec: memberCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    organization: {
      __proto__: null,
      projectsByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_project_project,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      membersByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_member_member,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      invitationsByTheirOrganizationId: {
        localCodec: organizationCodec,
        remoteResourceOptions: registryConfig_pgResources_invitation_invitation,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["organization_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    post: {
      __proto__: null,
      projectByMyProjectId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_project_project,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["project_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      postStatusByMyStatusId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_post_status_post_status,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["status_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyUserId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      upvotesByTheirPostId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_upvote_upvote,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["post_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      commentsByTheirPostId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_comment_comment,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["post_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      downvotesByTheirPostId: {
        localCodec: postCodec,
        remoteResourceOptions: registryConfig_pgResources_downvote_downvote,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["post_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    postStatus: {
      __proto__: null,
      projectByMyProjectId: {
        localCodec: postStatusCodec,
        remoteResourceOptions: registryConfig_pgResources_project_project,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["project_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      postsByTheirStatusId: {
        localCodec: postStatusCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["status_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    project: {
      __proto__: null,
      organizationByMyOrganizationId: {
        localCodec: projectCodec,
        remoteResourceOptions: registryConfig_pgResources_organization_organization,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["organization_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      postsByTheirProjectId: {
        localCodec: projectCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["project_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      postStatusesByTheirProjectId: {
        localCodec: projectCodec,
        remoteResourceOptions: registryConfig_pgResources_post_status_post_status,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["project_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    upvote: {
      __proto__: null,
      postByMyPostId: {
        localCodec: upvoteCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["post_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      userByMyUserId: {
        localCodec: upvoteCodec,
        remoteResourceOptions: registryConfig_pgResources_user_user,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["user_id"],
        remoteAttributes: ["id"],
        isUnique: true,
        isReferencee: false,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    },
    user: {
      __proto__: null,
      postsByTheirUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_post_post,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      upvotesByTheirUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_upvote_upvote,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      membersByTheirUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_member_member,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      commentsByTheirUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_comment_comment,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      },
      downvotesByTheirUserId: {
        localCodec: userCodec,
        remoteResourceOptions: registryConfig_pgResources_downvote_downvote,
        localCodecPolymorphicTypes: undefined,
        localAttributes: ["id"],
        remoteAttributes: ["user_id"],
        isUnique: false,
        isReferencee: true,
        description: undefined,
        extensions: {
          tags: {
            behavior: []
          }
        }
      }
    }
  }
};
const registry = makeRegistry(registryConfig);
const resource_downvotePgResource = registry.pgResources["downvote"];
const resource_upvotePgResource = registry.pgResources["upvote"];
const resource_invitationPgResource = registry.pgResources["invitation"];
const resource_organizationPgResource = registry.pgResources["organization"];
const resource_commentPgResource = registry.pgResources["comment"];
const resource_projectPgResource = registry.pgResources["project"];
const resource_memberPgResource = registry.pgResources["member"];
const resource_postPgResource = registry.pgResources["post"];
const resource_post_statusPgResource = registry.pgResources["post_status"];
const resource_userPgResource = registry.pgResources["user"];
function qbWhereBuilder(qb) {
  return qb.whereBuilder();
}
function isEmpty(o) {
  return typeof o === "object" && o !== null && Object.keys(o).length === 0;
}
function assertAllowed(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed2(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed3(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed4(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed5(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed6(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed7(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed8(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed9(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed10(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function UUIDSerialize(value) {
  return "" + value;
}
const coerce = string => {
  if (!/^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$/i.test(string)) throw new GraphQLError("Invalid UUID, expected 32 hexadecimal characters, optionally with hypens");
  return string;
};
function assertAllowed11(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed12(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed13(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed14(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed15(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed16(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed17(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed18(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const dataTypeToAggregateTypeMap = {};
const spec = {
  id: "distinctCount",
  humanLabel: "distinct count",
  HumanLabel: "Distinct count",
  isSuitableType() {
    return !0;
  },
  sqlAggregateWrap(sqlFrag) {
    return sql`count(distinct ${sqlFrag})`;
  },
  pgTypeCodecModifier(codec) {
    const oid = codec.extensions?.oid;
    return (oid ? dataTypeToAggregateTypeMap[oid] : null) ?? TYPES.bigint;
  }
};
const aggregateGroupBySpec = {
  id: "truncated-to-hour",
  isSuitableType(codec) {
    return codec === TYPES.timestamp || codec === TYPES.timestamptz;
  },
  sqlWrap(sqlFrag) {
    return sql`date_trunc('hour', ${sqlFrag})`;
  },
  sqlWrapCodec(codec) {
    return codec;
  }
};
const aggregateGroupBySpec2 = {
  id: "truncated-to-day",
  isSuitableType(codec) {
    return codec === TYPES.timestamp || codec === TYPES.timestamptz;
  },
  sqlWrap(sqlFrag) {
    return sql`date_trunc('day', ${sqlFrag})`;
  },
  sqlWrapCodec(codec) {
    return codec;
  }
};
const isIntervalLike = codec => !!codec.extensions?.isIntervalLike;
const isNumberLike = codec => !!codec.extensions?.isNumberLike;
const aggregateSpec_isSuitableType = codec => isIntervalLike(codec) || isNumberLike(codec);
const dataTypeToAggregateTypeMap2 = {
  "20": TYPES.numeric,
  "21": TYPES.bigint,
  "23": TYPES.bigint,
  "700": TYPES.float4,
  "701": TYPES.float,
  "790": TYPES.money,
  "1186": TYPES.interval
};
const aggregateSpec = {
  id: "sum",
  humanLabel: "sum",
  HumanLabel: "Sum",
  isSuitableType: aggregateSpec_isSuitableType,
  sqlAggregateWrap(sqlFrag) {
    return sql`coalesce(sum(${sqlFrag}), '0')`;
  },
  isNonNull: true,
  pgTypeCodecModifier(codec) {
    const oid = codec.extensions?.oid;
    return (oid ? dataTypeToAggregateTypeMap2[oid] : null) ?? TYPES.numeric;
  }
};
const infix = () => sql.fragment`=`;
const infix2 = () => sql.fragment`<>`;
const infix3 = () => sql.fragment`>`;
const infix4 = () => sql.fragment`>=`;
const infix5 = () => sql.fragment`<`;
const infix6 = () => sql.fragment`<=`;
const aggregateSpec2 = {
  id: "min",
  humanLabel: "minimum",
  HumanLabel: "Minimum",
  isSuitableType: aggregateSpec_isSuitableType,
  sqlAggregateWrap(sqlFrag) {
    return sql`min(${sqlFrag})`;
  }
};
const aggregateSpec3 = {
  id: "max",
  humanLabel: "maximum",
  HumanLabel: "Maximum",
  isSuitableType: aggregateSpec_isSuitableType,
  sqlAggregateWrap(sqlFrag) {
    return sql`max(${sqlFrag})`;
  }
};
const dataTypeToAggregateTypeMap3 = {
  "20": TYPES.numeric,
  "21": TYPES.numeric,
  "23": TYPES.numeric,
  "700": TYPES.float,
  "701": TYPES.float,
  "1186": TYPES.interval,
  "1700": TYPES.numeric
};
const aggregateSpec4 = {
  id: "average",
  humanLabel: "mean average",
  HumanLabel: "Mean average",
  isSuitableType: aggregateSpec_isSuitableType,
  sqlAggregateWrap(sqlFrag) {
    return sql`avg(${sqlFrag})`;
  },
  pgTypeCodecModifier(codec) {
    const oid = codec.extensions?.oid;
    return (oid ? dataTypeToAggregateTypeMap3[oid] : null) ?? TYPES.numeric;
  }
};
const dataTypeToAggregateTypeMap4 = {
  "700": TYPES.float,
  "701": TYPES.float
};
const aggregateSpec5 = {
  id: "stddevSample",
  humanLabel: "sample standard deviation",
  HumanLabel: "Sample standard deviation",
  isSuitableType: isNumberLike,
  sqlAggregateWrap(sqlFrag) {
    return sql`stddev_samp(${sqlFrag})`;
  },
  pgTypeCodecModifier(codec) {
    const oid = codec.extensions?.oid;
    return (oid ? dataTypeToAggregateTypeMap4[oid] : null) ?? TYPES.numeric;
  }
};
const dataTypeToAggregateTypeMap5 = {
  "700": TYPES.float,
  "701": TYPES.float
};
const aggregateSpec6 = {
  id: "stddevPopulation",
  humanLabel: "population standard deviation",
  HumanLabel: "Population standard deviation",
  isSuitableType: isNumberLike,
  sqlAggregateWrap(sqlFrag) {
    return sql`stddev_pop(${sqlFrag})`;
  },
  pgTypeCodecModifier(codec) {
    const oid = codec.extensions?.oid;
    return (oid ? dataTypeToAggregateTypeMap5[oid] : null) ?? TYPES.numeric;
  }
};
const dataTypeToAggregateTypeMap6 = {
  "700": TYPES.float,
  "701": TYPES.float
};
const aggregateSpec7 = {
  id: "varianceSample",
  humanLabel: "sample variance",
  HumanLabel: "Sample variance",
  isSuitableType: isNumberLike,
  sqlAggregateWrap(sqlFrag) {
    return sql`var_samp(${sqlFrag})`;
  },
  pgTypeCodecModifier(codec) {
    const oid = codec.extensions?.oid;
    return (oid ? dataTypeToAggregateTypeMap6[oid] : null) ?? TYPES.numeric;
  }
};
const dataTypeToAggregateTypeMap7 = {
  "700": TYPES.float,
  "701": TYPES.float
};
const aggregateSpec8 = {
  id: "variancePopulation",
  humanLabel: "population variance",
  HumanLabel: "Population variance",
  isSuitableType: isNumberLike,
  sqlAggregateWrap(sqlFrag) {
    return sql`var_pop(${sqlFrag})`;
  },
  pgTypeCodecModifier(codec) {
    const oid = codec.extensions?.oid;
    return (oid ? dataTypeToAggregateTypeMap7[oid] : null) ?? TYPES.numeric;
  }
};
const colSpec = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_project.attributes.id
};
const colSpec2 = {
  fieldName: "name",
  attributeName: "name",
  attribute: spec_project.attributes.name
};
const colSpec3 = {
  fieldName: "image",
  attributeName: "image",
  attribute: spec_project.attributes.image
};
const colSpec4 = {
  fieldName: "slug",
  attributeName: "slug",
  attribute: spec_project.attributes.slug
};
const colSpec5 = {
  fieldName: "description",
  attributeName: "description",
  attribute: spec_project.attributes.description
};
const colSpec6 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_project.attributes.organization_id
};
const colSpec7 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_project.attributes.created_at
};
const colSpec8 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_project.attributes.updated_at
};
function assertAllowed19(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed20(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed21(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const resolve = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec = () => TYPES.boolean;
const resolveSqlValue = () => sql.null;
const resolve2 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec2(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive.includes(resolveDomains(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive.includes(resolveDomains(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive.includes(resolveDomains(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive.includes(resolveDomains(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve3 = (i, v) => sql`${i} <> ${v}`;
const resolve4 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve5 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve6 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec3(c) {
  if (forceTextTypesSensitive.includes(resolveDomains(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve7 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve8 = (i, v) => sql`${i} < ${v}`;
const resolve9 = (i, v) => sql`${i} <= ${v}`;
const resolve10 = (i, v) => sql`${i} > ${v}`;
const resolve11 = (i, v) => sql`${i} >= ${v}`;
const resolve12 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec4 = () => TYPES.boolean;
const resolveSqlValue2 = () => sql.null;
const resolve13 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive2 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains2(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec5(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive2.includes(resolveDomains2(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive2.includes(resolveDomains2(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier2(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive2.includes(resolveDomains2(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive2.includes(resolveDomains2(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve14 = (i, v) => sql`${i} <> ${v}`;
const resolve15 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve16 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve17 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec6(c) {
  if (forceTextTypesSensitive2.includes(resolveDomains2(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve18 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve19 = (i, v) => sql`${i} < ${v}`;
const resolve20 = (i, v) => sql`${i} <= ${v}`;
const resolve21 = (i, v) => sql`${i} > ${v}`;
const resolve22 = (i, v) => sql`${i} >= ${v}`;
const resolve23 = (i, v) => sql`${i} LIKE ${v}`;
function escapeLikeWildcards(input) {
  if (typeof input !== "string") throw new Error("Non-string input was provided to escapeLikeWildcards");else return input.split("%").join("\\%").split("_").join("\\_");
}
const resolveInput = input => `%${escapeLikeWildcards(input)}%`;
const resolve24 = (i, v) => sql`${i} NOT LIKE ${v}`;
const resolveInput2 = input => `%${escapeLikeWildcards(input)}%`;
const resolve25 = (i, v) => sql`${i} ILIKE ${v}`;
const resolveInput3 = input => `%${escapeLikeWildcards(input)}%`;
const forceTextTypesInsensitive = [TYPES.char, TYPES.bpchar];
function resolveInputCodec7(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesInsensitive.includes(resolveDomains2(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesInsensitive.includes(resolveDomains2(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier3(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesInsensitive.includes(resolveDomains2(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesInsensitive.includes(resolveDomains2(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve26 = (i, v) => sql`${i} NOT ILIKE ${v}`;
const resolveInput4 = input => `%${escapeLikeWildcards(input)}%`;
const resolve27 = (i, v) => sql`${i} LIKE ${v}`;
const resolveInput5 = input => `${escapeLikeWildcards(input)}%`;
const resolve28 = (i, v) => sql`${i} NOT LIKE ${v}`;
const resolveInput6 = input => `${escapeLikeWildcards(input)}%`;
const resolve29 = (i, v) => sql`${i} ILIKE ${v}`;
const resolveInput7 = input => `${escapeLikeWildcards(input)}%`;
const resolve30 = (i, v) => sql`${i} NOT ILIKE ${v}`;
const resolveInput8 = input => `${escapeLikeWildcards(input)}%`;
const resolve31 = (i, v) => sql`${i} LIKE ${v}`;
const resolveInput9 = input => `%${escapeLikeWildcards(input)}`;
const resolve32 = (i, v) => sql`${i} NOT LIKE ${v}`;
const resolveInput10 = input => `%${escapeLikeWildcards(input)}`;
const resolve33 = (i, v) => sql`${i} ILIKE ${v}`;
const resolveInput11 = input => `%${escapeLikeWildcards(input)}`;
const resolve34 = (i, v) => sql`${i} NOT ILIKE ${v}`;
const resolveInput12 = input => `%${escapeLikeWildcards(input)}`;
const resolve35 = (i, v) => sql`${i} LIKE ${v}`;
const resolve36 = (i, v) => sql`${i} NOT LIKE ${v}`;
const resolve37 = (i, v) => sql`${i} ILIKE ${v}`;
const resolve38 = (i, v) => sql`${i} NOT ILIKE ${v}`;
function resolveInputCodec8(inputCodec) {
  if ("equalTo" === "in" || "equalTo" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier4(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue3(_unused, input, inputCodec) {
  if ("equalTo" === "in" || "equalTo" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec9(inputCodec) {
  if ("notEqualTo" === "in" || "notEqualTo" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier5(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue4(_unused, input, inputCodec) {
  if ("notEqualTo" === "in" || "notEqualTo" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec10(inputCodec) {
  if ("distinctFrom" === "in" || "distinctFrom" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier6(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue5(_unused, input, inputCodec) {
  if ("distinctFrom" === "in" || "distinctFrom" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec11(inputCodec) {
  if ("notDistinctFrom" === "in" || "notDistinctFrom" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier7(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue6(_unused, input, inputCodec) {
  if ("notDistinctFrom" === "in" || "notDistinctFrom" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec12(inputCodec) {
  if ("in" === "in" || "in" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier8(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue7(_unused, input, inputCodec) {
  if ("in" === "in" || "in" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec13(inputCodec) {
  if ("notIn" === "in" || "notIn" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier9(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue8(_unused, input, inputCodec) {
  if ("notIn" === "in" || "notIn" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec14(inputCodec) {
  if ("lessThan" === "in" || "lessThan" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier10(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue9(_unused, input, inputCodec) {
  if ("lessThan" === "in" || "lessThan" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec15(inputCodec) {
  if ("lessThanOrEqualTo" === "in" || "lessThanOrEqualTo" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier11(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue10(_unused, input, inputCodec) {
  if ("lessThanOrEqualTo" === "in" || "lessThanOrEqualTo" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec16(inputCodec) {
  if ("greaterThan" === "in" || "greaterThan" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier12(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue11(_unused, input, inputCodec) {
  if ("greaterThan" === "in" || "greaterThan" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
function resolveInputCodec17(inputCodec) {
  if ("greaterThanOrEqualTo" === "in" || "greaterThanOrEqualTo" === "notIn") {
    const t = resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
    return listOfCodec(t, {
      extensions: {
        listItemNonNull: !0
      }
    });
  } else return resolveDomains2(inputCodec) === TYPES.citext ? inputCodec : TYPES.text;
}
function resolveSqlIdentifier13(sourceAlias, codec) {
  return resolveDomains2(codec) === TYPES.citext ? [sourceAlias, codec] : [sql`lower(${sourceAlias}::text)`, TYPES.text];
}
function resolveSqlValue12(_unused, input, inputCodec) {
  if ("greaterThanOrEqualTo" === "in" || "greaterThanOrEqualTo" === "notIn") {
    const sqlList = sqlValueWithCodec(input, inputCodec);
    if (inputCodec.arrayOfCodec === TYPES.citext) return sqlList;else return sql`(select lower(t) from unnest(${sqlList}) t)`;
  } else {
    const sqlValue = sqlValueWithCodec(input, inputCodec);
    if (inputCodec === TYPES.citext) return sqlValue;else return sql`lower(${sqlValue})`;
  }
}
const resolve39 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec18 = () => TYPES.boolean;
const resolveSqlValue13 = () => sql.null;
const resolve40 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive3 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains3(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec19(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive3.includes(resolveDomains3(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive3.includes(resolveDomains3(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier14(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive3.includes(resolveDomains3(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive3.includes(resolveDomains3(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve41 = (i, v) => sql`${i} <> ${v}`;
const resolve42 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve43 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve44 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec20(c) {
  if (forceTextTypesSensitive3.includes(resolveDomains3(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve45 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve46 = (i, v) => sql`${i} < ${v}`;
const resolve47 = (i, v) => sql`${i} <= ${v}`;
const resolve48 = (i, v) => sql`${i} > ${v}`;
const resolve49 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed22(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const PgAggregateConditionExpression = class PgAggregateConditionExpression extends Modifier {
  spec;
  pgWhereConditionSpecListToSQL;
  alias;
  conditions = [];
  constructor(parent, spec, pgWhereConditionSpecListToSQL) {
    super(parent);
    this.spec = spec;
    this.pgWhereConditionSpecListToSQL = pgWhereConditionSpecListToSQL;
    this.alias = parent.alias;
  }
  where(condition) {
    this.conditions.push(condition);
  }
  apply() {
    const sqlCondition = this.pgWhereConditionSpecListToSQL(this.alias, this.conditions);
    if (sqlCondition) this.parent.expression(sqlCondition);
  }
};
const PgAggregateCondition = class PgAggregateCondition extends Modifier {
  pgWhereConditionSpecListToSQL;
  sql;
  tableExpression;
  alias;
  conditions = [];
  expressions = [];
  constructor(parent, options, pgWhereConditionSpecListToSQL) {
    super(parent);
    this.pgWhereConditionSpecListToSQL = pgWhereConditionSpecListToSQL;
    const {
      sql,
      tableExpression,
      alias
    } = options;
    this.sql = sql;
    this.alias = sql.identifier(Symbol(alias ?? "aggregate"));
    this.tableExpression = tableExpression;
  }
  where(condition) {
    this.conditions.push(condition);
  }
  expression(expression) {
    this.expressions.push(expression);
  }
  forAggregate(spec) {
    return new PgAggregateConditionExpression(this, spec, this.pgWhereConditionSpecListToSQL);
  }
  apply() {
    const {
        sql
      } = this,
      sqlCondition = this.pgWhereConditionSpecListToSQL(this.alias, this.conditions),
      where = sqlCondition ? sql`where ${sqlCondition}` : sql.blank,
      boolExpr = this.expressions.length === 0 ? sql.true : sql.parens(sql.join(this.expressions.map(expr => sql.parens(expr)), `
and
`)),
      subquery = sql`(${sql.indent`\
select ${boolExpr}
from ${this.tableExpression} as ${this.alias}
${where}`}
group by ())`;
    return this.parent.where(subquery);
  }
};
const colSpec9 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_post.attributes.id
};
const colSpec10 = {
  fieldName: "title",
  attributeName: "title",
  attribute: spec_post.attributes.title
};
const colSpec11 = {
  fieldName: "description",
  attributeName: "description",
  attribute: spec_post.attributes.description
};
const colSpec12 = {
  fieldName: "projectId",
  attributeName: "project_id",
  attribute: spec_post.attributes.project_id
};
const colSpec13 = {
  fieldName: "userId",
  attributeName: "user_id",
  attribute: spec_post.attributes.user_id
};
const colSpec14 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_post.attributes.created_at
};
const colSpec15 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_post.attributes.updated_at
};
const colSpec16 = {
  fieldName: "statusId",
  attributeName: "status_id",
  attribute: spec_post.attributes.status_id
};
const colSpec17 = {
  fieldName: "statusUpdatedAt",
  attributeName: "status_updated_at",
  attribute: spec_post.attributes.status_updated_at
};
function assertAllowed23(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed24(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed25(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed26(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec18 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_upvote.attributes.id
};
const colSpec19 = {
  fieldName: "postId",
  attributeName: "post_id",
  attribute: spec_upvote.attributes.post_id
};
const colSpec20 = {
  fieldName: "userId",
  attributeName: "user_id",
  attribute: spec_upvote.attributes.user_id
};
const colSpec21 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_upvote.attributes.created_at
};
const colSpec22 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_upvote.attributes.updated_at
};
function assertAllowed27(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed28(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec23 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_user.attributes.id
};
const colSpec24 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_user.attributes.created_at
};
const colSpec25 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_user.attributes.updated_at
};
const colSpec26 = {
  fieldName: "hidraId",
  attributeName: "hidra_id",
  attribute: spec_user.attributes.hidra_id
};
const colSpec27 = {
  fieldName: "username",
  attributeName: "username",
  attribute: spec_user.attributes.username
};
const colSpec28 = {
  fieldName: "firstName",
  attributeName: "first_name",
  attribute: spec_user.attributes.first_name
};
const colSpec29 = {
  fieldName: "lastName",
  attributeName: "last_name",
  attribute: spec_user.attributes.last_name
};
const colSpec30 = {
  fieldName: "email",
  attributeName: "email",
  attribute: spec_user.attributes.email
};
const colSpec31 = {
  fieldName: "tier",
  attributeName: "tier",
  attribute: spec_user.attributes.tier
};
function assertAllowed29(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed30(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const resolve50 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec21 = () => TYPES.boolean;
const resolveSqlValue14 = () => sql.null;
const resolve51 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive4 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains4(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec22(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive4.includes(resolveDomains4(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive4.includes(resolveDomains4(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier15(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive4.includes(resolveDomains4(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive4.includes(resolveDomains4(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve52 = (i, v) => sql`${i} <> ${v}`;
const resolve53 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve54 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve55 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec23(c) {
  if (forceTextTypesSensitive4.includes(resolveDomains4(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve56 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve57 = (i, v) => sql`${i} < ${v}`;
const resolve58 = (i, v) => sql`${i} <= ${v}`;
const resolve59 = (i, v) => sql`${i} > ${v}`;
const resolve60 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed31(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const resolve61 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec24 = () => TYPES.boolean;
const resolveSqlValue15 = () => sql.null;
const resolve62 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive5 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains5(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec25(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive5.includes(resolveDomains5(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive5.includes(resolveDomains5(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier16(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive5.includes(resolveDomains5(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive5.includes(resolveDomains5(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve63 = (i, v) => sql`${i} <> ${v}`;
const resolve64 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve65 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve66 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec26(c) {
  if (forceTextTypesSensitive5.includes(resolveDomains5(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve67 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve68 = (i, v) => sql`${i} < ${v}`;
const resolve69 = (i, v) => sql`${i} <= ${v}`;
const resolve70 = (i, v) => sql`${i} > ${v}`;
const resolve71 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed32(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed33(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec32 = {
  fieldName: "userId",
  attributeName: "user_id",
  attribute: spec_member.attributes.user_id
};
const colSpec33 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_member.attributes.organization_id
};
const colSpec34 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_member.attributes.created_at
};
const colSpec35 = {
  fieldName: "role",
  attributeName: "role",
  attribute: spec_member.attributes.role
};
const colSpec36 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_member.attributes.id
};
function assertAllowed34(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed35(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const resolve72 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec27 = () => TYPES.boolean;
const resolveSqlValue16 = () => sql.null;
const resolve73 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive6 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains6(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec28(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive6.includes(resolveDomains6(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive6.includes(resolveDomains6(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier17(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive6.includes(resolveDomains6(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive6.includes(resolveDomains6(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve74 = (i, v) => sql`${i} <> ${v}`;
const resolve75 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve76 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve77 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec29(c) {
  if (forceTextTypesSensitive6.includes(resolveDomains6(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve78 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve79 = (i, v) => sql`${i} < ${v}`;
const resolve80 = (i, v) => sql`${i} <= ${v}`;
const resolve81 = (i, v) => sql`${i} > ${v}`;
const resolve82 = (i, v) => sql`${i} >= ${v}`;
const colSpec37 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_organization.attributes.id
};
const colSpec38 = {
  fieldName: "name",
  attributeName: "name",
  attribute: spec_organization.attributes.name
};
const colSpec39 = {
  fieldName: "slug",
  attributeName: "slug",
  attribute: spec_organization.attributes.slug
};
const colSpec40 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_organization.attributes.created_at
};
const colSpec41 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_organization.attributes.updated_at
};
function assertAllowed36(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed37(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed38(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed39(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed40(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec42 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_invitation.attributes.id
};
const colSpec43 = {
  fieldName: "organizationId",
  attributeName: "organization_id",
  attribute: spec_invitation.attributes.organization_id
};
const colSpec44 = {
  fieldName: "email",
  attributeName: "email",
  attribute: spec_invitation.attributes.email
};
const colSpec45 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_invitation.attributes.created_at
};
const colSpec46 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_invitation.attributes.updated_at
};
function assertAllowed41(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed42(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed43(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec47 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_comment.attributes.id
};
const colSpec48 = {
  fieldName: "message",
  attributeName: "message",
  attribute: spec_comment.attributes.message
};
const colSpec49 = {
  fieldName: "postId",
  attributeName: "post_id",
  attribute: spec_comment.attributes.post_id
};
const colSpec50 = {
  fieldName: "userId",
  attributeName: "user_id",
  attribute: spec_comment.attributes.user_id
};
const colSpec51 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_comment.attributes.created_at
};
const colSpec52 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_comment.attributes.updated_at
};
const colSpec53 = {
  fieldName: "parentId",
  attributeName: "parent_id",
  attribute: spec_comment.attributes.parent_id
};
function assertAllowed44(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed45(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed46(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed47(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed48(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec54 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_downvote.attributes.id
};
const colSpec55 = {
  fieldName: "postId",
  attributeName: "post_id",
  attribute: spec_downvote.attributes.post_id
};
const colSpec56 = {
  fieldName: "userId",
  attributeName: "user_id",
  attribute: spec_downvote.attributes.user_id
};
const colSpec57 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_downvote.attributes.created_at
};
const colSpec58 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_downvote.attributes.updated_at
};
function assertAllowed49(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed50(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed51(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed52(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const colSpec59 = {
  fieldName: "rowId",
  attributeName: "id",
  attribute: spec_postStatus.attributes.id
};
const colSpec60 = {
  fieldName: "status",
  attributeName: "status",
  attribute: spec_postStatus.attributes.status
};
const colSpec61 = {
  fieldName: "description",
  attributeName: "description",
  attribute: spec_postStatus.attributes.description
};
const colSpec62 = {
  fieldName: "color",
  attributeName: "color",
  attribute: spec_postStatus.attributes.color
};
const colSpec63 = {
  fieldName: "projectId",
  attributeName: "project_id",
  attribute: spec_postStatus.attributes.project_id
};
const colSpec64 = {
  fieldName: "isDefault",
  attributeName: "is_default",
  attribute: spec_postStatus.attributes.is_default
};
const colSpec65 = {
  fieldName: "createdAt",
  attributeName: "created_at",
  attribute: spec_postStatus.attributes.created_at
};
const colSpec66 = {
  fieldName: "updatedAt",
  attributeName: "updated_at",
  attribute: spec_postStatus.attributes.updated_at
};
function assertAllowed53(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed54(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed55(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const resolve83 = (i, _v, input) => sql`${i} ${input ? sql`IS NULL` : sql`IS NOT NULL`}`;
const resolveInputCodec30 = () => TYPES.boolean;
const resolveSqlValue17 = () => sql.null;
const resolve84 = (i, v) => sql`${i} = ${v}`;
const forceTextTypesSensitive7 = [TYPES.citext, TYPES.char, TYPES.bpchar];
function resolveDomains7(c) {
  let current = c;
  while (current.domainOfCodec) current = current.domainOfCodec;
  return current;
}
function resolveInputCodec31(c) {
  if (c.arrayOfCodec) {
    if (forceTextTypesSensitive7.includes(resolveDomains7(c.arrayOfCodec))) return listOfCodec(TYPES.text, {
      extensions: {
        listItemNonNull: c.extensions?.listItemNonNull
      }
    });
    return c;
  } else {
    if (forceTextTypesSensitive7.includes(resolveDomains7(c))) return TYPES.text;
    return c;
  }
}
function resolveSqlIdentifier18(identifier, c) {
  if (c.arrayOfCodec && forceTextTypesSensitive7.includes(resolveDomains7(c.arrayOfCodec))) return [sql`(${identifier})::text[]`, listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: c.extensions?.listItemNonNull
    }
  })];else if (forceTextTypesSensitive7.includes(resolveDomains7(c))) return [sql`(${identifier})::text`, TYPES.text];else return [identifier, c];
}
const resolve85 = (i, v) => sql`${i} <> ${v}`;
const resolve86 = (i, v) => sql`${i} IS DISTINCT FROM ${v}`;
const resolve87 = (i, v) => sql`${i} IS NOT DISTINCT FROM ${v}`;
const resolve88 = (i, v) => sql`${i} = ANY(${v})`;
function resolveInputCodec32(c) {
  if (forceTextTypesSensitive7.includes(resolveDomains7(c))) return listOfCodec(TYPES.text, {
    extensions: {
      listItemNonNull: !0
    }
  });else return listOfCodec(c, {
    extensions: {
      listItemNonNull: !0
    }
  });
}
const resolve89 = (i, v) => sql`${i} <> ALL(${v})`;
const resolve90 = (i, v) => sql`${i} < ${v}`;
const resolve91 = (i, v) => sql`${i} <= ${v}`;
const resolve92 = (i, v) => sql`${i} > ${v}`;
const resolve93 = (i, v) => sql`${i} >= ${v}`;
function assertAllowed56(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed57(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const relation = registry.pgRelations["project"]["postsByTheirProjectId"];
const relation2 = registry.pgRelations["project"]["postStatusesByTheirProjectId"];
function assertAllowed58(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed59(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed60(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed61(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
function assertAllowed62(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const relation3 = registry.pgRelations["post"]["upvotesByTheirPostId"];
const relation4 = registry.pgRelations["post"]["commentsByTheirPostId"];
const relation5 = registry.pgRelations["post"]["downvotesByTheirPostId"];
function assertAllowed63(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const relation6 = registry.pgRelations["comment"]["commentsByTheirParentId"];
function assertAllowed64(value, mode) {
  if (mode === "object" && !true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
  if (mode === "list" && !true) {
    const arr = value;
    if (arr) {
      const l = arr.length;
      for (let i = 0; i < l; i++) if (isEmpty(arr[i])) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
    }
  }
  if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
}
const relation7 = registry.pgRelations["postStatus"]["postsByTheirStatusId"];
const relation8 = registry.pgRelations["organization"]["projectsByTheirOrganizationId"];
const relation9 = registry.pgRelations["organization"]["membersByTheirOrganizationId"];
const relation10 = registry.pgRelations["organization"]["invitationsByTheirOrganizationId"];
const relation11 = registry.pgRelations["user"]["postsByTheirUserId"];
const relation12 = registry.pgRelations["user"]["upvotesByTheirUserId"];
const relation13 = registry.pgRelations["user"]["membersByTheirUserId"];
const relation14 = registry.pgRelations["user"]["commentsByTheirUserId"];
const relation15 = registry.pgRelations["user"]["downvotesByTheirUserId"];
function oldPlan(_, args) {
  const $insert = pgInsertSingle(resource_organizationPgResource, Object.create(null));
  args.apply($insert);
  return object({
    result: $insert
  });
}
const planWrapper = (plan, _, fieldArgs) => {
  const $organization = fieldArgs.getRaw(["input", "organization"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$organization, $currentUser, $db], async ([organization, currentUser, db]) => {
    if (!currentUser?.tier) throw new Error("Unauthorized");
    const {
      members
    } = lib_drizzle_schema;
    if ("create" === "create") {
      if (currentUser.tier === "basic" || currentUser.tier === "free") {
        if ((await db.select().from(members).where(and(eq(members.userId, currentUser.id), eq(members.role, "owner")))).length > 0) throw new Error("Maximum number of organizations reached.");
      }
    } else {
      const [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, organization)));
      if ("create" === "delete" && userRole.role !== "owner") throw new Error("Insufficient permissions");
      if ("create" === "update" && (!userRole || userRole.role === "member")) throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
function oldPlan2(_, args) {
  const $insert = pgInsertSingle(resource_commentPgResource, Object.create(null));
  args.apply($insert);
  return object({
    result: $insert
  });
}
const planWrapper2 = (plan, _, fieldArgs) => {
  const $comment = fieldArgs.getRaw(["input", "comment"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$comment, $currentUser, $db], async ([comment, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const MAX_FREE_TIER_COMMENTS = 100,
      {
        users,
        members,
        projects,
        posts,
        comments
      } = lib_drizzle_schema;
    if ("create" === "create") {
      const postId = comment.postId,
        [organizationOwner] = await db.select({
          tier: users.tier
        }).from(posts).innerJoin(projects, eq(posts.projectId, projects.id)).leftJoin(members, and(eq(members.organizationId, projects.organizationId), eq(members.role, "owner"))).leftJoin(users, eq(members.userId, users.id)).where(eq(posts.id, postId));
      if (!organizationOwner.tier || organizationOwner.tier === "free") {
        const [postComments] = await db.select({
          totalCount: count()
        }).from(comments).where(eq(comments.postId, postId));
        if (postComments.totalCount >= MAX_FREE_TIER_COMMENTS) throw new Error("Maximum number of comments has been reached");
      }
    } else {
      const [currentComment] = await db.select({
        organizationId: projects.organizationId,
        userId: posts.userId
      }).from(comments).innerJoin(posts, eq(comments.postId, posts.id)).innerJoin(projects, eq(posts.projectId, projects.id)).where(eq(comments.id, comment));
      if (currentUser.id !== currentComment.userId) {
        const [userRole] = await db.select({
          role: members.role
        }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, currentComment.organizationId)));
        if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
      }
    }
  });
  return plan();
};
function oldPlan3(_, args) {
  const $insert = pgInsertSingle(resource_projectPgResource, Object.create(null));
  args.apply($insert);
  return object({
    result: $insert
  });
}
const planWrapper3 = (plan, _, fieldArgs) => {
  const $project = fieldArgs.getRaw(["input", "project"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$project, $currentUser, $db], async ([project, currentUser, db]) => {
    if (!currentUser?.tier) throw new Error("Unauthorized");
    let organizationId;
    const {
      organizations,
      users,
      members,
      projects
    } = lib_drizzle_schema;
    if ("create" === "create") organizationId = project.organizationId;else {
      const [currentProject] = await db.select().from(projects).where(eq(projects.id, project));
      organizationId = currentProject.organizationId;
    }
    const [userRole] = await db.select({
      role: members.role
    }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, organizationId)));
    if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
    if ("create" === "create") {
      const [organizationOwner] = await db.select({
          tier: users.tier
        }).from(organizations).leftJoin(members, and(eq(members.organizationId, organizationId), eq(members.role, "owner"))).leftJoin(users, eq(members.userId, users.id)),
        currentProjects = await db.select().from(projects).where(eq(projects.organizationId, organizationId));
      if (!organizationOwner.tier) throw new Error("Maximum number of projects reached.");
      if (organizationOwner.tier === "free" && !!currentProjects.length) throw new Error("Maximum number of projects reached.");
      if (organizationOwner.tier === "basic" && currentProjects.length >= 3) throw new Error("Maximum number of projects reached.");
    }
  });
  return plan();
};
function oldPlan4(_, args) {
  const $insert = pgInsertSingle(resource_memberPgResource, Object.create(null));
  args.apply($insert);
  return object({
    result: $insert
  });
}
const planWrapper4 = (plan, _, fieldArgs) => {
  const $input = fieldArgs.getRaw(["input", "member"]),
    $patch = "create" === "update" ? fieldArgs.getRaw(["input", "patch"]) : $input,
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$input, $patch, $currentUser, $db], async ([input, patch, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
      members
    } = lib_drizzle_schema;
    if ("create" === "create") {
      const {
          role,
          userId,
          organizationId
        } = input,
        organizationUsers = await db.select().from(members).where(eq(members.organizationId, organizationId));
      if (organizationUsers.length) {
        const userRole = organizationUsers.find(user => user.userId === currentUser.id)?.role;
        if (!userRole) {
          if (userId !== currentUser.id || role !== "member") throw new Error("Insufficient permissions");
        } else if (userRole !== "owner") throw new Error("Insufficient permissions");
      }
    } else {
      const [member] = await db.select().from(members).where(eq(members.id, input));
      if (currentUser.id !== member.userId) {
        const [userRole] = await db.select({
          role: members.role
        }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, member.organizationId)));
        if (userRole.role !== "owner") throw new Error("Insufficient permissions");
        if (patch.role === "owner") throw new Error("Organizations can only have one owner");
      } else if ("create" === "update") throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
function oldPlan5(_, args) {
  const $insert = pgInsertSingle(resource_postPgResource, Object.create(null));
  args.apply($insert);
  return object({
    result: $insert
  });
}
const planWrapper5 = (plan, _, fieldArgs) => {
  const $post = fieldArgs.getRaw(["input", "post"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$post, $currentUser, $db], async ([post, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const MAX_FREE_TIER_FEEDBACK_UNIQUE_USERS = 15,
      {
        users,
        members,
        projects,
        posts
      } = lib_drizzle_schema;
    if ("create" === "create") {
      const projectId = post.projectId,
        [organizationOwner] = await db.select({
          tier: users.tier
        }).from(projects).leftJoin(members, and(eq(members.organizationId, projects.organizationId), eq(members.role, "owner"))).leftJoin(users, eq(members.userId, users.id)).where(eq(projects.id, projectId));
      if (!organizationOwner.tier || organizationOwner.tier === "free") {
        const [projectFeedback] = await db.select({
          totalUserCount: count(posts.userId)
        }).from(posts).where(eq(posts.projectId, projectId));
        if (projectFeedback.totalUserCount >= MAX_FREE_TIER_FEEDBACK_UNIQUE_USERS) {
          const [userFeedback] = await db.select({
            totalCount: count()
          }).from(posts).where(and(eq(posts.projectId, projectId), eq(posts.userId, currentUser.id)));
          if (!userFeedback.totalCount) throw new Error("Maximum number of unique users providing feedback has been reached");
        }
      }
    } else {
      const [currenPost] = await db.select({
        organizationId: projects.organizationId,
        userId: posts.userId
      }).from(posts).innerJoin(projects, eq(posts.projectId, projects.id)).where(eq(posts.id, post));
      if (currentUser.id !== currenPost.userId) {
        const [userRole] = await db.select({
          role: members.role
        }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, currenPost.organizationId)));
        if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
      }
    }
  });
  return plan();
};
function oldPlan6(_, args) {
  const $insert = pgInsertSingle(resource_post_statusPgResource, Object.create(null));
  args.apply($insert);
  return object({
    result: $insert
  });
}
const planWrapper6 = (plan, _, fieldArgs) => {
  const $postStatus = fieldArgs.getRaw(["input", "postStatus"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$postStatus, $currentUser, $db], async ([postStatus, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
      members,
      projects,
      postStatuses
    } = lib_drizzle_schema;
    let projectId;
    if ("create" === "create") projectId = postStatus.projectId;else {
      const [currentPostStatus] = await db.select().from(postStatuses).where(eq(postStatuses.id, postStatus));
      projectId = currentPostStatus.projectId;
    }
    const [project] = await db.select({
        organizationId: projects.organizationId
      }).from(projects).where(eq(projects.id, projectId)),
      [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, project.organizationId)));
    if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan7 = (_$root, args) => {
  const $update = pgUpdateSingle(resource_downvotePgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($update);
  return object({
    result: $update
  });
};
const planWrapper7 = (plan, _, fieldArgs) => {
  const $downvoteId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$downvoteId, $currentUser, $db], async ([downvoteId, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
        downvotes
      } = lib_drizzle_schema,
      [downvote] = await db.select().from(downvotes).where(eq(downvotes.id, downvoteId));
    if (currentUser.id !== downvote.userId) {
      console.error("Current User ID", currentUser.id);
      console.error("Downvote User ID", downvote.userId);
      console.error("Downvote Row ID", downvote.id);
      throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
const oldPlan8 = (_$root, args) => {
  const $update = pgUpdateSingle(resource_upvotePgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($update);
  return object({
    result: $update
  });
};
const planWrapper8 = (plan, _, fieldArgs) => {
  const $upvoteId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$upvoteId, $currentUser, $db], async ([upvoteId, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
        upvotes
      } = lib_drizzle_schema,
      [upvote] = await db.select().from(upvotes).where(eq(upvotes.id, upvoteId));
    if (currentUser.id !== upvote.userId) {
      console.error("Current User ID", currentUser.id);
      console.error("Upvote User ID", upvote.userId);
      console.error("Upvote Row ID", upvote.id);
      throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
const oldPlan9 = (_$root, args) => {
  const $update = pgUpdateSingle(resource_organizationPgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($update);
  return object({
    result: $update
  });
};
const planWrapper9 = (plan, _, fieldArgs) => {
  const $organization = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$organization, $currentUser, $db], async ([organization, currentUser, db]) => {
    if (!currentUser?.tier) throw new Error("Unauthorized");
    const {
      members
    } = lib_drizzle_schema;
    if ("update" === "create") {
      if (currentUser.tier === "basic" || currentUser.tier === "free") {
        if ((await db.select().from(members).where(and(eq(members.userId, currentUser.id), eq(members.role, "owner")))).length > 0) throw new Error("Maximum number of organizations reached.");
      }
    } else {
      const [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, organization)));
      if ("update" === "delete" && userRole.role !== "owner") throw new Error("Insufficient permissions");
      if ("update" === "update" && (!userRole || userRole.role === "member")) throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
const oldPlan10 = (_$root, args) => {
  const $update = pgUpdateSingle(resource_commentPgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($update);
  return object({
    result: $update
  });
};
const planWrapper10 = (plan, _, fieldArgs) => {
  const $comment = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$comment, $currentUser, $db], async ([comment, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const MAX_FREE_TIER_COMMENTS = 100,
      {
        users,
        members,
        projects,
        posts,
        comments
      } = lib_drizzle_schema;
    if ("update" === "create") {
      const postId = comment.postId,
        [organizationOwner] = await db.select({
          tier: users.tier
        }).from(posts).innerJoin(projects, eq(posts.projectId, projects.id)).leftJoin(members, and(eq(members.organizationId, projects.organizationId), eq(members.role, "owner"))).leftJoin(users, eq(members.userId, users.id)).where(eq(posts.id, postId));
      if (!organizationOwner.tier || organizationOwner.tier === "free") {
        const [postComments] = await db.select({
          totalCount: count()
        }).from(comments).where(eq(comments.postId, postId));
        if (postComments.totalCount >= MAX_FREE_TIER_COMMENTS) throw new Error("Maximum number of comments has been reached");
      }
    } else {
      const [currentComment] = await db.select({
        organizationId: projects.organizationId,
        userId: posts.userId
      }).from(comments).innerJoin(posts, eq(comments.postId, posts.id)).innerJoin(projects, eq(posts.projectId, projects.id)).where(eq(comments.id, comment));
      if (currentUser.id !== currentComment.userId) {
        const [userRole] = await db.select({
          role: members.role
        }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, currentComment.organizationId)));
        if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
      }
    }
  });
  return plan();
};
const oldPlan11 = (_$root, args) => {
  const $update = pgUpdateSingle(resource_projectPgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($update);
  return object({
    result: $update
  });
};
const planWrapper11 = (plan, _, fieldArgs) => {
  const $project = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$project, $currentUser, $db], async ([project, currentUser, db]) => {
    if (!currentUser?.tier) throw new Error("Unauthorized");
    let organizationId;
    const {
      organizations,
      users,
      members,
      projects
    } = lib_drizzle_schema;
    if ("update" === "create") organizationId = project.organizationId;else {
      const [currentProject] = await db.select().from(projects).where(eq(projects.id, project));
      organizationId = currentProject.organizationId;
    }
    const [userRole] = await db.select({
      role: members.role
    }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, organizationId)));
    if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
    if ("update" === "create") {
      const [organizationOwner] = await db.select({
          tier: users.tier
        }).from(organizations).leftJoin(members, and(eq(members.organizationId, organizationId), eq(members.role, "owner"))).leftJoin(users, eq(members.userId, users.id)),
        currentProjects = await db.select().from(projects).where(eq(projects.organizationId, organizationId));
      if (!organizationOwner.tier) throw new Error("Maximum number of projects reached.");
      if (organizationOwner.tier === "free" && !!currentProjects.length) throw new Error("Maximum number of projects reached.");
      if (organizationOwner.tier === "basic" && currentProjects.length >= 3) throw new Error("Maximum number of projects reached.");
    }
  });
  return plan();
};
const oldPlan12 = (_$root, args) => {
  const $update = pgUpdateSingle(resource_memberPgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($update);
  return object({
    result: $update
  });
};
const planWrapper12 = (plan, _, fieldArgs) => {
  const $input = fieldArgs.getRaw(["input", "rowId"]),
    $patch = "update" === "update" ? fieldArgs.getRaw(["input", "patch"]) : $input,
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$input, $patch, $currentUser, $db], async ([input, patch, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
      members
    } = lib_drizzle_schema;
    if ("update" === "create") {
      const {
          role,
          userId,
          organizationId
        } = input,
        organizationUsers = await db.select().from(members).where(eq(members.organizationId, organizationId));
      if (organizationUsers.length) {
        const userRole = organizationUsers.find(user => user.userId === currentUser.id)?.role;
        if (!userRole) {
          if (userId !== currentUser.id || role !== "member") throw new Error("Insufficient permissions");
        } else if (userRole !== "owner") throw new Error("Insufficient permissions");
      }
    } else {
      const [member] = await db.select().from(members).where(eq(members.id, input));
      if (currentUser.id !== member.userId) {
        const [userRole] = await db.select({
          role: members.role
        }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, member.organizationId)));
        if (userRole.role !== "owner") throw new Error("Insufficient permissions");
        if (patch.role === "owner") throw new Error("Organizations can only have one owner");
      } else if ("update" === "update") throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
const oldPlan13 = (_$root, args) => {
  const $update = pgUpdateSingle(resource_postPgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($update);
  return object({
    result: $update
  });
};
const planWrapper13 = (plan, _, fieldArgs) => {
  const $post = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$post, $currentUser, $db], async ([post, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const MAX_FREE_TIER_FEEDBACK_UNIQUE_USERS = 15,
      {
        users,
        members,
        projects,
        posts
      } = lib_drizzle_schema;
    if ("update" === "create") {
      const projectId = post.projectId,
        [organizationOwner] = await db.select({
          tier: users.tier
        }).from(projects).leftJoin(members, and(eq(members.organizationId, projects.organizationId), eq(members.role, "owner"))).leftJoin(users, eq(members.userId, users.id)).where(eq(projects.id, projectId));
      if (!organizationOwner.tier || organizationOwner.tier === "free") {
        const [projectFeedback] = await db.select({
          totalUserCount: count(posts.userId)
        }).from(posts).where(eq(posts.projectId, projectId));
        if (projectFeedback.totalUserCount >= MAX_FREE_TIER_FEEDBACK_UNIQUE_USERS) {
          const [userFeedback] = await db.select({
            totalCount: count()
          }).from(posts).where(and(eq(posts.projectId, projectId), eq(posts.userId, currentUser.id)));
          if (!userFeedback.totalCount) throw new Error("Maximum number of unique users providing feedback has been reached");
        }
      }
    } else {
      const [currenPost] = await db.select({
        organizationId: projects.organizationId,
        userId: posts.userId
      }).from(posts).innerJoin(projects, eq(posts.projectId, projects.id)).where(eq(posts.id, post));
      if (currentUser.id !== currenPost.userId) {
        const [userRole] = await db.select({
          role: members.role
        }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, currenPost.organizationId)));
        if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
      }
    }
  });
  return plan();
};
const oldPlan14 = (_$root, args) => {
  const $update = pgUpdateSingle(resource_post_statusPgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($update);
  return object({
    result: $update
  });
};
const planWrapper14 = (plan, _, fieldArgs) => {
  const $postStatus = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$postStatus, $currentUser, $db], async ([postStatus, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
      members,
      projects,
      postStatuses
    } = lib_drizzle_schema;
    let projectId;
    if ("update" === "create") projectId = postStatus.projectId;else {
      const [currentPostStatus] = await db.select().from(postStatuses).where(eq(postStatuses.id, postStatus));
      projectId = currentPostStatus.projectId;
    }
    const [project] = await db.select({
        organizationId: projects.organizationId
      }).from(projects).where(eq(projects.id, projectId)),
      [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, project.organizationId)));
    if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan15 = (_$root, args) => {
  const $update = pgUpdateSingle(resource_userPgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($update);
  return object({
    result: $update
  });
};
const planWrapper15 = (plan, _, fieldArgs) => {
  const $userId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser");
  sideEffect([$userId, $currentUser], async ([userId, currentUser]) => {
    if (!currentUser) throw new Error("Unauthorized");
    if (userId !== currentUser.id) throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan16 = (_$root, args) => {
  const $delete = pgDeleteSingle(resource_downvotePgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($delete);
  return object({
    result: $delete
  });
};
const planWrapper16 = (plan, _, fieldArgs) => {
  const $downvoteId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$downvoteId, $currentUser, $db], async ([downvoteId, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
        downvotes
      } = lib_drizzle_schema,
      [downvote] = await db.select().from(downvotes).where(eq(downvotes.id, downvoteId));
    if (currentUser.id !== downvote.userId) {
      console.error("Current User ID", currentUser.id);
      console.error("Downvote User ID", downvote.userId);
      console.error("Downvote Row ID", downvote.id);
      throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
const oldPlan17 = (_$root, args) => {
  const $delete = pgDeleteSingle(resource_upvotePgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($delete);
  return object({
    result: $delete
  });
};
const planWrapper17 = (plan, _, fieldArgs) => {
  const $upvoteId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$upvoteId, $currentUser, $db], async ([upvoteId, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
        upvotes
      } = lib_drizzle_schema,
      [upvote] = await db.select().from(upvotes).where(eq(upvotes.id, upvoteId));
    if (currentUser.id !== upvote.userId) {
      console.error("Current User ID", currentUser.id);
      console.error("Upvote User ID", upvote.userId);
      console.error("Upvote Row ID", upvote.id);
      throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
const oldPlan18 = (_$root, args) => {
  const $delete = pgDeleteSingle(resource_organizationPgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($delete);
  return object({
    result: $delete
  });
};
const planWrapper18 = (plan, _, fieldArgs) => {
  const $organization = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$organization, $currentUser, $db], async ([organization, currentUser, db]) => {
    if (!currentUser?.tier) throw new Error("Unauthorized");
    const {
      members
    } = lib_drizzle_schema;
    if ("delete" === "create") {
      if (currentUser.tier === "basic" || currentUser.tier === "free") {
        if ((await db.select().from(members).where(and(eq(members.userId, currentUser.id), eq(members.role, "owner")))).length > 0) throw new Error("Maximum number of organizations reached.");
      }
    } else {
      const [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, organization)));
      if ("delete" === "delete" && userRole.role !== "owner") throw new Error("Insufficient permissions");
      if ("delete" === "update" && (!userRole || userRole.role === "member")) throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
const oldPlan19 = (_$root, args) => {
  const $delete = pgDeleteSingle(resource_commentPgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($delete);
  return object({
    result: $delete
  });
};
const planWrapper19 = (plan, _, fieldArgs) => {
  const $comment = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$comment, $currentUser, $db], async ([comment, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const MAX_FREE_TIER_COMMENTS = 100,
      {
        users,
        members,
        projects,
        posts,
        comments
      } = lib_drizzle_schema;
    if ("delete" === "create") {
      const postId = comment.postId,
        [organizationOwner] = await db.select({
          tier: users.tier
        }).from(posts).innerJoin(projects, eq(posts.projectId, projects.id)).leftJoin(members, and(eq(members.organizationId, projects.organizationId), eq(members.role, "owner"))).leftJoin(users, eq(members.userId, users.id)).where(eq(posts.id, postId));
      if (!organizationOwner.tier || organizationOwner.tier === "free") {
        const [postComments] = await db.select({
          totalCount: count()
        }).from(comments).where(eq(comments.postId, postId));
        if (postComments.totalCount >= MAX_FREE_TIER_COMMENTS) throw new Error("Maximum number of comments has been reached");
      }
    } else {
      const [currentComment] = await db.select({
        organizationId: projects.organizationId,
        userId: posts.userId
      }).from(comments).innerJoin(posts, eq(comments.postId, posts.id)).innerJoin(projects, eq(posts.projectId, projects.id)).where(eq(comments.id, comment));
      if (currentUser.id !== currentComment.userId) {
        const [userRole] = await db.select({
          role: members.role
        }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, currentComment.organizationId)));
        if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
      }
    }
  });
  return plan();
};
const oldPlan20 = (_$root, args) => {
  const $delete = pgDeleteSingle(resource_projectPgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($delete);
  return object({
    result: $delete
  });
};
const planWrapper20 = (plan, _, fieldArgs) => {
  const $project = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$project, $currentUser, $db], async ([project, currentUser, db]) => {
    if (!currentUser?.tier) throw new Error("Unauthorized");
    let organizationId;
    const {
      organizations,
      users,
      members,
      projects
    } = lib_drizzle_schema;
    if ("delete" === "create") organizationId = project.organizationId;else {
      const [currentProject] = await db.select().from(projects).where(eq(projects.id, project));
      organizationId = currentProject.organizationId;
    }
    const [userRole] = await db.select({
      role: members.role
    }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, organizationId)));
    if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
    if ("delete" === "create") {
      const [organizationOwner] = await db.select({
          tier: users.tier
        }).from(organizations).leftJoin(members, and(eq(members.organizationId, organizationId), eq(members.role, "owner"))).leftJoin(users, eq(members.userId, users.id)),
        currentProjects = await db.select().from(projects).where(eq(projects.organizationId, organizationId));
      if (!organizationOwner.tier) throw new Error("Maximum number of projects reached.");
      if (organizationOwner.tier === "free" && !!currentProjects.length) throw new Error("Maximum number of projects reached.");
      if (organizationOwner.tier === "basic" && currentProjects.length >= 3) throw new Error("Maximum number of projects reached.");
    }
  });
  return plan();
};
const oldPlan21 = (_$root, args) => {
  const $delete = pgDeleteSingle(resource_memberPgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($delete);
  return object({
    result: $delete
  });
};
const planWrapper21 = (plan, _, fieldArgs) => {
  const $input = fieldArgs.getRaw(["input", "rowId"]),
    $patch = "delete" === "update" ? fieldArgs.getRaw(["input", "patch"]) : $input,
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$input, $patch, $currentUser, $db], async ([input, patch, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
      members
    } = lib_drizzle_schema;
    if ("delete" === "create") {
      const {
          role,
          userId,
          organizationId
        } = input,
        organizationUsers = await db.select().from(members).where(eq(members.organizationId, organizationId));
      if (organizationUsers.length) {
        const userRole = organizationUsers.find(user => user.userId === currentUser.id)?.role;
        if (!userRole) {
          if (userId !== currentUser.id || role !== "member") throw new Error("Insufficient permissions");
        } else if (userRole !== "owner") throw new Error("Insufficient permissions");
      }
    } else {
      const [member] = await db.select().from(members).where(eq(members.id, input));
      if (currentUser.id !== member.userId) {
        const [userRole] = await db.select({
          role: members.role
        }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, member.organizationId)));
        if (userRole.role !== "owner") throw new Error("Insufficient permissions");
        if (patch.role === "owner") throw new Error("Organizations can only have one owner");
      } else if ("delete" === "update") throw new Error("Insufficient permissions");
    }
  });
  return plan();
};
const oldPlan22 = (_$root, args) => {
  const $delete = pgDeleteSingle(resource_postPgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($delete);
  return object({
    result: $delete
  });
};
const planWrapper22 = (plan, _, fieldArgs) => {
  const $post = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$post, $currentUser, $db], async ([post, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const MAX_FREE_TIER_FEEDBACK_UNIQUE_USERS = 15,
      {
        users,
        members,
        projects,
        posts
      } = lib_drizzle_schema;
    if ("delete" === "create") {
      const projectId = post.projectId,
        [organizationOwner] = await db.select({
          tier: users.tier
        }).from(projects).leftJoin(members, and(eq(members.organizationId, projects.organizationId), eq(members.role, "owner"))).leftJoin(users, eq(members.userId, users.id)).where(eq(projects.id, projectId));
      if (!organizationOwner.tier || organizationOwner.tier === "free") {
        const [projectFeedback] = await db.select({
          totalUserCount: count(posts.userId)
        }).from(posts).where(eq(posts.projectId, projectId));
        if (projectFeedback.totalUserCount >= MAX_FREE_TIER_FEEDBACK_UNIQUE_USERS) {
          const [userFeedback] = await db.select({
            totalCount: count()
          }).from(posts).where(and(eq(posts.projectId, projectId), eq(posts.userId, currentUser.id)));
          if (!userFeedback.totalCount) throw new Error("Maximum number of unique users providing feedback has been reached");
        }
      }
    } else {
      const [currenPost] = await db.select({
        organizationId: projects.organizationId,
        userId: posts.userId
      }).from(posts).innerJoin(projects, eq(posts.projectId, projects.id)).where(eq(posts.id, post));
      if (currentUser.id !== currenPost.userId) {
        const [userRole] = await db.select({
          role: members.role
        }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, currenPost.organizationId)));
        if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
      }
    }
  });
  return plan();
};
const oldPlan23 = (_$root, args) => {
  const $delete = pgDeleteSingle(resource_post_statusPgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($delete);
  return object({
    result: $delete
  });
};
const planWrapper23 = (plan, _, fieldArgs) => {
  const $postStatus = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser"),
    $db = context().get("db");
  sideEffect([$postStatus, $currentUser, $db], async ([postStatus, currentUser, db]) => {
    if (!currentUser) throw new Error("Unauthorized");
    const {
      members,
      projects,
      postStatuses
    } = lib_drizzle_schema;
    let projectId;
    if ("delete" === "create") projectId = postStatus.projectId;else {
      const [currentPostStatus] = await db.select().from(postStatuses).where(eq(postStatuses.id, postStatus));
      projectId = currentPostStatus.projectId;
    }
    const [project] = await db.select({
        organizationId: projects.organizationId
      }).from(projects).where(eq(projects.id, projectId)),
      [userRole] = await db.select({
        role: members.role
      }).from(members).where(and(eq(members.userId, currentUser.id), eq(members.organizationId, project.organizationId)));
    if (!userRole || userRole.role === "member") throw new Error("Insufficient permissions");
  });
  return plan();
};
const oldPlan24 = (_$root, args) => {
  const $delete = pgDeleteSingle(resource_userPgResource, {
    id: args.getRaw(['input', "rowId"])
  });
  args.apply($delete);
  return object({
    result: $delete
  });
};
const planWrapper24 = (plan, _, fieldArgs) => {
  const $userId = fieldArgs.getRaw(["input", "rowId"]),
    $currentUser = context().get("currentUser");
  sideEffect([$userId, $currentUser], async ([userId, currentUser]) => {
    if (!currentUser) throw new Error("Unauthorized");
    if (userId !== currentUser.id) throw new Error("Insufficient permissions");
  });
  return plan();
};
export const typeDefs = /* GraphQL */`"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a \`Node\` to work well with Relay 1 mutations. This just resolves to \`query\`.
  """
  id: ID!

  """Fetches an object given its globally unique \`ID\`."""
  node(
    """The globally unique \`ID\`."""
    id: ID!
  ): Node

  """Get a single \`Downvote\`."""
  downvote(rowId: UUID!): Downvote

  """Get a single \`Downvote\`."""
  downvoteByPostIdAndUserId(postId: UUID!, userId: UUID!): Downvote

  """Get a single \`Upvote\`."""
  upvote(rowId: UUID!): Upvote

  """Get a single \`Upvote\`."""
  upvoteByPostIdAndUserId(postId: UUID!, userId: UUID!): Upvote

  """Get a single \`Invitation\`."""
  invitation(rowId: UUID!): Invitation

  """Get a single \`Invitation\`."""
  invitationByOrganizationIdAndEmail(organizationId: UUID!, email: String!): Invitation

  """Get a single \`Organization\`."""
  organization(rowId: UUID!): Organization

  """Get a single \`Organization\`."""
  organizationByName(name: String!): Organization

  """Get a single \`Organization\`."""
  organizationBySlug(slug: String!): Organization

  """Get a single \`Comment\`."""
  comment(rowId: UUID!): Comment

  """Get a single \`Project\`."""
  project(rowId: UUID!): Project

  """Get a single \`Project\`."""
  projectBySlugAndOrganizationId(slug: String!, organizationId: UUID!): Project

  """Get a single \`Member\`."""
  member(rowId: UUID!): Member

  """Get a single \`Member\`."""
  memberByUserIdAndOrganizationId(userId: UUID!, organizationId: UUID!): Member

  """Get a single \`Post\`."""
  post(rowId: UUID!): Post

  """Get a single \`PostStatus\`."""
  postStatus(rowId: UUID!): PostStatus

  """Get a single \`User\`."""
  user(rowId: UUID!): User

  """Get a single \`User\`."""
  userByEmail(email: String!): User

  """Get a single \`User\`."""
  userByHidraId(hidraId: UUID!): User

  """Get a single \`User\`."""
  userByUsername(username: String!): User

  """Reads and enables pagination through a set of \`Downvote\`."""
  downvotes(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DownvoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DownvoteFilter

    """The method to use when ordering \`Downvote\`."""
    orderBy: [DownvoteOrderBy!] = [PRIMARY_KEY_ASC]
  ): DownvoteConnection

  """Reads and enables pagination through a set of \`Upvote\`."""
  upvotes(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UpvoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UpvoteFilter

    """The method to use when ordering \`Upvote\`."""
    orderBy: [UpvoteOrderBy!] = [PRIMARY_KEY_ASC]
  ): UpvoteConnection

  """Reads and enables pagination through a set of \`Invitation\`."""
  invitations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InvitationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: InvitationFilter

    """The method to use when ordering \`Invitation\`."""
    orderBy: [InvitationOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvitationConnection

  """Reads and enables pagination through a set of \`Organization\`."""
  organizations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganizationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganizationFilter

    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganizationConnection

  """Reads and enables pagination through a set of \`Comment\`."""
  comments(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CommentFilter

    """The method to use when ordering \`Comment\`."""
    orderBy: [CommentOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentConnection

  """Reads and enables pagination through a set of \`Project\`."""
  projects(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter

    """The method to use when ordering \`Project\`."""
    orderBy: [ProjectOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectConnection

  """Reads and enables pagination through a set of \`Member\`."""
  members(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MemberFilter

    """The method to use when ordering \`Member\`."""
    orderBy: [MemberOrderBy!] = [PRIMARY_KEY_ASC]
  ): MemberConnection

  """Reads and enables pagination through a set of \`Post\`."""
  posts(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter

    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostConnection

  """Reads and enables pagination through a set of \`PostStatus\`."""
  postStatuses(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostStatusCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostStatusFilter

    """The method to use when ordering \`PostStatus\`."""
    orderBy: [PostStatusOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostStatusConnection

  """Reads and enables pagination through a set of \`User\`."""
  users(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter

    """The method to use when ordering \`User\`."""
    orderBy: [UserOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserConnection
}

"""An object with a globally unique \`ID\`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
}

type Downvote {
  rowId: UUID!
  postId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Post\` that is related to this \`Downvote\`."""
  post: Post

  """Reads a single \`User\` that is related to this \`Downvote\`."""
  user: User
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) and, if it has a timezone, [RFC
3339](https://datatracker.ietf.org/doc/html/rfc3339) standards. Input values
that do not conform to both ISO 8601 and RFC 3339 may be coerced, which may lead
to unexpected results.
"""
scalar Datetime

type Post {
  rowId: UUID!
  title: String
  description: String
  projectId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
  statusId: UUID
  statusUpdatedAt: Datetime

  """Reads a single \`Project\` that is related to this \`Post\`."""
  project: Project

  """Reads a single \`PostStatus\` that is related to this \`Post\`."""
  status: PostStatus

  """Reads a single \`User\` that is related to this \`Post\`."""
  user: User

  """Reads and enables pagination through a set of \`Upvote\`."""
  upvotes(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UpvoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UpvoteFilter

    """The method to use when ordering \`Upvote\`."""
    orderBy: [UpvoteOrderBy!] = [PRIMARY_KEY_ASC]
  ): UpvoteConnection!

  """Reads and enables pagination through a set of \`Comment\`."""
  comments(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CommentFilter

    """The method to use when ordering \`Comment\`."""
    orderBy: [CommentOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentConnection!

  """Reads and enables pagination through a set of \`Downvote\`."""
  downvotes(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DownvoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DownvoteFilter

    """The method to use when ordering \`Downvote\`."""
    orderBy: [DownvoteOrderBy!] = [PRIMARY_KEY_ASC]
  ): DownvoteConnection!
}

type Project {
  rowId: UUID!
  name: String!
  image: String
  slug: String!
  description: String
  organizationId: UUID!
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Organization\` that is related to this \`Project\`."""
  organization: Organization

  """Reads and enables pagination through a set of \`Post\`."""
  posts(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter

    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostConnection!

  """Reads and enables pagination through a set of \`PostStatus\`."""
  postStatuses(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostStatusCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostStatusFilter

    """The method to use when ordering \`PostStatus\`."""
    orderBy: [PostStatusOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostStatusConnection!
}

type Organization {
  rowId: UUID!
  name: String!
  slug: String!
  createdAt: Datetime
  updatedAt: Datetime

  """Reads and enables pagination through a set of \`Project\`."""
  projects(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter

    """The method to use when ordering \`Project\`."""
    orderBy: [ProjectOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectConnection!

  """Reads and enables pagination through a set of \`Member\`."""
  members(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MemberFilter

    """The method to use when ordering \`Member\`."""
    orderBy: [MemberOrderBy!] = [PRIMARY_KEY_ASC]
  ): MemberConnection!

  """Reads and enables pagination through a set of \`Invitation\`."""
  invitations(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InvitationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: InvitationFilter

    """The method to use when ordering \`Invitation\`."""
    orderBy: [InvitationOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvitationConnection!
}

"""A connection to a list of \`Project\` values."""
type ProjectConnection {
  """A list of \`Project\` objects."""
  nodes: [Project]!

  """
  A list of edges which contains the \`Project\` and cursor to aid in pagination.
  """
  edges: [ProjectEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Project\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ProjectAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Project\` for these aggregates."""
    groupBy: [ProjectGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: ProjectHavingInput
  ): [ProjectAggregates!]
}

"""A \`Project\` edge in the connection."""
type ProjectEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Project\` at the end of the edge."""
  node: Project
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

type ProjectAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ProjectDistinctCountAggregates
}

type ProjectDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of image across the matching connection"""
  image: BigInt

  """Distinct count of slug across the matching connection"""
  slug: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""Grouping methods for \`Project\` for usage during aggregation."""
enum ProjectGroupBy {
  NAME
  IMAGE
  SLUG
  DESCRIPTION
  ORGANIZATION_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`Project\` aggregates."""
input ProjectHavingInput {
  AND: [ProjectHavingInput!]
  OR: [ProjectHavingInput!]
  sum: ProjectHavingSumInput
  distinctCount: ProjectHavingDistinctCountInput
  min: ProjectHavingMinInput
  max: ProjectHavingMaxInput
  average: ProjectHavingAverageInput
  stddevSample: ProjectHavingStddevSampleInput
  stddevPopulation: ProjectHavingStddevPopulationInput
  varianceSample: ProjectHavingVarianceSampleInput
  variancePopulation: ProjectHavingVariancePopulationInput
}

input ProjectHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input HavingDatetimeFilter {
  equalTo: Datetime
  notEqualTo: Datetime
  greaterThan: Datetime
  greaterThanOrEqualTo: Datetime
  lessThan: Datetime
  lessThanOrEqualTo: Datetime
}

input ProjectHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input ProjectHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against \`Project\` object types. All fields are tested for equality and combined with a logical and.
"""
input ProjectCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`name\` field."""
  name: String

  """Checks for equality with the objects \`image\` field."""
  image: String

  """Checks for equality with the objects \`slug\` field."""
  slug: String

  """Checks for equality with the objects \`description\` field."""
  description: String

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime
}

"""
A filter to be used against \`Project\` object types. All fields are combined with a logical and.
"""
input ProjectFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`name\` field."""
  name: StringFilter

  """Filter by the objects \`image\` field."""
  image: StringFilter

  """Filter by the objects \`slug\` field."""
  slug: StringFilter

  """Filter by the objects \`description\` field."""
  description: StringFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`posts\` relation."""
  posts: ProjectToManyPostFilter

  """Some related \`posts\` exist."""
  postsExist: Boolean

  """Filter by the objects \`postStatuses\` relation."""
  postStatuses: ProjectToManyPostStatusFilter

  """Some related \`postStatuses\` exist."""
  postStatusesExist: Boolean

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Checks for all expressions in this list."""
  and: [ProjectFilter!]

  """Checks for any expressions in this list."""
  or: [ProjectFilter!]

  """Negates the expression."""
  not: ProjectFilter
}

"""
A filter to be used against UUID fields. All fields are combined with a logical and.
"""
input UUIDFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: UUID

  """Not equal to the specified value."""
  notEqualTo: UUID

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: UUID

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: UUID

  """Included in the specified list."""
  in: [UUID!]

  """Not included in the specified list."""
  notIn: [UUID!]

  """Less than the specified value."""
  lessThan: UUID

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: UUID

  """Greater than the specified value."""
  greaterThan: UUID

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: UUID
}

"""
A filter to be used against String fields. All fields are combined with a logical and.
"""
input StringFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: String

  """Not equal to the specified value."""
  notEqualTo: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """Included in the specified list."""
  in: [String!]

  """Not included in the specified list."""
  notIn: [String!]

  """Less than the specified value."""
  lessThan: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String
}

"""
A filter to be used against Datetime fields. All fields are combined with a logical and.
"""
input DatetimeFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Datetime

  """Not equal to the specified value."""
  notEqualTo: Datetime

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Datetime

  """Included in the specified list."""
  in: [Datetime!]

  """Not included in the specified list."""
  notIn: [Datetime!]

  """Less than the specified value."""
  lessThan: Datetime

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Datetime

  """Greater than the specified value."""
  greaterThan: Datetime

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Datetime
}

"""
A filter to be used against many \`Post\` object types. All fields are combined with a logical and.
"""
input ProjectToManyPostFilter {
  """
  Every related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PostFilter

  """
  Some related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PostFilter

  """
  No related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PostFilter

  """Aggregates across related \`Post\` match the filter criteria."""
  aggregates: PostAggregatesFilter
}

"""
A filter to be used against \`Post\` object types. All fields are combined with a logical and.
"""
input PostFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`title\` field."""
  title: StringFilter

  """Filter by the objects \`description\` field."""
  description: StringFilter

  """Filter by the objects \`projectId\` field."""
  projectId: UUIDFilter

  """Filter by the objects \`userId\` field."""
  userId: UUIDFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`statusId\` field."""
  statusId: UUIDFilter

  """Filter by the objects \`statusUpdatedAt\` field."""
  statusUpdatedAt: DatetimeFilter

  """Filter by the objects \`upvotes\` relation."""
  upvotes: PostToManyUpvoteFilter

  """Some related \`upvotes\` exist."""
  upvotesExist: Boolean

  """Filter by the objects \`comments\` relation."""
  comments: PostToManyCommentFilter

  """Some related \`comments\` exist."""
  commentsExist: Boolean

  """Filter by the objects \`downvotes\` relation."""
  downvotes: PostToManyDownvoteFilter

  """Some related \`downvotes\` exist."""
  downvotesExist: Boolean

  """Filter by the objects \`project\` relation."""
  project: ProjectFilter

  """Filter by the objects \`status\` relation."""
  status: PostStatusFilter

  """A related \`status\` exists."""
  statusExists: Boolean

  """Filter by the objects \`user\` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [PostFilter!]

  """Checks for any expressions in this list."""
  or: [PostFilter!]

  """Negates the expression."""
  not: PostFilter
}

"""
A filter to be used against many \`Upvote\` object types. All fields are combined with a logical and.
"""
input PostToManyUpvoteFilter {
  """
  Every related \`Upvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: UpvoteFilter

  """
  Some related \`Upvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: UpvoteFilter

  """
  No related \`Upvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: UpvoteFilter

  """Aggregates across related \`Upvote\` match the filter criteria."""
  aggregates: UpvoteAggregatesFilter
}

"""
A filter to be used against \`Upvote\` object types. All fields are combined with a logical and.
"""
input UpvoteFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`postId\` field."""
  postId: UUIDFilter

  """Filter by the objects \`userId\` field."""
  userId: UUIDFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`post\` relation."""
  post: PostFilter

  """Filter by the objects \`user\` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [UpvoteFilter!]

  """Checks for any expressions in this list."""
  or: [UpvoteFilter!]

  """Negates the expression."""
  not: UpvoteFilter
}

"""
A filter to be used against \`User\` object types. All fields are combined with a logical and.
"""
input UserFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`hidraId\` field."""
  hidraId: UUIDFilter

  """Filter by the objects \`username\` field."""
  username: StringFilter

  """Filter by the objects \`firstName\` field."""
  firstName: StringFilter

  """Filter by the objects \`lastName\` field."""
  lastName: StringFilter

  """Filter by the objects \`email\` field."""
  email: StringFilter

  """Filter by the objects \`tier\` field."""
  tier: TierFilter

  """Filter by the objects \`posts\` relation."""
  posts: UserToManyPostFilter

  """Some related \`posts\` exist."""
  postsExist: Boolean

  """Filter by the objects \`upvotes\` relation."""
  upvotes: UserToManyUpvoteFilter

  """Some related \`upvotes\` exist."""
  upvotesExist: Boolean

  """Filter by the objects \`members\` relation."""
  members: UserToManyMemberFilter

  """Some related \`members\` exist."""
  membersExist: Boolean

  """Filter by the objects \`comments\` relation."""
  comments: UserToManyCommentFilter

  """Some related \`comments\` exist."""
  commentsExist: Boolean

  """Filter by the objects \`downvotes\` relation."""
  downvotes: UserToManyDownvoteFilter

  """Some related \`downvotes\` exist."""
  downvotesExist: Boolean

  """Checks for all expressions in this list."""
  and: [UserFilter!]

  """Checks for any expressions in this list."""
  or: [UserFilter!]

  """Negates the expression."""
  not: UserFilter
}

"""
A filter to be used against Tier fields. All fields are combined with a logical and.
"""
input TierFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Tier

  """Not equal to the specified value."""
  notEqualTo: Tier

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Tier

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Tier

  """Included in the specified list."""
  in: [Tier!]

  """Not included in the specified list."""
  notIn: [Tier!]

  """Less than the specified value."""
  lessThan: Tier

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Tier

  """Greater than the specified value."""
  greaterThan: Tier

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Tier
}

enum Tier {
  free
  basic
  team
  enterprise
}

"""
A filter to be used against many \`Post\` object types. All fields are combined with a logical and.
"""
input UserToManyPostFilter {
  """
  Every related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PostFilter

  """
  Some related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PostFilter

  """
  No related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PostFilter

  """Aggregates across related \`Post\` match the filter criteria."""
  aggregates: PostAggregatesFilter
}

"""A filter to be used against aggregates of \`Post\` object types."""
input PostAggregatesFilter {
  """
  A filter that must pass for the relevant \`Post\` object to be included within the aggregate.
  """
  filter: PostFilter

  """Distinct count aggregate over matching \`Post\` objects."""
  distinctCount: PostDistinctCountAggregateFilter
}

input PostDistinctCountAggregateFilter {
  rowId: BigIntFilter
  title: BigIntFilter
  description: BigIntFilter
  projectId: BigIntFilter
  userId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  statusId: BigIntFilter
  statusUpdatedAt: BigIntFilter
}

"""
A filter to be used against BigInt fields. All fields are combined with a logical and.
"""
input BigIntFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: BigInt

  """Not equal to the specified value."""
  notEqualTo: BigInt

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigInt

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigInt

  """Included in the specified list."""
  in: [BigInt!]

  """Not included in the specified list."""
  notIn: [BigInt!]

  """Less than the specified value."""
  lessThan: BigInt

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigInt

  """Greater than the specified value."""
  greaterThan: BigInt

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigInt
}

"""
A filter to be used against many \`Upvote\` object types. All fields are combined with a logical and.
"""
input UserToManyUpvoteFilter {
  """
  Every related \`Upvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: UpvoteFilter

  """
  Some related \`Upvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: UpvoteFilter

  """
  No related \`Upvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: UpvoteFilter

  """Aggregates across related \`Upvote\` match the filter criteria."""
  aggregates: UpvoteAggregatesFilter
}

"""A filter to be used against aggregates of \`Upvote\` object types."""
input UpvoteAggregatesFilter {
  """
  A filter that must pass for the relevant \`Upvote\` object to be included within the aggregate.
  """
  filter: UpvoteFilter

  """Distinct count aggregate over matching \`Upvote\` objects."""
  distinctCount: UpvoteDistinctCountAggregateFilter
}

input UpvoteDistinctCountAggregateFilter {
  rowId: BigIntFilter
  postId: BigIntFilter
  userId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many \`Member\` object types. All fields are combined with a logical and.
"""
input UserToManyMemberFilter {
  """
  Every related \`Member\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: MemberFilter

  """
  Some related \`Member\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: MemberFilter

  """
  No related \`Member\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: MemberFilter

  """Aggregates across related \`Member\` match the filter criteria."""
  aggregates: MemberAggregatesFilter
}

"""
A filter to be used against \`Member\` object types. All fields are combined with a logical and.
"""
input MemberFilter {
  """Filter by the objects \`userId\` field."""
  userId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`role\` field."""
  role: RoleFilter

  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Filter by the objects \`user\` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [MemberFilter!]

  """Checks for any expressions in this list."""
  or: [MemberFilter!]

  """Negates the expression."""
  not: MemberFilter
}

"""
A filter to be used against Role fields. All fields are combined with a logical and.
"""
input RoleFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Role

  """Not equal to the specified value."""
  notEqualTo: Role

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Role

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Role

  """Included in the specified list."""
  in: [Role!]

  """Not included in the specified list."""
  notIn: [Role!]

  """Less than the specified value."""
  lessThan: Role

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Role

  """Greater than the specified value."""
  greaterThan: Role

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Role
}

enum Role {
  owner
  admin
  member
}

"""
A filter to be used against \`Organization\` object types. All fields are combined with a logical and.
"""
input OrganizationFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`name\` field."""
  name: StringFilter

  """Filter by the objects \`slug\` field."""
  slug: StringFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`projects\` relation."""
  projects: OrganizationToManyProjectFilter

  """Some related \`projects\` exist."""
  projectsExist: Boolean

  """Filter by the objects \`members\` relation."""
  members: OrganizationToManyMemberFilter

  """Some related \`members\` exist."""
  membersExist: Boolean

  """Filter by the objects \`invitations\` relation."""
  invitations: OrganizationToManyInvitationFilter

  """Some related \`invitations\` exist."""
  invitationsExist: Boolean

  """Checks for all expressions in this list."""
  and: [OrganizationFilter!]

  """Checks for any expressions in this list."""
  or: [OrganizationFilter!]

  """Negates the expression."""
  not: OrganizationFilter
}

"""
A filter to be used against many \`Project\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyProjectFilter {
  """
  Every related \`Project\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: ProjectFilter

  """
  Some related \`Project\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: ProjectFilter

  """
  No related \`Project\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: ProjectFilter

  """Aggregates across related \`Project\` match the filter criteria."""
  aggregates: ProjectAggregatesFilter
}

"""A filter to be used against aggregates of \`Project\` object types."""
input ProjectAggregatesFilter {
  """
  A filter that must pass for the relevant \`Project\` object to be included within the aggregate.
  """
  filter: ProjectFilter

  """Distinct count aggregate over matching \`Project\` objects."""
  distinctCount: ProjectDistinctCountAggregateFilter
}

input ProjectDistinctCountAggregateFilter {
  rowId: BigIntFilter
  name: BigIntFilter
  image: BigIntFilter
  slug: BigIntFilter
  description: BigIntFilter
  organizationId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many \`Member\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyMemberFilter {
  """
  Every related \`Member\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: MemberFilter

  """
  Some related \`Member\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: MemberFilter

  """
  No related \`Member\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: MemberFilter

  """Aggregates across related \`Member\` match the filter criteria."""
  aggregates: MemberAggregatesFilter
}

"""A filter to be used against aggregates of \`Member\` object types."""
input MemberAggregatesFilter {
  """
  A filter that must pass for the relevant \`Member\` object to be included within the aggregate.
  """
  filter: MemberFilter

  """Distinct count aggregate over matching \`Member\` objects."""
  distinctCount: MemberDistinctCountAggregateFilter
}

input MemberDistinctCountAggregateFilter {
  userId: BigIntFilter
  organizationId: BigIntFilter
  createdAt: BigIntFilter
  role: BigIntFilter
  rowId: BigIntFilter
}

"""
A filter to be used against many \`Invitation\` object types. All fields are combined with a logical and.
"""
input OrganizationToManyInvitationFilter {
  """
  Every related \`Invitation\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: InvitationFilter

  """
  Some related \`Invitation\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: InvitationFilter

  """
  No related \`Invitation\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: InvitationFilter

  """Aggregates across related \`Invitation\` match the filter criteria."""
  aggregates: InvitationAggregatesFilter
}

"""
A filter to be used against \`Invitation\` object types. All fields are combined with a logical and.
"""
input InvitationFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`organizationId\` field."""
  organizationId: UUIDFilter

  """Filter by the objects \`email\` field."""
  email: StringFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`organization\` relation."""
  organization: OrganizationFilter

  """Checks for all expressions in this list."""
  and: [InvitationFilter!]

  """Checks for any expressions in this list."""
  or: [InvitationFilter!]

  """Negates the expression."""
  not: InvitationFilter
}

"""A filter to be used against aggregates of \`Invitation\` object types."""
input InvitationAggregatesFilter {
  """
  A filter that must pass for the relevant \`Invitation\` object to be included within the aggregate.
  """
  filter: InvitationFilter

  """Distinct count aggregate over matching \`Invitation\` objects."""
  distinctCount: InvitationDistinctCountAggregateFilter
}

input InvitationDistinctCountAggregateFilter {
  rowId: BigIntFilter
  organizationId: BigIntFilter
  email: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many \`Comment\` object types. All fields are combined with a logical and.
"""
input UserToManyCommentFilter {
  """
  Every related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: CommentFilter

  """
  Some related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: CommentFilter

  """
  No related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: CommentFilter

  """Aggregates across related \`Comment\` match the filter criteria."""
  aggregates: CommentAggregatesFilter
}

"""
A filter to be used against \`Comment\` object types. All fields are combined with a logical and.
"""
input CommentFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`message\` field."""
  message: StringFilter

  """Filter by the objects \`postId\` field."""
  postId: UUIDFilter

  """Filter by the objects \`userId\` field."""
  userId: UUIDFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`parentId\` field."""
  parentId: UUIDFilter

  """Filter by the objects \`childComments\` relation."""
  childComments: CommentToManyCommentFilter

  """Some related \`childComments\` exist."""
  childCommentsExist: Boolean

  """Filter by the objects \`parent\` relation."""
  parent: CommentFilter

  """A related \`parent\` exists."""
  parentExists: Boolean

  """Filter by the objects \`post\` relation."""
  post: PostFilter

  """Filter by the objects \`user\` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [CommentFilter!]

  """Checks for any expressions in this list."""
  or: [CommentFilter!]

  """Negates the expression."""
  not: CommentFilter
}

"""
A filter to be used against many \`Comment\` object types. All fields are combined with a logical and.
"""
input CommentToManyCommentFilter {
  """
  Every related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: CommentFilter

  """
  Some related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: CommentFilter

  """
  No related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: CommentFilter

  """Aggregates across related \`Comment\` match the filter criteria."""
  aggregates: CommentAggregatesFilter
}

"""A filter to be used against aggregates of \`Comment\` object types."""
input CommentAggregatesFilter {
  """
  A filter that must pass for the relevant \`Comment\` object to be included within the aggregate.
  """
  filter: CommentFilter

  """Distinct count aggregate over matching \`Comment\` objects."""
  distinctCount: CommentDistinctCountAggregateFilter
}

input CommentDistinctCountAggregateFilter {
  rowId: BigIntFilter
  message: BigIntFilter
  postId: BigIntFilter
  userId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
  parentId: BigIntFilter
}

"""
A filter to be used against many \`Downvote\` object types. All fields are combined with a logical and.
"""
input UserToManyDownvoteFilter {
  """
  Every related \`Downvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: DownvoteFilter

  """
  Some related \`Downvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: DownvoteFilter

  """
  No related \`Downvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: DownvoteFilter

  """Aggregates across related \`Downvote\` match the filter criteria."""
  aggregates: DownvoteAggregatesFilter
}

"""
A filter to be used against \`Downvote\` object types. All fields are combined with a logical and.
"""
input DownvoteFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`postId\` field."""
  postId: UUIDFilter

  """Filter by the objects \`userId\` field."""
  userId: UUIDFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`post\` relation."""
  post: PostFilter

  """Filter by the objects \`user\` relation."""
  user: UserFilter

  """Checks for all expressions in this list."""
  and: [DownvoteFilter!]

  """Checks for any expressions in this list."""
  or: [DownvoteFilter!]

  """Negates the expression."""
  not: DownvoteFilter
}

"""A filter to be used against aggregates of \`Downvote\` object types."""
input DownvoteAggregatesFilter {
  """
  A filter that must pass for the relevant \`Downvote\` object to be included within the aggregate.
  """
  filter: DownvoteFilter

  """Distinct count aggregate over matching \`Downvote\` objects."""
  distinctCount: DownvoteDistinctCountAggregateFilter
}

input DownvoteDistinctCountAggregateFilter {
  rowId: BigIntFilter
  postId: BigIntFilter
  userId: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""
A filter to be used against many \`Comment\` object types. All fields are combined with a logical and.
"""
input PostToManyCommentFilter {
  """
  Every related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: CommentFilter

  """
  Some related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: CommentFilter

  """
  No related \`Comment\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: CommentFilter

  """Aggregates across related \`Comment\` match the filter criteria."""
  aggregates: CommentAggregatesFilter
}

"""
A filter to be used against many \`Downvote\` object types. All fields are combined with a logical and.
"""
input PostToManyDownvoteFilter {
  """
  Every related \`Downvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: DownvoteFilter

  """
  Some related \`Downvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: DownvoteFilter

  """
  No related \`Downvote\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: DownvoteFilter

  """Aggregates across related \`Downvote\` match the filter criteria."""
  aggregates: DownvoteAggregatesFilter
}

"""
A filter to be used against \`PostStatus\` object types. All fields are combined with a logical and.
"""
input PostStatusFilter {
  """Filter by the objects \`rowId\` field."""
  rowId: UUIDFilter

  """Filter by the objects \`status\` field."""
  status: StringFilter

  """Filter by the objects \`description\` field."""
  description: StringFilter

  """Filter by the objects \`color\` field."""
  color: StringFilter

  """Filter by the objects \`projectId\` field."""
  projectId: UUIDFilter

  """Filter by the objects \`isDefault\` field."""
  isDefault: BooleanFilter

  """Filter by the objects \`createdAt\` field."""
  createdAt: DatetimeFilter

  """Filter by the objects \`updatedAt\` field."""
  updatedAt: DatetimeFilter

  """Filter by the objects \`postsByStatusId\` relation."""
  postsByStatusId: PostStatusToManyPostFilter

  """Some related \`postsByStatusId\` exist."""
  postsByStatusIdExist: Boolean

  """Filter by the objects \`project\` relation."""
  project: ProjectFilter

  """Checks for all expressions in this list."""
  and: [PostStatusFilter!]

  """Checks for any expressions in this list."""
  or: [PostStatusFilter!]

  """Negates the expression."""
  not: PostStatusFilter
}

"""
A filter to be used against Boolean fields. All fields are combined with a logical and.
"""
input BooleanFilter {
  """
  Is null (if \`true\` is specified) or is not null (if \`false\` is specified).
  """
  isNull: Boolean

  """Equal to the specified value."""
  equalTo: Boolean

  """Not equal to the specified value."""
  notEqualTo: Boolean

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Boolean

  """Included in the specified list."""
  in: [Boolean!]

  """Not included in the specified list."""
  notIn: [Boolean!]

  """Less than the specified value."""
  lessThan: Boolean

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Boolean

  """Greater than the specified value."""
  greaterThan: Boolean

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Boolean
}

"""
A filter to be used against many \`Post\` object types. All fields are combined with a logical and.
"""
input PostStatusToManyPostFilter {
  """
  Every related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PostFilter

  """
  Some related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PostFilter

  """
  No related \`Post\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PostFilter

  """Aggregates across related \`Post\` match the filter criteria."""
  aggregates: PostAggregatesFilter
}

"""
A filter to be used against many \`PostStatus\` object types. All fields are combined with a logical and.
"""
input ProjectToManyPostStatusFilter {
  """
  Every related \`PostStatus\` matches the filter criteria. All fields are combined with a logical and.
  """
  every: PostStatusFilter

  """
  Some related \`PostStatus\` matches the filter criteria. All fields are combined with a logical and.
  """
  some: PostStatusFilter

  """
  No related \`PostStatus\` matches the filter criteria. All fields are combined with a logical and.
  """
  none: PostStatusFilter

  """Aggregates across related \`PostStatus\` match the filter criteria."""
  aggregates: PostStatusAggregatesFilter
}

"""A filter to be used against aggregates of \`PostStatus\` object types."""
input PostStatusAggregatesFilter {
  """
  A filter that must pass for the relevant \`PostStatus\` object to be included within the aggregate.
  """
  filter: PostStatusFilter

  """Distinct count aggregate over matching \`PostStatus\` objects."""
  distinctCount: PostStatusDistinctCountAggregateFilter
}

input PostStatusDistinctCountAggregateFilter {
  rowId: BigIntFilter
  status: BigIntFilter
  description: BigIntFilter
  color: BigIntFilter
  projectId: BigIntFilter
  isDefault: BigIntFilter
  createdAt: BigIntFilter
  updatedAt: BigIntFilter
}

"""Methods to use when ordering \`Project\`."""
enum ProjectOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  SLUG_ASC
  SLUG_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  POSTS_COUNT_ASC
  POSTS_COUNT_DESC
  POSTS_DISTINCT_COUNT_ROW_ID_ASC
  POSTS_DISTINCT_COUNT_ROW_ID_DESC
  POSTS_DISTINCT_COUNT_TITLE_ASC
  POSTS_DISTINCT_COUNT_TITLE_DESC
  POSTS_DISTINCT_COUNT_DESCRIPTION_ASC
  POSTS_DISTINCT_COUNT_DESCRIPTION_DESC
  POSTS_DISTINCT_COUNT_PROJECT_ID_ASC
  POSTS_DISTINCT_COUNT_PROJECT_ID_DESC
  POSTS_DISTINCT_COUNT_USER_ID_ASC
  POSTS_DISTINCT_COUNT_USER_ID_DESC
  POSTS_DISTINCT_COUNT_CREATED_AT_ASC
  POSTS_DISTINCT_COUNT_CREATED_AT_DESC
  POSTS_DISTINCT_COUNT_UPDATED_AT_ASC
  POSTS_DISTINCT_COUNT_UPDATED_AT_DESC
  POSTS_DISTINCT_COUNT_STATUS_ID_ASC
  POSTS_DISTINCT_COUNT_STATUS_ID_DESC
  POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_ASC
  POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_DESC
  POST_STATUSES_COUNT_ASC
  POST_STATUSES_COUNT_DESC
  POST_STATUSES_DISTINCT_COUNT_ROW_ID_ASC
  POST_STATUSES_DISTINCT_COUNT_ROW_ID_DESC
  POST_STATUSES_DISTINCT_COUNT_STATUS_ASC
  POST_STATUSES_DISTINCT_COUNT_STATUS_DESC
  POST_STATUSES_DISTINCT_COUNT_DESCRIPTION_ASC
  POST_STATUSES_DISTINCT_COUNT_DESCRIPTION_DESC
  POST_STATUSES_DISTINCT_COUNT_COLOR_ASC
  POST_STATUSES_DISTINCT_COUNT_COLOR_DESC
  POST_STATUSES_DISTINCT_COUNT_PROJECT_ID_ASC
  POST_STATUSES_DISTINCT_COUNT_PROJECT_ID_DESC
  POST_STATUSES_DISTINCT_COUNT_IS_DEFAULT_ASC
  POST_STATUSES_DISTINCT_COUNT_IS_DEFAULT_DESC
  POST_STATUSES_DISTINCT_COUNT_CREATED_AT_ASC
  POST_STATUSES_DISTINCT_COUNT_CREATED_AT_DESC
  POST_STATUSES_DISTINCT_COUNT_UPDATED_AT_ASC
  POST_STATUSES_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""A connection to a list of \`Member\` values."""
type MemberConnection {
  """A list of \`Member\` objects."""
  nodes: [Member]!

  """
  A list of edges which contains the \`Member\` and cursor to aid in pagination.
  """
  edges: [MemberEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Member\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: MemberAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Member\` for these aggregates."""
    groupBy: [MemberGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: MemberHavingInput
  ): [MemberAggregates!]
}

type Member {
  userId: UUID!
  organizationId: UUID!
  createdAt: Datetime
  role: Role!
  rowId: UUID!

  """Reads a single \`Organization\` that is related to this \`Member\`."""
  organization: Organization

  """Reads a single \`User\` that is related to this \`Member\`."""
  user: User
}

type User {
  rowId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
  hidraId: UUID!
  username: String
  firstName: String
  lastName: String
  email: String!
  tier: Tier

  """Reads and enables pagination through a set of \`Post\`."""
  posts(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter

    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostConnection!

  """Reads and enables pagination through a set of \`Upvote\`."""
  upvotes(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UpvoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UpvoteFilter

    """The method to use when ordering \`Upvote\`."""
    orderBy: [UpvoteOrderBy!] = [PRIMARY_KEY_ASC]
  ): UpvoteConnection!

  """Reads and enables pagination through a set of \`Member\`."""
  members(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MemberCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MemberFilter

    """The method to use when ordering \`Member\`."""
    orderBy: [MemberOrderBy!] = [PRIMARY_KEY_ASC]
  ): MemberConnection!

  """Reads and enables pagination through a set of \`Comment\`."""
  comments(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CommentFilter

    """The method to use when ordering \`Comment\`."""
    orderBy: [CommentOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentConnection!

  """Reads and enables pagination through a set of \`Downvote\`."""
  downvotes(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DownvoteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DownvoteFilter

    """The method to use when ordering \`Downvote\`."""
    orderBy: [DownvoteOrderBy!] = [PRIMARY_KEY_ASC]
  ): DownvoteConnection!
}

"""A connection to a list of \`Post\` values."""
type PostConnection {
  """A list of \`Post\` objects."""
  nodes: [Post]!

  """
  A list of edges which contains the \`Post\` and cursor to aid in pagination.
  """
  edges: [PostEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Post\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: PostAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Post\` for these aggregates."""
    groupBy: [PostGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: PostHavingInput
  ): [PostAggregates!]
}

"""A \`Post\` edge in the connection."""
type PostEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Post\` at the end of the edge."""
  node: Post
}

type PostAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: PostDistinctCountAggregates
}

type PostDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of title across the matching connection"""
  title: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of statusId across the matching connection"""
  statusId: BigInt

  """Distinct count of statusUpdatedAt across the matching connection"""
  statusUpdatedAt: BigInt
}

"""Grouping methods for \`Post\` for usage during aggregation."""
enum PostGroupBy {
  TITLE
  DESCRIPTION
  PROJECT_ID
  USER_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  STATUS_ID
  STATUS_UPDATED_AT
  STATUS_UPDATED_AT_TRUNCATED_TO_HOUR
  STATUS_UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`Post\` aggregates."""
input PostHavingInput {
  AND: [PostHavingInput!]
  OR: [PostHavingInput!]
  sum: PostHavingSumInput
  distinctCount: PostHavingDistinctCountInput
  min: PostHavingMinInput
  max: PostHavingMaxInput
  average: PostHavingAverageInput
  stddevSample: PostHavingStddevSampleInput
  stddevPopulation: PostHavingStddevPopulationInput
  varianceSample: PostHavingVarianceSampleInput
  variancePopulation: PostHavingVariancePopulationInput
}

input PostHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

input PostHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
  statusUpdatedAt: HavingDatetimeFilter
}

"""
A condition to be used against \`Post\` object types. All fields are tested for equality and combined with a logical and.
"""
input PostCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`title\` field."""
  title: String

  """Checks for equality with the objects \`description\` field."""
  description: String

  """Checks for equality with the objects \`projectId\` field."""
  projectId: UUID

  """Checks for equality with the objects \`userId\` field."""
  userId: UUID

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime

  """Checks for equality with the objects \`statusId\` field."""
  statusId: UUID

  """Checks for equality with the objects \`statusUpdatedAt\` field."""
  statusUpdatedAt: Datetime
}

"""Methods to use when ordering \`Post\`."""
enum PostOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  TITLE_ASC
  TITLE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  STATUS_ID_ASC
  STATUS_ID_DESC
  STATUS_UPDATED_AT_ASC
  STATUS_UPDATED_AT_DESC
  UPVOTES_COUNT_ASC
  UPVOTES_COUNT_DESC
  UPVOTES_DISTINCT_COUNT_ROW_ID_ASC
  UPVOTES_DISTINCT_COUNT_ROW_ID_DESC
  UPVOTES_DISTINCT_COUNT_POST_ID_ASC
  UPVOTES_DISTINCT_COUNT_POST_ID_DESC
  UPVOTES_DISTINCT_COUNT_USER_ID_ASC
  UPVOTES_DISTINCT_COUNT_USER_ID_DESC
  UPVOTES_DISTINCT_COUNT_CREATED_AT_ASC
  UPVOTES_DISTINCT_COUNT_CREATED_AT_DESC
  UPVOTES_DISTINCT_COUNT_UPDATED_AT_ASC
  UPVOTES_DISTINCT_COUNT_UPDATED_AT_DESC
  COMMENTS_COUNT_ASC
  COMMENTS_COUNT_DESC
  COMMENTS_DISTINCT_COUNT_ROW_ID_ASC
  COMMENTS_DISTINCT_COUNT_ROW_ID_DESC
  COMMENTS_DISTINCT_COUNT_MESSAGE_ASC
  COMMENTS_DISTINCT_COUNT_MESSAGE_DESC
  COMMENTS_DISTINCT_COUNT_POST_ID_ASC
  COMMENTS_DISTINCT_COUNT_POST_ID_DESC
  COMMENTS_DISTINCT_COUNT_USER_ID_ASC
  COMMENTS_DISTINCT_COUNT_USER_ID_DESC
  COMMENTS_DISTINCT_COUNT_CREATED_AT_ASC
  COMMENTS_DISTINCT_COUNT_CREATED_AT_DESC
  COMMENTS_DISTINCT_COUNT_UPDATED_AT_ASC
  COMMENTS_DISTINCT_COUNT_UPDATED_AT_DESC
  COMMENTS_DISTINCT_COUNT_PARENT_ID_ASC
  COMMENTS_DISTINCT_COUNT_PARENT_ID_DESC
  DOWNVOTES_COUNT_ASC
  DOWNVOTES_COUNT_DESC
  DOWNVOTES_DISTINCT_COUNT_ROW_ID_ASC
  DOWNVOTES_DISTINCT_COUNT_ROW_ID_DESC
  DOWNVOTES_DISTINCT_COUNT_POST_ID_ASC
  DOWNVOTES_DISTINCT_COUNT_POST_ID_DESC
  DOWNVOTES_DISTINCT_COUNT_USER_ID_ASC
  DOWNVOTES_DISTINCT_COUNT_USER_ID_DESC
  DOWNVOTES_DISTINCT_COUNT_CREATED_AT_ASC
  DOWNVOTES_DISTINCT_COUNT_CREATED_AT_DESC
  DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_ASC
  DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""A connection to a list of \`Upvote\` values."""
type UpvoteConnection {
  """A list of \`Upvote\` objects."""
  nodes: [Upvote]!

  """
  A list of edges which contains the \`Upvote\` and cursor to aid in pagination.
  """
  edges: [UpvoteEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Upvote\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: UpvoteAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Upvote\` for these aggregates."""
    groupBy: [UpvoteGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: UpvoteHavingInput
  ): [UpvoteAggregates!]
}

type Upvote {
  rowId: UUID!
  postId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Post\` that is related to this \`Upvote\`."""
  post: Post

  """Reads a single \`User\` that is related to this \`Upvote\`."""
  user: User
}

"""A \`Upvote\` edge in the connection."""
type UpvoteEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Upvote\` at the end of the edge."""
  node: Upvote
}

type UpvoteAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: UpvoteDistinctCountAggregates
}

type UpvoteDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of postId across the matching connection"""
  postId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for \`Upvote\` for usage during aggregation."""
enum UpvoteGroupBy {
  POST_ID
  USER_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`Upvote\` aggregates."""
input UpvoteHavingInput {
  AND: [UpvoteHavingInput!]
  OR: [UpvoteHavingInput!]
  sum: UpvoteHavingSumInput
  distinctCount: UpvoteHavingDistinctCountInput
  min: UpvoteHavingMinInput
  max: UpvoteHavingMaxInput
  average: UpvoteHavingAverageInput
  stddevSample: UpvoteHavingStddevSampleInput
  stddevPopulation: UpvoteHavingStddevPopulationInput
  varianceSample: UpvoteHavingVarianceSampleInput
  variancePopulation: UpvoteHavingVariancePopulationInput
}

input UpvoteHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UpvoteHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against \`Upvote\` object types. All fields are tested for equality and combined with a logical and.
"""
input UpvoteCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`postId\` field."""
  postId: UUID

  """Checks for equality with the objects \`userId\` field."""
  userId: UUID

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering \`Upvote\`."""
enum UpvoteOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  POST_ID_ASC
  POST_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""
A condition to be used against \`Member\` object types. All fields are tested for equality and combined with a logical and.
"""
input MemberCondition {
  """Checks for equality with the objects \`userId\` field."""
  userId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`role\` field."""
  role: Role

  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID
}

"""Methods to use when ordering \`Member\`."""
enum MemberOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ROLE_ASC
  ROLE_DESC
  ROW_ID_ASC
  ROW_ID_DESC
}

"""A connection to a list of \`Comment\` values."""
type CommentConnection {
  """A list of \`Comment\` objects."""
  nodes: [Comment]!

  """
  A list of edges which contains the \`Comment\` and cursor to aid in pagination.
  """
  edges: [CommentEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Comment\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: CommentAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Comment\` for these aggregates."""
    groupBy: [CommentGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: CommentHavingInput
  ): [CommentAggregates!]
}

type Comment {
  rowId: UUID!
  message: String
  postId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
  parentId: UUID

  """Reads a single \`Comment\` that is related to this \`Comment\`."""
  parent: Comment

  """Reads a single \`Post\` that is related to this \`Comment\`."""
  post: Post

  """Reads a single \`User\` that is related to this \`Comment\`."""
  user: User

  """Reads and enables pagination through a set of \`Comment\`."""
  childComments(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CommentFilter

    """The method to use when ordering \`Comment\`."""
    orderBy: [CommentOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentConnection!
}

"""
A condition to be used against \`Comment\` object types. All fields are tested for equality and combined with a logical and.
"""
input CommentCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`message\` field."""
  message: String

  """Checks for equality with the objects \`postId\` field."""
  postId: UUID

  """Checks for equality with the objects \`userId\` field."""
  userId: UUID

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime

  """Checks for equality with the objects \`parentId\` field."""
  parentId: UUID
}

"""Methods to use when ordering \`Comment\`."""
enum CommentOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  MESSAGE_ASC
  MESSAGE_DESC
  POST_ID_ASC
  POST_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  CHILD_COMMENTS_COUNT_ASC
  CHILD_COMMENTS_COUNT_DESC
  CHILD_COMMENTS_DISTINCT_COUNT_ROW_ID_ASC
  CHILD_COMMENTS_DISTINCT_COUNT_ROW_ID_DESC
  CHILD_COMMENTS_DISTINCT_COUNT_MESSAGE_ASC
  CHILD_COMMENTS_DISTINCT_COUNT_MESSAGE_DESC
  CHILD_COMMENTS_DISTINCT_COUNT_POST_ID_ASC
  CHILD_COMMENTS_DISTINCT_COUNT_POST_ID_DESC
  CHILD_COMMENTS_DISTINCT_COUNT_USER_ID_ASC
  CHILD_COMMENTS_DISTINCT_COUNT_USER_ID_DESC
  CHILD_COMMENTS_DISTINCT_COUNT_CREATED_AT_ASC
  CHILD_COMMENTS_DISTINCT_COUNT_CREATED_AT_DESC
  CHILD_COMMENTS_DISTINCT_COUNT_UPDATED_AT_ASC
  CHILD_COMMENTS_DISTINCT_COUNT_UPDATED_AT_DESC
  CHILD_COMMENTS_DISTINCT_COUNT_PARENT_ID_ASC
  CHILD_COMMENTS_DISTINCT_COUNT_PARENT_ID_DESC
}

"""A \`Comment\` edge in the connection."""
type CommentEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Comment\` at the end of the edge."""
  node: Comment
}

type CommentAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: CommentDistinctCountAggregates
}

type CommentDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of message across the matching connection"""
  message: BigInt

  """Distinct count of postId across the matching connection"""
  postId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of parentId across the matching connection"""
  parentId: BigInt
}

"""Grouping methods for \`Comment\` for usage during aggregation."""
enum CommentGroupBy {
  MESSAGE
  POST_ID
  USER_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  PARENT_ID
}

"""Conditions for \`Comment\` aggregates."""
input CommentHavingInput {
  AND: [CommentHavingInput!]
  OR: [CommentHavingInput!]
  sum: CommentHavingSumInput
  distinctCount: CommentHavingDistinctCountInput
  min: CommentHavingMinInput
  max: CommentHavingMaxInput
  average: CommentHavingAverageInput
  stddevSample: CommentHavingStddevSampleInput
  stddevPopulation: CommentHavingStddevPopulationInput
  varianceSample: CommentHavingVarianceSampleInput
  variancePopulation: CommentHavingVariancePopulationInput
}

input CommentHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input CommentHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""A connection to a list of \`Downvote\` values."""
type DownvoteConnection {
  """A list of \`Downvote\` objects."""
  nodes: [Downvote]!

  """
  A list of edges which contains the \`Downvote\` and cursor to aid in pagination.
  """
  edges: [DownvoteEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Downvote\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: DownvoteAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Downvote\` for these aggregates."""
    groupBy: [DownvoteGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: DownvoteHavingInput
  ): [DownvoteAggregates!]
}

"""A \`Downvote\` edge in the connection."""
type DownvoteEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Downvote\` at the end of the edge."""
  node: Downvote
}

type DownvoteAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: DownvoteDistinctCountAggregates
}

type DownvoteDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of postId across the matching connection"""
  postId: BigInt

  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for \`Downvote\` for usage during aggregation."""
enum DownvoteGroupBy {
  POST_ID
  USER_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`Downvote\` aggregates."""
input DownvoteHavingInput {
  AND: [DownvoteHavingInput!]
  OR: [DownvoteHavingInput!]
  sum: DownvoteHavingSumInput
  distinctCount: DownvoteHavingDistinctCountInput
  min: DownvoteHavingMinInput
  max: DownvoteHavingMaxInput
  average: DownvoteHavingAverageInput
  stddevSample: DownvoteHavingStddevSampleInput
  stddevPopulation: DownvoteHavingStddevPopulationInput
  varianceSample: DownvoteHavingVarianceSampleInput
  variancePopulation: DownvoteHavingVariancePopulationInput
}

input DownvoteHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input DownvoteHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against \`Downvote\` object types. All fields are tested
for equality and combined with a logical and.
"""
input DownvoteCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`postId\` field."""
  postId: UUID

  """Checks for equality with the objects \`userId\` field."""
  userId: UUID

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering \`Downvote\`."""
enum DownvoteOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  POST_ID_ASC
  POST_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""A \`Member\` edge in the connection."""
type MemberEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Member\` at the end of the edge."""
  node: Member
}

type MemberAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: MemberDistinctCountAggregates
}

type MemberDistinctCountAggregates {
  """Distinct count of userId across the matching connection"""
  userId: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of role across the matching connection"""
  role: BigInt

  """Distinct count of rowId across the matching connection"""
  rowId: BigInt
}

"""Grouping methods for \`Member\` for usage during aggregation."""
enum MemberGroupBy {
  USER_ID
  ORGANIZATION_ID
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  ROLE
}

"""Conditions for \`Member\` aggregates."""
input MemberHavingInput {
  AND: [MemberHavingInput!]
  OR: [MemberHavingInput!]
  sum: MemberHavingSumInput
  distinctCount: MemberHavingDistinctCountInput
  min: MemberHavingMinInput
  max: MemberHavingMaxInput
  average: MemberHavingAverageInput
  stddevSample: MemberHavingStddevSampleInput
  stddevPopulation: MemberHavingStddevPopulationInput
  varianceSample: MemberHavingVarianceSampleInput
  variancePopulation: MemberHavingVariancePopulationInput
}

input MemberHavingSumInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingMinInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingMaxInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingAverageInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
}

input MemberHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
}

"""A connection to a list of \`Invitation\` values."""
type InvitationConnection {
  """A list of \`Invitation\` objects."""
  nodes: [Invitation]!

  """
  A list of edges which contains the \`Invitation\` and cursor to aid in pagination.
  """
  edges: [InvitationEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Invitation\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: InvitationAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Invitation\` for these aggregates."""
    groupBy: [InvitationGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: InvitationHavingInput
  ): [InvitationAggregates!]
}

type Invitation {
  rowId: UUID!
  organizationId: UUID!
  email: String!
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Organization\` that is related to this \`Invitation\`."""
  organization: Organization
}

"""A \`Invitation\` edge in the connection."""
type InvitationEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Invitation\` at the end of the edge."""
  node: Invitation
}

type InvitationAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: InvitationDistinctCountAggregates
}

type InvitationDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of organizationId across the matching connection"""
  organizationId: BigInt

  """Distinct count of email across the matching connection"""
  email: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for \`Invitation\` for usage during aggregation."""
enum InvitationGroupBy {
  ORGANIZATION_ID
  EMAIL
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`Invitation\` aggregates."""
input InvitationHavingInput {
  AND: [InvitationHavingInput!]
  OR: [InvitationHavingInput!]
  sum: InvitationHavingSumInput
  distinctCount: InvitationHavingDistinctCountInput
  min: InvitationHavingMinInput
  max: InvitationHavingMaxInput
  average: InvitationHavingAverageInput
  stddevSample: InvitationHavingStddevSampleInput
  stddevPopulation: InvitationHavingStddevPopulationInput
  varianceSample: InvitationHavingVarianceSampleInput
  variancePopulation: InvitationHavingVariancePopulationInput
}

input InvitationHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input InvitationHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against \`Invitation\` object types. All fields are tested
for equality and combined with a logical and.
"""
input InvitationCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`organizationId\` field."""
  organizationId: UUID

  """Checks for equality with the objects \`email\` field."""
  email: String

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering \`Invitation\`."""
enum InvitationOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  ORGANIZATION_ID_ASC
  ORGANIZATION_ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""A connection to a list of \`PostStatus\` values."""
type PostStatusConnection {
  """A list of \`PostStatus\` objects."""
  nodes: [PostStatus]!

  """
  A list of edges which contains the \`PostStatus\` and cursor to aid in pagination.
  """
  edges: [PostStatusEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`PostStatus\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: PostStatusAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`PostStatus\` for these aggregates."""
    groupBy: [PostStatusGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: PostStatusHavingInput
  ): [PostStatusAggregates!]
}

type PostStatus {
  rowId: UUID!
  status: String!
  description: String
  color: String
  projectId: UUID!
  isDefault: Boolean!
  createdAt: Datetime
  updatedAt: Datetime

  """Reads a single \`Project\` that is related to this \`PostStatus\`."""
  project: Project

  """Reads and enables pagination through a set of \`Post\`."""
  postsByStatusId(
    """Only read the first \`n\` values of the set."""
    first: Int

    """Only read the last \`n\` values of the set."""
    last: Int

    """
    Skip the first \`n\` values from our \`after\` cursor, an alternative to cursor
    based pagination. May not be used with \`last\`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PostCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PostFilter

    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostConnection!
}

"""A \`PostStatus\` edge in the connection."""
type PostStatusEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`PostStatus\` at the end of the edge."""
  node: PostStatus
}

type PostStatusAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: PostStatusDistinctCountAggregates
}

type PostStatusDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of status across the matching connection"""
  status: BigInt

  """Distinct count of description across the matching connection"""
  description: BigInt

  """Distinct count of color across the matching connection"""
  color: BigInt

  """Distinct count of projectId across the matching connection"""
  projectId: BigInt

  """Distinct count of isDefault across the matching connection"""
  isDefault: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for \`PostStatus\` for usage during aggregation."""
enum PostStatusGroupBy {
  STATUS
  DESCRIPTION
  COLOR
  PROJECT_ID
  IS_DEFAULT
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`PostStatus\` aggregates."""
input PostStatusHavingInput {
  AND: [PostStatusHavingInput!]
  OR: [PostStatusHavingInput!]
  sum: PostStatusHavingSumInput
  distinctCount: PostStatusHavingDistinctCountInput
  min: PostStatusHavingMinInput
  max: PostStatusHavingMaxInput
  average: PostStatusHavingAverageInput
  stddevSample: PostStatusHavingStddevSampleInput
  stddevPopulation: PostStatusHavingStddevPopulationInput
  varianceSample: PostStatusHavingVarianceSampleInput
  variancePopulation: PostStatusHavingVariancePopulationInput
}

input PostStatusHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input PostStatusHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against \`PostStatus\` object types. All fields are tested
for equality and combined with a logical and.
"""
input PostStatusCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`status\` field."""
  status: String

  """Checks for equality with the objects \`description\` field."""
  description: String

  """Checks for equality with the objects \`color\` field."""
  color: String

  """Checks for equality with the objects \`projectId\` field."""
  projectId: UUID

  """Checks for equality with the objects \`isDefault\` field."""
  isDefault: Boolean

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering \`PostStatus\`."""
enum PostStatusOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  STATUS_ASC
  STATUS_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  COLOR_ASC
  COLOR_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  IS_DEFAULT_ASC
  IS_DEFAULT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  POSTS_BY_STATUS_ID_COUNT_ASC
  POSTS_BY_STATUS_ID_COUNT_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_ROW_ID_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_ROW_ID_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_TITLE_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_TITLE_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_DESCRIPTION_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_DESCRIPTION_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_PROJECT_ID_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_PROJECT_ID_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_USER_ID_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_USER_ID_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_CREATED_AT_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_CREATED_AT_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_UPDATED_AT_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_UPDATED_AT_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_ID_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_ID_DESC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_UPDATED_AT_ASC
  POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_UPDATED_AT_DESC
}

"""A connection to a list of \`Organization\` values."""
type OrganizationConnection {
  """A list of \`Organization\` objects."""
  nodes: [Organization]!

  """
  A list of edges which contains the \`Organization\` and cursor to aid in pagination.
  """
  edges: [OrganizationEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`Organization\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: OrganizationAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`Organization\` for these aggregates."""
    groupBy: [OrganizationGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: OrganizationHavingInput
  ): [OrganizationAggregates!]
}

"""A \`Organization\` edge in the connection."""
type OrganizationEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`Organization\` at the end of the edge."""
  node: Organization
}

type OrganizationAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: OrganizationDistinctCountAggregates
}

type OrganizationDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of name across the matching connection"""
  name: BigInt

  """Distinct count of slug across the matching connection"""
  slug: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt
}

"""Grouping methods for \`Organization\` for usage during aggregation."""
enum OrganizationGroupBy {
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
}

"""Conditions for \`Organization\` aggregates."""
input OrganizationHavingInput {
  AND: [OrganizationHavingInput!]
  OR: [OrganizationHavingInput!]
  sum: OrganizationHavingSumInput
  distinctCount: OrganizationHavingDistinctCountInput
  min: OrganizationHavingMinInput
  max: OrganizationHavingMaxInput
  average: OrganizationHavingAverageInput
  stddevSample: OrganizationHavingStddevSampleInput
  stddevPopulation: OrganizationHavingStddevPopulationInput
  varianceSample: OrganizationHavingVarianceSampleInput
  variancePopulation: OrganizationHavingVariancePopulationInput
}

input OrganizationHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input OrganizationHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against \`Organization\` object types. All fields are
tested for equality and combined with a logical and.
"""
input OrganizationCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`name\` field."""
  name: String

  """Checks for equality with the objects \`slug\` field."""
  slug: String

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime
}

"""Methods to use when ordering \`Organization\`."""
enum OrganizationOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  NAME_ASC
  NAME_DESC
  SLUG_ASC
  SLUG_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PROJECTS_COUNT_ASC
  PROJECTS_COUNT_DESC
  PROJECTS_DISTINCT_COUNT_ROW_ID_ASC
  PROJECTS_DISTINCT_COUNT_ROW_ID_DESC
  PROJECTS_DISTINCT_COUNT_NAME_ASC
  PROJECTS_DISTINCT_COUNT_NAME_DESC
  PROJECTS_DISTINCT_COUNT_IMAGE_ASC
  PROJECTS_DISTINCT_COUNT_IMAGE_DESC
  PROJECTS_DISTINCT_COUNT_SLUG_ASC
  PROJECTS_DISTINCT_COUNT_SLUG_DESC
  PROJECTS_DISTINCT_COUNT_DESCRIPTION_ASC
  PROJECTS_DISTINCT_COUNT_DESCRIPTION_DESC
  PROJECTS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  PROJECTS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  PROJECTS_DISTINCT_COUNT_CREATED_AT_ASC
  PROJECTS_DISTINCT_COUNT_CREATED_AT_DESC
  PROJECTS_DISTINCT_COUNT_UPDATED_AT_ASC
  PROJECTS_DISTINCT_COUNT_UPDATED_AT_DESC
  MEMBERS_COUNT_ASC
  MEMBERS_COUNT_DESC
  MEMBERS_DISTINCT_COUNT_USER_ID_ASC
  MEMBERS_DISTINCT_COUNT_USER_ID_DESC
  MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  MEMBERS_DISTINCT_COUNT_CREATED_AT_ASC
  MEMBERS_DISTINCT_COUNT_CREATED_AT_DESC
  MEMBERS_DISTINCT_COUNT_ROLE_ASC
  MEMBERS_DISTINCT_COUNT_ROLE_DESC
  MEMBERS_DISTINCT_COUNT_ROW_ID_ASC
  MEMBERS_DISTINCT_COUNT_ROW_ID_DESC
  INVITATIONS_COUNT_ASC
  INVITATIONS_COUNT_DESC
  INVITATIONS_DISTINCT_COUNT_ROW_ID_ASC
  INVITATIONS_DISTINCT_COUNT_ROW_ID_DESC
  INVITATIONS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  INVITATIONS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  INVITATIONS_DISTINCT_COUNT_EMAIL_ASC
  INVITATIONS_DISTINCT_COUNT_EMAIL_DESC
  INVITATIONS_DISTINCT_COUNT_CREATED_AT_ASC
  INVITATIONS_DISTINCT_COUNT_CREATED_AT_DESC
  INVITATIONS_DISTINCT_COUNT_UPDATED_AT_ASC
  INVITATIONS_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""A connection to a list of \`User\` values."""
type UserConnection {
  """A list of \`User\` objects."""
  nodes: [User]!

  """
  A list of edges which contains the \`User\` and cursor to aid in pagination.
  """
  edges: [UserEdge]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* \`User\` you could get from the connection."""
  totalCount: Int!

  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: UserAggregates

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """The method to use when grouping \`User\` for these aggregates."""
    groupBy: [UserGroupBy!]!

    """Conditions on the grouped aggregates."""
    having: UserHavingInput
  ): [UserAggregates!]
}

"""A \`User\` edge in the connection."""
type UserEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The \`User\` at the end of the edge."""
  node: User
}

type UserAggregates {
  keys: [String]

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: UserDistinctCountAggregates
}

type UserDistinctCountAggregates {
  """Distinct count of rowId across the matching connection"""
  rowId: BigInt

  """Distinct count of createdAt across the matching connection"""
  createdAt: BigInt

  """Distinct count of updatedAt across the matching connection"""
  updatedAt: BigInt

  """Distinct count of hidraId across the matching connection"""
  hidraId: BigInt

  """Distinct count of username across the matching connection"""
  username: BigInt

  """Distinct count of firstName across the matching connection"""
  firstName: BigInt

  """Distinct count of lastName across the matching connection"""
  lastName: BigInt

  """Distinct count of email across the matching connection"""
  email: BigInt

  """Distinct count of tier across the matching connection"""
  tier: BigInt
}

"""Grouping methods for \`User\` for usage during aggregation."""
enum UserGroupBy {
  CREATED_AT
  CREATED_AT_TRUNCATED_TO_HOUR
  CREATED_AT_TRUNCATED_TO_DAY
  UPDATED_AT
  UPDATED_AT_TRUNCATED_TO_HOUR
  UPDATED_AT_TRUNCATED_TO_DAY
  FIRST_NAME
  LAST_NAME
  TIER
}

"""Conditions for \`User\` aggregates."""
input UserHavingInput {
  AND: [UserHavingInput!]
  OR: [UserHavingInput!]
  sum: UserHavingSumInput
  distinctCount: UserHavingDistinctCountInput
  min: UserHavingMinInput
  max: UserHavingMaxInput
  average: UserHavingAverageInput
  stddevSample: UserHavingStddevSampleInput
  stddevPopulation: UserHavingStddevPopulationInput
  varianceSample: UserHavingVarianceSampleInput
  variancePopulation: UserHavingVariancePopulationInput
}

input UserHavingSumInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingDistinctCountInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingMinInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingMaxInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingAverageInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingStddevSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingStddevPopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingVarianceSampleInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

input UserHavingVariancePopulationInput {
  createdAt: HavingDatetimeFilter
  updatedAt: HavingDatetimeFilter
}

"""
A condition to be used against \`User\` object types. All fields are tested for equality and combined with a logical and.
"""
input UserCondition {
  """Checks for equality with the objects \`rowId\` field."""
  rowId: UUID

  """Checks for equality with the objects \`createdAt\` field."""
  createdAt: Datetime

  """Checks for equality with the objects \`updatedAt\` field."""
  updatedAt: Datetime

  """Checks for equality with the objects \`hidraId\` field."""
  hidraId: UUID

  """Checks for equality with the objects \`username\` field."""
  username: String

  """Checks for equality with the objects \`firstName\` field."""
  firstName: String

  """Checks for equality with the objects \`lastName\` field."""
  lastName: String

  """Checks for equality with the objects \`email\` field."""
  email: String

  """Checks for equality with the objects \`tier\` field."""
  tier: Tier
}

"""Methods to use when ordering \`User\`."""
enum UserOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROW_ID_ASC
  ROW_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  HIDRA_ID_ASC
  HIDRA_ID_DESC
  USERNAME_ASC
  USERNAME_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  TIER_ASC
  TIER_DESC
  POSTS_COUNT_ASC
  POSTS_COUNT_DESC
  POSTS_DISTINCT_COUNT_ROW_ID_ASC
  POSTS_DISTINCT_COUNT_ROW_ID_DESC
  POSTS_DISTINCT_COUNT_TITLE_ASC
  POSTS_DISTINCT_COUNT_TITLE_DESC
  POSTS_DISTINCT_COUNT_DESCRIPTION_ASC
  POSTS_DISTINCT_COUNT_DESCRIPTION_DESC
  POSTS_DISTINCT_COUNT_PROJECT_ID_ASC
  POSTS_DISTINCT_COUNT_PROJECT_ID_DESC
  POSTS_DISTINCT_COUNT_USER_ID_ASC
  POSTS_DISTINCT_COUNT_USER_ID_DESC
  POSTS_DISTINCT_COUNT_CREATED_AT_ASC
  POSTS_DISTINCT_COUNT_CREATED_AT_DESC
  POSTS_DISTINCT_COUNT_UPDATED_AT_ASC
  POSTS_DISTINCT_COUNT_UPDATED_AT_DESC
  POSTS_DISTINCT_COUNT_STATUS_ID_ASC
  POSTS_DISTINCT_COUNT_STATUS_ID_DESC
  POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_ASC
  POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_DESC
  UPVOTES_COUNT_ASC
  UPVOTES_COUNT_DESC
  UPVOTES_DISTINCT_COUNT_ROW_ID_ASC
  UPVOTES_DISTINCT_COUNT_ROW_ID_DESC
  UPVOTES_DISTINCT_COUNT_POST_ID_ASC
  UPVOTES_DISTINCT_COUNT_POST_ID_DESC
  UPVOTES_DISTINCT_COUNT_USER_ID_ASC
  UPVOTES_DISTINCT_COUNT_USER_ID_DESC
  UPVOTES_DISTINCT_COUNT_CREATED_AT_ASC
  UPVOTES_DISTINCT_COUNT_CREATED_AT_DESC
  UPVOTES_DISTINCT_COUNT_UPDATED_AT_ASC
  UPVOTES_DISTINCT_COUNT_UPDATED_AT_DESC
  MEMBERS_COUNT_ASC
  MEMBERS_COUNT_DESC
  MEMBERS_DISTINCT_COUNT_USER_ID_ASC
  MEMBERS_DISTINCT_COUNT_USER_ID_DESC
  MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_ASC
  MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_DESC
  MEMBERS_DISTINCT_COUNT_CREATED_AT_ASC
  MEMBERS_DISTINCT_COUNT_CREATED_AT_DESC
  MEMBERS_DISTINCT_COUNT_ROLE_ASC
  MEMBERS_DISTINCT_COUNT_ROLE_DESC
  MEMBERS_DISTINCT_COUNT_ROW_ID_ASC
  MEMBERS_DISTINCT_COUNT_ROW_ID_DESC
  COMMENTS_COUNT_ASC
  COMMENTS_COUNT_DESC
  COMMENTS_DISTINCT_COUNT_ROW_ID_ASC
  COMMENTS_DISTINCT_COUNT_ROW_ID_DESC
  COMMENTS_DISTINCT_COUNT_MESSAGE_ASC
  COMMENTS_DISTINCT_COUNT_MESSAGE_DESC
  COMMENTS_DISTINCT_COUNT_POST_ID_ASC
  COMMENTS_DISTINCT_COUNT_POST_ID_DESC
  COMMENTS_DISTINCT_COUNT_USER_ID_ASC
  COMMENTS_DISTINCT_COUNT_USER_ID_DESC
  COMMENTS_DISTINCT_COUNT_CREATED_AT_ASC
  COMMENTS_DISTINCT_COUNT_CREATED_AT_DESC
  COMMENTS_DISTINCT_COUNT_UPDATED_AT_ASC
  COMMENTS_DISTINCT_COUNT_UPDATED_AT_DESC
  COMMENTS_DISTINCT_COUNT_PARENT_ID_ASC
  COMMENTS_DISTINCT_COUNT_PARENT_ID_DESC
  DOWNVOTES_COUNT_ASC
  DOWNVOTES_COUNT_DESC
  DOWNVOTES_DISTINCT_COUNT_ROW_ID_ASC
  DOWNVOTES_DISTINCT_COUNT_ROW_ID_DESC
  DOWNVOTES_DISTINCT_COUNT_POST_ID_ASC
  DOWNVOTES_DISTINCT_COUNT_POST_ID_DESC
  DOWNVOTES_DISTINCT_COUNT_USER_ID_ASC
  DOWNVOTES_DISTINCT_COUNT_USER_ID_DESC
  DOWNVOTES_DISTINCT_COUNT_CREATED_AT_ASC
  DOWNVOTES_DISTINCT_COUNT_CREATED_AT_DESC
  DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_ASC
  DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_DESC
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single \`Downvote\`."""
  createDownvote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateDownvoteInput!
  ): CreateDownvotePayload

  """Creates a single \`Upvote\`."""
  createUpvote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUpvoteInput!
  ): CreateUpvotePayload

  """Creates a single \`Invitation\`."""
  createInvitation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateInvitationInput!
  ): CreateInvitationPayload

  """Creates a single \`Organization\`."""
  createOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateOrganizationInput!
  ): CreateOrganizationPayload

  """Creates a single \`Comment\`."""
  createComment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateCommentInput!
  ): CreateCommentPayload

  """Creates a single \`Project\`."""
  createProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateProjectInput!
  ): CreateProjectPayload

  """Creates a single \`Member\`."""
  createMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateMemberInput!
  ): CreateMemberPayload

  """Creates a single \`Post\`."""
  createPost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreatePostInput!
  ): CreatePostPayload

  """Creates a single \`PostStatus\`."""
  createPostStatus(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreatePostStatusInput!
  ): CreatePostStatusPayload

  """Creates a single \`User\`."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """Updates a single \`Downvote\` using a unique key and a patch."""
  updateDownvote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateDownvoteInput!
  ): UpdateDownvotePayload

  """Updates a single \`Upvote\` using a unique key and a patch."""
  updateUpvote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUpvoteInput!
  ): UpdateUpvotePayload

  """Updates a single \`Invitation\` using a unique key and a patch."""
  updateInvitation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateInvitationInput!
  ): UpdateInvitationPayload

  """Updates a single \`Organization\` using a unique key and a patch."""
  updateOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateOrganizationInput!
  ): UpdateOrganizationPayload

  """Updates a single \`Comment\` using a unique key and a patch."""
  updateComment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateCommentInput!
  ): UpdateCommentPayload

  """Updates a single \`Project\` using a unique key and a patch."""
  updateProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateProjectInput!
  ): UpdateProjectPayload

  """Updates a single \`Member\` using a unique key and a patch."""
  updateMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateMemberInput!
  ): UpdateMemberPayload

  """Updates a single \`Post\` using a unique key and a patch."""
  updatePost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePostInput!
  ): UpdatePostPayload

  """Updates a single \`PostStatus\` using a unique key and a patch."""
  updatePostStatus(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdatePostStatusInput!
  ): UpdatePostStatusPayload

  """Updates a single \`User\` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """Deletes a single \`Downvote\` using a unique key."""
  deleteDownvote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteDownvoteInput!
  ): DeleteDownvotePayload

  """Deletes a single \`Upvote\` using a unique key."""
  deleteUpvote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUpvoteInput!
  ): DeleteUpvotePayload

  """Deletes a single \`Invitation\` using a unique key."""
  deleteInvitation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteInvitationInput!
  ): DeleteInvitationPayload

  """Deletes a single \`Organization\` using a unique key."""
  deleteOrganization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteOrganizationInput!
  ): DeleteOrganizationPayload

  """Deletes a single \`Comment\` using a unique key."""
  deleteComment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteCommentInput!
  ): DeleteCommentPayload

  """Deletes a single \`Project\` using a unique key."""
  deleteProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteProjectInput!
  ): DeleteProjectPayload

  """Deletes a single \`Member\` using a unique key."""
  deleteMember(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteMemberInput!
  ): DeleteMemberPayload

  """Deletes a single \`Post\` using a unique key."""
  deletePost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePostInput!
  ): DeletePostPayload

  """Deletes a single \`PostStatus\` using a unique key."""
  deletePostStatus(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeletePostStatusInput!
  ): DeletePostStatusPayload

  """Deletes a single \`User\` using a unique key."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload
}

"""The output of our create \`Downvote\` mutation."""
type CreateDownvotePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Downvote\` that was created by this mutation."""
  downvote: Downvote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Downvote\`. May be used by Relay 1."""
  downvoteEdge(
    """The method to use when ordering \`Downvote\`."""
    orderBy: [DownvoteOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DownvoteEdge
}

"""All input for the create \`Downvote\` mutation."""
input CreateDownvoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Downvote\` to be created by this mutation."""
  downvote: DownvoteInput!
}

"""An input for mutations affecting \`Downvote\`"""
input DownvoteInput {
  rowId: UUID
  postId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`Upvote\` mutation."""
type CreateUpvotePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Upvote\` that was created by this mutation."""
  upvote: Upvote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Upvote\`. May be used by Relay 1."""
  upvoteEdge(
    """The method to use when ordering \`Upvote\`."""
    orderBy: [UpvoteOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UpvoteEdge
}

"""All input for the create \`Upvote\` mutation."""
input CreateUpvoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Upvote\` to be created by this mutation."""
  upvote: UpvoteInput!
}

"""An input for mutations affecting \`Upvote\`"""
input UpvoteInput {
  rowId: UUID
  postId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`Invitation\` mutation."""
type CreateInvitationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Invitation\` that was created by this mutation."""
  invitation: Invitation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Invitation\`. May be used by Relay 1."""
  invitationEdge(
    """The method to use when ordering \`Invitation\`."""
    orderBy: [InvitationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): InvitationEdge
}

"""All input for the create \`Invitation\` mutation."""
input CreateInvitationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Invitation\` to be created by this mutation."""
  invitation: InvitationInput!
}

"""An input for mutations affecting \`Invitation\`"""
input InvitationInput {
  rowId: UUID
  organizationId: UUID!
  email: String!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`Organization\` mutation."""
type CreateOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Organization\` that was created by this mutation."""
  organization: Organization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Organization\`. May be used by Relay 1."""
  organizationEdge(
    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): OrganizationEdge
}

"""All input for the create \`Organization\` mutation."""
input CreateOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Organization\` to be created by this mutation."""
  organization: OrganizationInput!
}

"""An input for mutations affecting \`Organization\`"""
input OrganizationInput {
  rowId: UUID
  name: String!
  slug: String!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`Comment\` mutation."""
type CreateCommentPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Comment\` that was created by this mutation."""
  comment: Comment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Comment\`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering \`Comment\`."""
    orderBy: [CommentOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CommentEdge
}

"""All input for the create \`Comment\` mutation."""
input CreateCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Comment\` to be created by this mutation."""
  comment: CommentInput!
}

"""An input for mutations affecting \`Comment\`"""
input CommentInput {
  rowId: UUID
  message: String
  postId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
  parentId: UUID
}

"""The output of our create \`Project\` mutation."""
type CreateProjectPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Project\` that was created by this mutation."""
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Project\`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering \`Project\`."""
    orderBy: [ProjectOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectEdge
}

"""All input for the create \`Project\` mutation."""
input CreateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Project\` to be created by this mutation."""
  project: ProjectInput!
}

"""An input for mutations affecting \`Project\`"""
input ProjectInput {
  rowId: UUID
  name: String!
  image: String
  slug: String!
  description: String
  organizationId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`Member\` mutation."""
type CreateMemberPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Member\` that was created by this mutation."""
  member: Member

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Member\`. May be used by Relay 1."""
  memberEdge(
    """The method to use when ordering \`Member\`."""
    orderBy: [MemberOrderBy!]! = [PRIMARY_KEY_ASC]
  ): MemberEdge
}

"""All input for the create \`Member\` mutation."""
input CreateMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Member\` to be created by this mutation."""
  member: MemberInput!
}

"""An input for mutations affecting \`Member\`"""
input MemberInput {
  userId: UUID!
  organizationId: UUID!
  createdAt: Datetime
  role: Role!
  rowId: UUID
}

"""The output of our create \`Post\` mutation."""
type CreatePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was created by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the create \`Post\` mutation."""
input CreatePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`Post\` to be created by this mutation."""
  post: PostInput!
}

"""An input for mutations affecting \`Post\`"""
input PostInput {
  rowId: UUID
  title: String
  description: String
  projectId: UUID!
  userId: UUID!
  createdAt: Datetime
  updatedAt: Datetime
  statusId: UUID
  statusUpdatedAt: Datetime
}

"""The output of our create \`PostStatus\` mutation."""
type CreatePostStatusPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`PostStatus\` that was created by this mutation."""
  postStatus: PostStatus

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`PostStatus\`. May be used by Relay 1."""
  postStatusEdge(
    """The method to use when ordering \`PostStatus\`."""
    orderBy: [PostStatusOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostStatusEdge
}

"""All input for the create \`PostStatus\` mutation."""
input CreatePostStatusInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`PostStatus\` to be created by this mutation."""
  postStatus: PostStatusInput!
}

"""An input for mutations affecting \`PostStatus\`"""
input PostStatusInput {
  rowId: UUID
  status: String!
  description: String
  color: String
  projectId: UUID!
  isDefault: Boolean
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create \`User\` mutation."""
type CreateUserPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`User\` that was created by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`User\`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering \`User\`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the create \`User\` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The \`User\` to be created by this mutation."""
  user: UserInput!
}

"""An input for mutations affecting \`User\`"""
input UserInput {
  rowId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  hidraId: UUID!
  username: String
  firstName: String
  lastName: String
  email: String!
}

"""The output of our update \`Downvote\` mutation."""
type UpdateDownvotePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Downvote\` that was updated by this mutation."""
  downvote: Downvote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Downvote\`. May be used by Relay 1."""
  downvoteEdge(
    """The method to use when ordering \`Downvote\`."""
    orderBy: [DownvoteOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DownvoteEdge
}

"""All input for the \`updateDownvote\` mutation."""
input UpdateDownvoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Downvote\` being updated.
  """
  patch: DownvotePatch!
}

"""
Represents an update to a \`Downvote\`. Fields that are set will be updated.
"""
input DownvotePatch {
  rowId: UUID
  postId: UUID
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update \`Upvote\` mutation."""
type UpdateUpvotePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Upvote\` that was updated by this mutation."""
  upvote: Upvote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Upvote\`. May be used by Relay 1."""
  upvoteEdge(
    """The method to use when ordering \`Upvote\`."""
    orderBy: [UpvoteOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UpvoteEdge
}

"""All input for the \`updateUpvote\` mutation."""
input UpdateUpvoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Upvote\` being updated.
  """
  patch: UpvotePatch!
}

"""
Represents an update to a \`Upvote\`. Fields that are set will be updated.
"""
input UpvotePatch {
  rowId: UUID
  postId: UUID
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update \`Invitation\` mutation."""
type UpdateInvitationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Invitation\` that was updated by this mutation."""
  invitation: Invitation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Invitation\`. May be used by Relay 1."""
  invitationEdge(
    """The method to use when ordering \`Invitation\`."""
    orderBy: [InvitationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): InvitationEdge
}

"""All input for the \`updateInvitation\` mutation."""
input UpdateInvitationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Invitation\` being updated.
  """
  patch: InvitationPatch!
}

"""
Represents an update to a \`Invitation\`. Fields that are set will be updated.
"""
input InvitationPatch {
  rowId: UUID
  organizationId: UUID
  email: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update \`Organization\` mutation."""
type UpdateOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Organization\` that was updated by this mutation."""
  organization: Organization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Organization\`. May be used by Relay 1."""
  organizationEdge(
    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): OrganizationEdge
}

"""All input for the \`updateOrganization\` mutation."""
input UpdateOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Organization\` being updated.
  """
  patch: OrganizationPatch!
}

"""
Represents an update to a \`Organization\`. Fields that are set will be updated.
"""
input OrganizationPatch {
  rowId: UUID
  name: String
  slug: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update \`Comment\` mutation."""
type UpdateCommentPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Comment\` that was updated by this mutation."""
  comment: Comment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Comment\`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering \`Comment\`."""
    orderBy: [CommentOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CommentEdge
}

"""All input for the \`updateComment\` mutation."""
input UpdateCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Comment\` being updated.
  """
  patch: CommentPatch!
}

"""
Represents an update to a \`Comment\`. Fields that are set will be updated.
"""
input CommentPatch {
  rowId: UUID
  message: String
  postId: UUID
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  parentId: UUID
}

"""The output of our update \`Project\` mutation."""
type UpdateProjectPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Project\` that was updated by this mutation."""
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Project\`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering \`Project\`."""
    orderBy: [ProjectOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectEdge
}

"""All input for the \`updateProject\` mutation."""
input UpdateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Project\` being updated.
  """
  patch: ProjectPatch!
}

"""
Represents an update to a \`Project\`. Fields that are set will be updated.
"""
input ProjectPatch {
  rowId: UUID
  name: String
  image: String
  slug: String
  description: String
  organizationId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update \`Member\` mutation."""
type UpdateMemberPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Member\` that was updated by this mutation."""
  member: Member

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Member\`. May be used by Relay 1."""
  memberEdge(
    """The method to use when ordering \`Member\`."""
    orderBy: [MemberOrderBy!]! = [PRIMARY_KEY_ASC]
  ): MemberEdge
}

"""All input for the \`updateMember\` mutation."""
input UpdateMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Member\` being updated.
  """
  patch: MemberPatch!
}

"""
Represents an update to a \`Member\`. Fields that are set will be updated.
"""
input MemberPatch {
  userId: UUID
  organizationId: UUID
  createdAt: Datetime
  role: Role
  rowId: UUID
}

"""The output of our update \`Post\` mutation."""
type UpdatePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was updated by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the \`updatePost\` mutation."""
input UpdatePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`Post\` being updated.
  """
  patch: PostPatch!
}

"""Represents an update to a \`Post\`. Fields that are set will be updated."""
input PostPatch {
  rowId: UUID
  title: String
  description: String
  projectId: UUID
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  statusId: UUID
  statusUpdatedAt: Datetime
}

"""The output of our update \`PostStatus\` mutation."""
type UpdatePostStatusPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`PostStatus\` that was updated by this mutation."""
  postStatus: PostStatus

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`PostStatus\`. May be used by Relay 1."""
  postStatusEdge(
    """The method to use when ordering \`PostStatus\`."""
    orderBy: [PostStatusOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostStatusEdge
}

"""All input for the \`updatePostStatus\` mutation."""
input UpdatePostStatusInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`PostStatus\` being updated.
  """
  patch: PostStatusPatch!
}

"""
Represents an update to a \`PostStatus\`. Fields that are set will be updated.
"""
input PostStatusPatch {
  rowId: UUID
  status: String
  description: String
  color: String
  projectId: UUID
  isDefault: Boolean
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our update \`User\` mutation."""
type UpdateUserPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`User\` that was updated by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`User\`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering \`User\`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the \`updateUser\` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!

  """
  An object where the defined keys will be set on the \`User\` being updated.
  """
  patch: UserPatch!
}

"""Represents an update to a \`User\`. Fields that are set will be updated."""
input UserPatch {
  rowId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  hidraId: UUID
  username: String
  firstName: String
  lastName: String
  email: String
}

"""The output of our delete \`Downvote\` mutation."""
type DeleteDownvotePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Downvote\` that was deleted by this mutation."""
  downvote: Downvote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Downvote\`. May be used by Relay 1."""
  downvoteEdge(
    """The method to use when ordering \`Downvote\`."""
    orderBy: [DownvoteOrderBy!]! = [PRIMARY_KEY_ASC]
  ): DownvoteEdge
}

"""All input for the \`deleteDownvote\` mutation."""
input DeleteDownvoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Upvote\` mutation."""
type DeleteUpvotePayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Upvote\` that was deleted by this mutation."""
  upvote: Upvote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Upvote\`. May be used by Relay 1."""
  upvoteEdge(
    """The method to use when ordering \`Upvote\`."""
    orderBy: [UpvoteOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UpvoteEdge
}

"""All input for the \`deleteUpvote\` mutation."""
input DeleteUpvoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Invitation\` mutation."""
type DeleteInvitationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Invitation\` that was deleted by this mutation."""
  invitation: Invitation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Invitation\`. May be used by Relay 1."""
  invitationEdge(
    """The method to use when ordering \`Invitation\`."""
    orderBy: [InvitationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): InvitationEdge
}

"""All input for the \`deleteInvitation\` mutation."""
input DeleteInvitationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Organization\` mutation."""
type DeleteOrganizationPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Organization\` that was deleted by this mutation."""
  organization: Organization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Organization\`. May be used by Relay 1."""
  organizationEdge(
    """The method to use when ordering \`Organization\`."""
    orderBy: [OrganizationOrderBy!]! = [PRIMARY_KEY_ASC]
  ): OrganizationEdge
}

"""All input for the \`deleteOrganization\` mutation."""
input DeleteOrganizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Comment\` mutation."""
type DeleteCommentPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Comment\` that was deleted by this mutation."""
  comment: Comment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Comment\`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering \`Comment\`."""
    orderBy: [CommentOrderBy!]! = [PRIMARY_KEY_ASC]
  ): CommentEdge
}

"""All input for the \`deleteComment\` mutation."""
input DeleteCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Project\` mutation."""
type DeleteProjectPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Project\` that was deleted by this mutation."""
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Project\`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering \`Project\`."""
    orderBy: [ProjectOrderBy!]! = [PRIMARY_KEY_ASC]
  ): ProjectEdge
}

"""All input for the \`deleteProject\` mutation."""
input DeleteProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Member\` mutation."""
type DeleteMemberPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Member\` that was deleted by this mutation."""
  member: Member

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Member\`. May be used by Relay 1."""
  memberEdge(
    """The method to use when ordering \`Member\`."""
    orderBy: [MemberOrderBy!]! = [PRIMARY_KEY_ASC]
  ): MemberEdge
}

"""All input for the \`deleteMember\` mutation."""
input DeleteMemberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`Post\` mutation."""
type DeletePostPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`Post\` that was deleted by this mutation."""
  post: Post

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`Post\`. May be used by Relay 1."""
  postEdge(
    """The method to use when ordering \`Post\`."""
    orderBy: [PostOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostEdge
}

"""All input for the \`deletePost\` mutation."""
input DeletePostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`PostStatus\` mutation."""
type DeletePostStatusPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`PostStatus\` that was deleted by this mutation."""
  postStatus: PostStatus

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`PostStatus\`. May be used by Relay 1."""
  postStatusEdge(
    """The method to use when ordering \`PostStatus\`."""
    orderBy: [PostStatusOrderBy!]! = [PRIMARY_KEY_ASC]
  ): PostStatusEdge
}

"""All input for the \`deletePostStatus\` mutation."""
input DeletePostStatusInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete \`User\` mutation."""
type DeleteUserPayload {
  """
  The exact same \`clientMutationId\` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The \`User\` that was deleted by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our \`User\`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering \`User\`."""
    orderBy: [UserOrderBy!]! = [PRIMARY_KEY_ASC]
  ): UserEdge
}

"""All input for the \`deleteUser\` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}`;
export const plans = {
  Query: {
    __assertStep() {
      return !0;
    },
    query() {
      return rootValue();
    },
    id($parent) {
      const specifier = handler.plan($parent);
      return lambda(specifier, nodeIdCodecs[handler.codec.name].encode);
    },
    node(_$root, args) {
      return node(nodeIdHandlerByTypeName, args.getRaw("id"));
    },
    downvote(_$root, {
      $rowId
    }) {
      return resource_downvotePgResource.get({
        id: $rowId
      });
    },
    downvoteByPostIdAndUserId(_$root, {
      $postId,
      $userId
    }) {
      return resource_downvotePgResource.get({
        post_id: $postId,
        user_id: $userId
      });
    },
    upvote(_$root, {
      $rowId
    }) {
      return resource_upvotePgResource.get({
        id: $rowId
      });
    },
    upvoteByPostIdAndUserId(_$root, {
      $postId,
      $userId
    }) {
      return resource_upvotePgResource.get({
        post_id: $postId,
        user_id: $userId
      });
    },
    invitation(_$root, {
      $rowId
    }) {
      return resource_invitationPgResource.get({
        id: $rowId
      });
    },
    invitationByOrganizationIdAndEmail(_$root, {
      $organizationId,
      $email
    }) {
      return resource_invitationPgResource.get({
        organization_id: $organizationId,
        email: $email
      });
    },
    organization(_$root, {
      $rowId
    }) {
      return resource_organizationPgResource.get({
        id: $rowId
      });
    },
    organizationByName(_$root, {
      $name
    }) {
      return resource_organizationPgResource.get({
        name: $name
      });
    },
    organizationBySlug(_$root, {
      $slug
    }) {
      return resource_organizationPgResource.get({
        slug: $slug
      });
    },
    comment(_$root, {
      $rowId
    }) {
      return resource_commentPgResource.get({
        id: $rowId
      });
    },
    project(_$root, {
      $rowId
    }) {
      return resource_projectPgResource.get({
        id: $rowId
      });
    },
    projectBySlugAndOrganizationId(_$root, {
      $slug,
      $organizationId
    }) {
      return resource_projectPgResource.get({
        slug: $slug,
        organization_id: $organizationId
      });
    },
    member(_$root, {
      $rowId
    }) {
      return resource_memberPgResource.get({
        id: $rowId
      });
    },
    memberByUserIdAndOrganizationId(_$root, {
      $userId,
      $organizationId
    }) {
      return resource_memberPgResource.get({
        user_id: $userId,
        organization_id: $organizationId
      });
    },
    post(_$root, {
      $rowId
    }) {
      return resource_postPgResource.get({
        id: $rowId
      });
    },
    postStatus(_$root, {
      $rowId
    }) {
      return resource_post_statusPgResource.get({
        id: $rowId
      });
    },
    user(_$root, {
      $rowId
    }) {
      return resource_userPgResource.get({
        id: $rowId
      });
    },
    userByEmail(_$root, {
      $email
    }) {
      return resource_userPgResource.get({
        email: $email
      });
    },
    userByHidraId(_$root, {
      $hidraId
    }) {
      return resource_userPgResource.get({
        hidra_id: $hidraId
      });
    },
    userByUsername(_$root, {
      $username
    }) {
      return resource_userPgResource.get({
        username: $username
      });
    },
    downvotes: {
      plan() {
        return connection(resource_downvotePgResource.find());
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    upvotes: {
      plan() {
        return connection(resource_upvotePgResource.find());
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed2(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    invitations: {
      plan() {
        return connection(resource_invitationPgResource.find());
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed3(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    organizations: {
      plan() {
        return connection(resource_organizationPgResource.find());
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed4(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    comments: {
      plan() {
        return connection(resource_commentPgResource.find());
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed5(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    projects: {
      plan() {
        return connection(resource_projectPgResource.find());
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed6(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    members: {
      plan() {
        return connection(resource_memberPgResource.find());
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed7(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    posts: {
      plan() {
        return connection(resource_postPgResource.find());
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed8(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    postStatuses: {
      plan() {
        return connection(resource_post_statusPgResource.find());
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed9(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    users: {
      plan() {
        return connection(resource_userPgResource.find());
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed10(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    }
  },
  Downvote: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    postId($record) {
      return $record.get("post_id");
    },
    userId($record) {
      return $record.get("user_id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    post($record) {
      return resource_postPgResource.get({
        id: $record.get("post_id")
      });
    },
    user($record) {
      return resource_userPgResource.get({
        id: $record.get("user_id")
      });
    }
  },
  UUID: {
    serialize: UUIDSerialize,
    parseValue(value) {
      return coerce("" + value);
    },
    parseLiteral(ast) {
      if (ast.kind !== Kind.STRING) throw new GraphQLError(`${"UUID" ?? "This scalar"} can only parse string values (kind = '${ast.kind}')`);
      return coerce(ast.value);
    }
  },
  Datetime: {
    serialize: UUIDSerialize,
    parseValue: UUIDSerialize,
    parseLiteral(ast) {
      if (ast.kind !== Kind.STRING) throw new GraphQLError(`${"Datetime" ?? "This scalar"} can only parse string values (kind='${ast.kind}')`);
      return ast.value;
    }
  },
  Post: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    projectId($record) {
      return $record.get("project_id");
    },
    userId($record) {
      return $record.get("user_id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    statusId($record) {
      return $record.get("status_id");
    },
    statusUpdatedAt($record) {
      return $record.get("status_updated_at");
    },
    project($record) {
      return resource_projectPgResource.get({
        id: $record.get("project_id")
      });
    },
    status($record) {
      return resource_post_statusPgResource.get({
        id: $record.get("status_id")
      });
    },
    user($record) {
      return resource_userPgResource.get({
        id: $record.get("user_id")
      });
    },
    upvotes: {
      plan($record) {
        const $records = resource_upvotePgResource.find({
          post_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed11(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    comments: {
      plan($record) {
        const $records = resource_commentPgResource.find({
          post_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed12(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    downvotes: {
      plan($record) {
        const $records = resource_downvotePgResource.find({
          post_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed13(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    }
  },
  Project: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    organizationId($record) {
      return $record.get("organization_id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    organization($record) {
      return resource_organizationPgResource.get({
        id: $record.get("organization_id")
      });
    },
    posts: {
      plan($record) {
        const $records = resource_postPgResource.find({
          project_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed14(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    postStatuses: {
      plan($record) {
        const $records = resource_post_statusPgResource.find({
          project_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed15(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    }
  },
  Organization: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    projects: {
      plan($record) {
        const $records = resource_projectPgResource.find({
          organization_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed16(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    members: {
      plan($record) {
        const $records = resource_memberPgResource.find({
          organization_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed17(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    invitations: {
      plan($record) {
        const $records = resource_invitationPgResource.find({
          organization_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed18(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    }
  },
  ProjectConnection: {
    __assertStep: ConnectionStep,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy(_$parent, $pgSelect, input) {
          return input.apply($pgSelect);
        },
        having(_$parent, $pgSelect, input) {
          return input.apply($pgSelect, queryBuilder => queryBuilder.havingBuilder());
        }
      }
    }
  },
  ProjectEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  Cursor: {
    serialize: UUIDSerialize,
    parseValue: UUIDSerialize,
    parseLiteral(ast) {
      if (ast.kind !== Kind.STRING) throw new GraphQLError(`${"Cursor" ?? "This scalar"} can only parse string values (kind='${ast.kind}')`);
      return ast.value;
    }
  },
  PageInfo: {
    __assertStep: assertPageInfoCapableStep,
    hasNextPage($pageInfo) {
      return $pageInfo.hasNextPage();
    },
    hasPreviousPage($pageInfo) {
      return $pageInfo.hasPreviousPage();
    },
    startCursor($pageInfo) {
      return $pageInfo.startCursor();
    },
    endCursor($pageInfo) {
      return $pageInfo.endCursor();
    }
  },
  ProjectAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const $groupDetails = $pgSelectSingle.getClassStep().getGroupDetails();
      return lambda([$groupDetails, $pgSelectSingle], ([groupDetails, item]) => {
        if (groupDetails.indicies.length === 0 || item == null) return null;else return groupDetails.indicies.map(({
          index
        }) => item[index]);
      });
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  ProjectDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    name($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("name")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    image($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("image")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    slug($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("slug")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    description($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("description")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    organizationId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("organization_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  BigInt: {
    serialize: UUIDSerialize,
    parseValue: UUIDSerialize,
    parseLiteral(ast) {
      if (ast.kind !== Kind.STRING) throw new GraphQLError(`${"BigInt" ?? "This scalar"} can only parse string values (kind='${ast.kind}')`);
      return ast.value;
    }
  },
  ProjectGroupBy: {
    NAME($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("name")}`,
        codec: TYPES.text
      });
    },
    IMAGE($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("image")}`,
        codec: TYPES.text
      });
    },
    SLUG($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("slug")}`,
        codec: TYPES.text
      });
    },
    DESCRIPTION($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("description")}`,
        codec: TYPES.text
      });
    },
    ORGANIZATION_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("organization_id")}`,
        codec: TYPES.uuid
      });
    },
    CREATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`,
        codec: TYPES.timestamptz
      });
    },
    CREATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    CREATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`,
        codec: TYPES.timestamptz
      });
    },
    UPDATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    }
  },
  ProjectHavingInput: {
    AND($where) {
      return $where;
    },
    OR($where) {
      return new PgOrFilter($where);
    },
    sum($having) {
      return $having;
    },
    distinctCount($having) {
      return $having;
    },
    min($having) {
      return $having;
    },
    max($having) {
      return $having;
    },
    average($having) {
      return $having;
    },
    stddevSample($having) {
      return $having;
    },
    stddevPopulation($having) {
      return $having;
    },
    varianceSample($having) {
      return $having;
    },
    variancePopulation($having) {
      return $having;
    }
  },
  ProjectHavingSumInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  HavingDatetimeFilter: {
    equalTo($booleanFilter, input) {
      if (input == null) return;
      $booleanFilter.having(sql`(${sql.parens($booleanFilter.expression)} ${infix()} ${sqlValueWithCodec(input, TYPES.timestamptz)})`);
    },
    notEqualTo($booleanFilter, input) {
      if (input == null) return;
      $booleanFilter.having(sql`(${sql.parens($booleanFilter.expression)} ${infix2()} ${sqlValueWithCodec(input, TYPES.timestamptz)})`);
    },
    greaterThan($booleanFilter, input) {
      if (input == null) return;
      $booleanFilter.having(sql`(${sql.parens($booleanFilter.expression)} ${infix3()} ${sqlValueWithCodec(input, TYPES.timestamptz)})`);
    },
    greaterThanOrEqualTo($booleanFilter, input) {
      if (input == null) return;
      $booleanFilter.having(sql`(${sql.parens($booleanFilter.expression)} ${infix4()} ${sqlValueWithCodec(input, TYPES.timestamptz)})`);
    },
    lessThan($booleanFilter, input) {
      if (input == null) return;
      $booleanFilter.having(sql`(${sql.parens($booleanFilter.expression)} ${infix5()} ${sqlValueWithCodec(input, TYPES.timestamptz)})`);
    },
    lessThanOrEqualTo($booleanFilter, input) {
      if (input == null) return;
      $booleanFilter.having(sql`(${sql.parens($booleanFilter.expression)} ${infix6()} ${sqlValueWithCodec(input, TYPES.timestamptz)})`);
    }
  },
  ProjectHavingDistinctCountInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  ProjectHavingMinInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  ProjectHavingMaxInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  ProjectHavingAverageInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  ProjectHavingStddevSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  ProjectHavingStddevPopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  ProjectHavingVarianceSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  ProjectHavingVariancePopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_project.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_project.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  ProjectCondition: {
    rowId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    name($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "name",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    image($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "image",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    slug($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "slug",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    description($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "description",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    organizationId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "organization_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    createdAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "created_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    },
    updatedAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "updated_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    }
  },
  ProjectFilter: {
    rowId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec;
      return condition;
    },
    name(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec2;
      return condition;
    },
    image(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec3;
      return condition;
    },
    slug(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec4;
      return condition;
    },
    description(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec5;
      return condition;
    },
    organizationId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec6;
      return condition;
    },
    createdAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec7;
      return condition;
    },
    updatedAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec8;
      return condition;
    },
    posts($where, value) {
      assertAllowed19(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: postIdentifier,
        alias: resource_postPgResource.name,
        localAttributes: registryConfig.pgRelations.project.postsByTheirProjectId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.project.postsByTheirProjectId.remoteAttributes
      };
      return $rel;
    },
    postsExist($where, value) {
      assertAllowed19(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: postIdentifier,
        alias: resource_postPgResource.name,
        equals: value
      });
      registryConfig.pgRelations.project.postsByTheirProjectId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.project.postsByTheirProjectId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    postStatuses($where, value) {
      assertAllowed19(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: postStatusIdentifier,
        alias: resource_post_statusPgResource.name,
        localAttributes: registryConfig.pgRelations.project.postStatusesByTheirProjectId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.project.postStatusesByTheirProjectId.remoteAttributes
      };
      return $rel;
    },
    postStatusesExist($where, value) {
      assertAllowed19(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: postStatusIdentifier,
        alias: resource_post_statusPgResource.name,
        equals: value
      });
      registryConfig.pgRelations.project.postStatusesByTheirProjectId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.project.postStatusesByTheirProjectId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    organization($where, value) {
      assertAllowed20(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: organizationIdentifier,
        alias: resource_organizationPgResource.name
      });
      registryConfig.pgRelations.project.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.project.organizationByMyOrganizationId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    and($where, value) {
      assertAllowed21(value, "list");
      if (value == null) return;
      return $where.andPlan();
    },
    or($where, value) {
      assertAllowed21(value, "list");
      if (value == null) return;
      const $or = $where.orPlan();
      return () => $or.andPlan();
    },
    not($where, value) {
      assertAllowed21(value, "object");
      if (value == null) return;
      return $where.notPlan().andPlan();
    }
  },
  UUIDFilter: {
    isNull($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec ? resolveInputCodec(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue ? resolveSqlValue($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "isNull"
        });
      $where.where(fragment);
    },
    equalTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve2(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "equalTo"
        });
      $where.where(fragment);
    },
    notEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve3(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notEqualTo"
        });
      $where.where(fragment);
    },
    distinctFrom($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve4(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "distinctFrom"
        });
      $where.where(fragment);
    },
    notDistinctFrom($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve5(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notDistinctFrom"
        });
      $where.where(fragment);
    },
    in($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec3 ? resolveInputCodec3(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve6(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "in"
        });
      $where.where(fragment);
    },
    notIn($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec3 ? resolveInputCodec3(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve7(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notIn"
        });
      $where.where(fragment);
    },
    lessThan($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve8(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThan"
        });
      $where.where(fragment);
    },
    lessThanOrEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve9(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThanOrEqualTo"
        });
      $where.where(fragment);
    },
    greaterThan($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve10(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThan"
        });
      $where.where(fragment);
    },
    greaterThanOrEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier ? resolveSqlIdentifier(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec2 ? resolveInputCodec2(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve11(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThanOrEqualTo"
        });
      $where.where(fragment);
    }
  },
  StringFilter: {
    isNull($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec4 ? resolveInputCodec4(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue2 ? resolveSqlValue2($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve12(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "isNull"
        });
      $where.where(fragment);
    },
    equalTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve13(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "equalTo"
        });
      $where.where(fragment);
    },
    notEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve14(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notEqualTo"
        });
      $where.where(fragment);
    },
    distinctFrom($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve15(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "distinctFrom"
        });
      $where.where(fragment);
    },
    notDistinctFrom($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve16(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notDistinctFrom"
        });
      $where.where(fragment);
    },
    in($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec6 ? resolveInputCodec6(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve17(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "in"
        });
      $where.where(fragment);
    },
    notIn($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec6 ? resolveInputCodec6(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve18(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notIn"
        });
      $where.where(fragment);
    },
    lessThan($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve19(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThan"
        });
      $where.where(fragment);
    },
    lessThanOrEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve20(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThanOrEqualTo"
        });
      $where.where(fragment);
    },
    greaterThan($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve21(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThan"
        });
      $where.where(fragment);
    },
    greaterThanOrEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve22(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThanOrEqualTo"
        });
      $where.where(fragment);
    },
    includes($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = resolveInput ? resolveInput(value) : value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve23(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "includes"
        });
      $where.where(fragment);
    },
    notIncludes($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = resolveInput2 ? resolveInput2(value) : value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve24(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notIncludes"
        });
      $where.where(fragment);
    },
    includesInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = resolveInput3 ? resolveInput3(value) : value,
        inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve25(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "includesInsensitive"
        });
      $where.where(fragment);
    },
    notIncludesInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = resolveInput4 ? resolveInput4(value) : value,
        inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve26(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notIncludesInsensitive"
        });
      $where.where(fragment);
    },
    startsWith($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = resolveInput5 ? resolveInput5(value) : value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve27(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "startsWith"
        });
      $where.where(fragment);
    },
    notStartsWith($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = resolveInput6 ? resolveInput6(value) : value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve28(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notStartsWith"
        });
      $where.where(fragment);
    },
    startsWithInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = resolveInput7 ? resolveInput7(value) : value,
        inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve29(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "startsWithInsensitive"
        });
      $where.where(fragment);
    },
    notStartsWithInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = resolveInput8 ? resolveInput8(value) : value,
        inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve30(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notStartsWithInsensitive"
        });
      $where.where(fragment);
    },
    endsWith($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = resolveInput9 ? resolveInput9(value) : value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve31(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "endsWith"
        });
      $where.where(fragment);
    },
    notEndsWith($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = resolveInput10 ? resolveInput10(value) : value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve32(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notEndsWith"
        });
      $where.where(fragment);
    },
    endsWithInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = resolveInput11 ? resolveInput11(value) : value,
        inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve33(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "endsWithInsensitive"
        });
      $where.where(fragment);
    },
    notEndsWithInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = resolveInput12 ? resolveInput12(value) : value,
        inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve34(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notEndsWithInsensitive"
        });
      $where.where(fragment);
    },
    like($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve35(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "like"
        });
      $where.where(fragment);
    },
    notLike($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier2 ? resolveSqlIdentifier2(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec5 ? resolveInputCodec5(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve36(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notLike"
        });
      $where.where(fragment);
    },
    likeInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve37(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "likeInsensitive"
        });
      $where.where(fragment);
    },
    notLikeInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier3 ? resolveSqlIdentifier3(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec7 ? resolveInputCodec7(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve38(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notLikeInsensitive"
        });
      $where.where(fragment);
    },
    equalToInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier4 ? resolveSqlIdentifier4(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec8 ? resolveInputCodec8(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue3 ? resolveSqlValue3($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve13(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "equalToInsensitive"
        });
      $where.where(fragment);
    },
    notEqualToInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier5 ? resolveSqlIdentifier5(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec9 ? resolveInputCodec9(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue4 ? resolveSqlValue4($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve14(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notEqualToInsensitive"
        });
      $where.where(fragment);
    },
    distinctFromInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier6 ? resolveSqlIdentifier6(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec10 ? resolveInputCodec10(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue5 ? resolveSqlValue5($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve15(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "distinctFromInsensitive"
        });
      $where.where(fragment);
    },
    notDistinctFromInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier7 ? resolveSqlIdentifier7(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec11 ? resolveInputCodec11(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue6 ? resolveSqlValue6($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve16(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notDistinctFromInsensitive"
        });
      $where.where(fragment);
    },
    inInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier8 ? resolveSqlIdentifier8(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec12 ? resolveInputCodec12(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue7 ? resolveSqlValue7($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve17(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "inInsensitive"
        });
      $where.where(fragment);
    },
    notInInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier9 ? resolveSqlIdentifier9(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec13 ? resolveInputCodec13(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue8 ? resolveSqlValue8($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve18(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notInInsensitive"
        });
      $where.where(fragment);
    },
    lessThanInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier10 ? resolveSqlIdentifier10(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec14 ? resolveInputCodec14(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue9 ? resolveSqlValue9($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve19(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThanInsensitive"
        });
      $where.where(fragment);
    },
    lessThanOrEqualToInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier11 ? resolveSqlIdentifier11(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec15 ? resolveInputCodec15(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue10 ? resolveSqlValue10($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve20(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThanOrEqualToInsensitive"
        });
      $where.where(fragment);
    },
    greaterThanInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier12 ? resolveSqlIdentifier12(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec16 ? resolveInputCodec16(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue11 ? resolveSqlValue11($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve21(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThanInsensitive"
        });
      $where.where(fragment);
    },
    greaterThanOrEqualToInsensitive($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier13 ? resolveSqlIdentifier13(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec17 ? resolveInputCodec17(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue12 ? resolveSqlValue12($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve22(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThanOrEqualToInsensitive"
        });
      $where.where(fragment);
    }
  },
  DatetimeFilter: {
    isNull($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec18 ? resolveInputCodec18(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue13 ? resolveSqlValue13($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve39(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "isNull"
        });
      $where.where(fragment);
    },
    equalTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve40(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "equalTo"
        });
      $where.where(fragment);
    },
    notEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve41(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notEqualTo"
        });
      $where.where(fragment);
    },
    distinctFrom($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve42(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "distinctFrom"
        });
      $where.where(fragment);
    },
    notDistinctFrom($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve43(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notDistinctFrom"
        });
      $where.where(fragment);
    },
    in($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec20 ? resolveInputCodec20(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve44(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "in"
        });
      $where.where(fragment);
    },
    notIn($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec20 ? resolveInputCodec20(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve45(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notIn"
        });
      $where.where(fragment);
    },
    lessThan($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve46(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThan"
        });
      $where.where(fragment);
    },
    lessThanOrEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve47(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThanOrEqualTo"
        });
      $where.where(fragment);
    },
    greaterThan($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve48(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThan"
        });
      $where.where(fragment);
    },
    greaterThanOrEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier14 ? resolveSqlIdentifier14(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec19 ? resolveInputCodec19(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve49(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThanOrEqualTo"
        });
      $where.where(fragment);
    }
  },
  ProjectToManyPostFilter: {
    every($where, value) {
      assertAllowed22(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed22(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed22(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  PostFilter: {
    rowId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec9;
      return condition;
    },
    title(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec10;
      return condition;
    },
    description(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec11;
      return condition;
    },
    projectId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec12;
      return condition;
    },
    userId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec13;
      return condition;
    },
    createdAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec14;
      return condition;
    },
    updatedAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec15;
      return condition;
    },
    statusId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec16;
      return condition;
    },
    statusUpdatedAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec17;
      return condition;
    },
    upvotes($where, value) {
      assertAllowed23(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: upvoteIdentifier,
        alias: resource_upvotePgResource.name,
        localAttributes: registryConfig.pgRelations.post.upvotesByTheirPostId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.post.upvotesByTheirPostId.remoteAttributes
      };
      return $rel;
    },
    upvotesExist($where, value) {
      assertAllowed23(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: upvoteIdentifier,
        alias: resource_upvotePgResource.name,
        equals: value
      });
      registryConfig.pgRelations.post.upvotesByTheirPostId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.post.upvotesByTheirPostId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    comments($where, value) {
      assertAllowed23(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: commentIdentifier,
        alias: resource_commentPgResource.name,
        localAttributes: registryConfig.pgRelations.post.commentsByTheirPostId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.post.commentsByTheirPostId.remoteAttributes
      };
      return $rel;
    },
    commentsExist($where, value) {
      assertAllowed23(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: commentIdentifier,
        alias: resource_commentPgResource.name,
        equals: value
      });
      registryConfig.pgRelations.post.commentsByTheirPostId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.post.commentsByTheirPostId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    downvotes($where, value) {
      assertAllowed23(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: downvoteIdentifier,
        alias: resource_downvotePgResource.name,
        localAttributes: registryConfig.pgRelations.post.downvotesByTheirPostId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.post.downvotesByTheirPostId.remoteAttributes
      };
      return $rel;
    },
    downvotesExist($where, value) {
      assertAllowed23(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: downvoteIdentifier,
        alias: resource_downvotePgResource.name,
        equals: value
      });
      registryConfig.pgRelations.post.downvotesByTheirPostId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.post.downvotesByTheirPostId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    project($where, value) {
      assertAllowed24(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: projectIdentifier,
        alias: resource_projectPgResource.name
      });
      registryConfig.pgRelations.post.projectByMyProjectId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.post.projectByMyProjectId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    status($where, value) {
      assertAllowed24(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: postStatusIdentifier,
        alias: resource_post_statusPgResource.name
      });
      registryConfig.pgRelations.post.postStatusByMyStatusId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.post.postStatusByMyStatusId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    statusExists($where, value) {
      assertAllowed24(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: postStatusIdentifier,
        alias: resource_post_statusPgResource.name,
        equals: value
      });
      registryConfig.pgRelations.post.postStatusByMyStatusId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.post.postStatusByMyStatusId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    user($where, value) {
      assertAllowed24(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: userIdentifier,
        alias: resource_userPgResource.name
      });
      registryConfig.pgRelations.post.userByMyUserId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.post.userByMyUserId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    and($where, value) {
      assertAllowed25(value, "list");
      if (value == null) return;
      return $where.andPlan();
    },
    or($where, value) {
      assertAllowed25(value, "list");
      if (value == null) return;
      const $or = $where.orPlan();
      return () => $or.andPlan();
    },
    not($where, value) {
      assertAllowed25(value, "object");
      if (value == null) return;
      return $where.notPlan().andPlan();
    }
  },
  PostToManyUpvoteFilter: {
    every($where, value) {
      assertAllowed26(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed26(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed26(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  UpvoteFilter: {
    rowId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec18;
      return condition;
    },
    postId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec19;
      return condition;
    },
    userId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec20;
      return condition;
    },
    createdAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec21;
      return condition;
    },
    updatedAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec22;
      return condition;
    },
    post($where, value) {
      assertAllowed27(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: postIdentifier,
        alias: resource_postPgResource.name
      });
      registryConfig.pgRelations.upvote.postByMyPostId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.upvote.postByMyPostId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    user($where, value) {
      assertAllowed27(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: userIdentifier,
        alias: resource_userPgResource.name
      });
      registryConfig.pgRelations.upvote.userByMyUserId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.upvote.userByMyUserId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    and($where, value) {
      assertAllowed28(value, "list");
      if (value == null) return;
      return $where.andPlan();
    },
    or($where, value) {
      assertAllowed28(value, "list");
      if (value == null) return;
      const $or = $where.orPlan();
      return () => $or.andPlan();
    },
    not($where, value) {
      assertAllowed28(value, "object");
      if (value == null) return;
      return $where.notPlan().andPlan();
    }
  },
  UserFilter: {
    rowId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec23;
      return condition;
    },
    createdAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec24;
      return condition;
    },
    updatedAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec25;
      return condition;
    },
    hidraId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec26;
      return condition;
    },
    username(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec27;
      return condition;
    },
    firstName(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec28;
      return condition;
    },
    lastName(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec29;
      return condition;
    },
    email(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec30;
      return condition;
    },
    tier(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec31;
      return condition;
    },
    posts($where, value) {
      assertAllowed29(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: postIdentifier,
        alias: resource_postPgResource.name,
        localAttributes: registryConfig.pgRelations.user.postsByTheirUserId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.user.postsByTheirUserId.remoteAttributes
      };
      return $rel;
    },
    postsExist($where, value) {
      assertAllowed29(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: postIdentifier,
        alias: resource_postPgResource.name,
        equals: value
      });
      registryConfig.pgRelations.user.postsByTheirUserId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.user.postsByTheirUserId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    upvotes($where, value) {
      assertAllowed29(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: upvoteIdentifier,
        alias: resource_upvotePgResource.name,
        localAttributes: registryConfig.pgRelations.user.upvotesByTheirUserId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.user.upvotesByTheirUserId.remoteAttributes
      };
      return $rel;
    },
    upvotesExist($where, value) {
      assertAllowed29(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: upvoteIdentifier,
        alias: resource_upvotePgResource.name,
        equals: value
      });
      registryConfig.pgRelations.user.upvotesByTheirUserId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.user.upvotesByTheirUserId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    members($where, value) {
      assertAllowed29(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: memberIdentifier,
        alias: resource_memberPgResource.name,
        localAttributes: registryConfig.pgRelations.user.membersByTheirUserId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.user.membersByTheirUserId.remoteAttributes
      };
      return $rel;
    },
    membersExist($where, value) {
      assertAllowed29(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: memberIdentifier,
        alias: resource_memberPgResource.name,
        equals: value
      });
      registryConfig.pgRelations.user.membersByTheirUserId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.user.membersByTheirUserId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    comments($where, value) {
      assertAllowed29(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: commentIdentifier,
        alias: resource_commentPgResource.name,
        localAttributes: registryConfig.pgRelations.user.commentsByTheirUserId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.user.commentsByTheirUserId.remoteAttributes
      };
      return $rel;
    },
    commentsExist($where, value) {
      assertAllowed29(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: commentIdentifier,
        alias: resource_commentPgResource.name,
        equals: value
      });
      registryConfig.pgRelations.user.commentsByTheirUserId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.user.commentsByTheirUserId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    downvotes($where, value) {
      assertAllowed29(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: downvoteIdentifier,
        alias: resource_downvotePgResource.name,
        localAttributes: registryConfig.pgRelations.user.downvotesByTheirUserId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.user.downvotesByTheirUserId.remoteAttributes
      };
      return $rel;
    },
    downvotesExist($where, value) {
      assertAllowed29(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: downvoteIdentifier,
        alias: resource_downvotePgResource.name,
        equals: value
      });
      registryConfig.pgRelations.user.downvotesByTheirUserId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.user.downvotesByTheirUserId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    and($where, value) {
      assertAllowed30(value, "list");
      if (value == null) return;
      return $where.andPlan();
    },
    or($where, value) {
      assertAllowed30(value, "list");
      if (value == null) return;
      const $or = $where.orPlan();
      return () => $or.andPlan();
    },
    not($where, value) {
      assertAllowed30(value, "object");
      if (value == null) return;
      return $where.notPlan().andPlan();
    }
  },
  TierFilter: {
    isNull($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec21 ? resolveInputCodec21(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue14 ? resolveSqlValue14($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve50(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "isNull"
        });
      $where.where(fragment);
    },
    equalTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve51(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "equalTo"
        });
      $where.where(fragment);
    },
    notEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve52(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notEqualTo"
        });
      $where.where(fragment);
    },
    distinctFrom($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve53(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "distinctFrom"
        });
      $where.where(fragment);
    },
    notDistinctFrom($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve54(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notDistinctFrom"
        });
      $where.where(fragment);
    },
    in($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec23 ? resolveInputCodec23(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve55(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "in"
        });
      $where.where(fragment);
    },
    notIn($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec23 ? resolveInputCodec23(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve56(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notIn"
        });
      $where.where(fragment);
    },
    lessThan($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve57(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThan"
        });
      $where.where(fragment);
    },
    lessThanOrEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve58(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThanOrEqualTo"
        });
      $where.where(fragment);
    },
    greaterThan($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve59(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThan"
        });
      $where.where(fragment);
    },
    greaterThanOrEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier15 ? resolveSqlIdentifier15(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec22 ? resolveInputCodec22(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve60(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThanOrEqualTo"
        });
      $where.where(fragment);
    }
  },
  UserToManyPostFilter: {
    every($where, value) {
      assertAllowed31(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed31(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed31(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  PostAggregatesFilter: {
    filter($subquery, input) {
      if (input == null) return;
      return new PgCondition($subquery, !1, "AND");
    },
    distinctCount($subquery, input) {
      if (input == null) return;
      return $subquery.forAggregate(spec);
    }
  },
  PostDistinctCountAggregateFilter: {
    rowId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_post.attributes.id.codec)
      };
      return $col;
    },
    title($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("title")}`, spec_post.attributes.title.codec)
      };
      return $col;
    },
    description($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("description")}`, spec_post.attributes.description.codec)
      };
      return $col;
    },
    projectId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("project_id")}`, spec_post.attributes.project_id.codec)
      };
      return $col;
    },
    userId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("user_id")}`, spec_post.attributes.user_id.codec)
      };
      return $col;
    },
    createdAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_post.attributes.created_at.codec)
      };
      return $col;
    },
    updatedAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("updated_at")}`, spec_post.attributes.updated_at.codec)
      };
      return $col;
    },
    statusId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("status_id")}`, spec_post.attributes.status_id.codec)
      };
      return $col;
    },
    statusUpdatedAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("status_updated_at")}`, spec_post.attributes.status_updated_at.codec)
      };
      return $col;
    }
  },
  BigIntFilter: {
    isNull($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec24 ? resolveInputCodec24(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue15 ? resolveSqlValue15($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve61(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "isNull"
        });
      $where.where(fragment);
    },
    equalTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve62(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "equalTo"
        });
      $where.where(fragment);
    },
    notEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve63(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notEqualTo"
        });
      $where.where(fragment);
    },
    distinctFrom($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve64(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "distinctFrom"
        });
      $where.where(fragment);
    },
    notDistinctFrom($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve65(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notDistinctFrom"
        });
      $where.where(fragment);
    },
    in($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec26 ? resolveInputCodec26(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve66(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "in"
        });
      $where.where(fragment);
    },
    notIn($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec26 ? resolveInputCodec26(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve67(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notIn"
        });
      $where.where(fragment);
    },
    lessThan($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve68(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThan"
        });
      $where.where(fragment);
    },
    lessThanOrEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve69(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThanOrEqualTo"
        });
      $where.where(fragment);
    },
    greaterThan($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve70(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThan"
        });
      $where.where(fragment);
    },
    greaterThanOrEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier16 ? resolveSqlIdentifier16(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec25 ? resolveInputCodec25(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve71(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThanOrEqualTo"
        });
      $where.where(fragment);
    }
  },
  UserToManyUpvoteFilter: {
    every($where, value) {
      assertAllowed32(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed32(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed32(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  UpvoteAggregatesFilter: {
    filter($subquery, input) {
      if (input == null) return;
      return new PgCondition($subquery, !1, "AND");
    },
    distinctCount($subquery, input) {
      if (input == null) return;
      return $subquery.forAggregate(spec);
    }
  },
  UpvoteDistinctCountAggregateFilter: {
    rowId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_upvote.attributes.id.codec)
      };
      return $col;
    },
    postId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("post_id")}`, spec_upvote.attributes.post_id.codec)
      };
      return $col;
    },
    userId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("user_id")}`, spec_upvote.attributes.user_id.codec)
      };
      return $col;
    },
    createdAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_upvote.attributes.created_at.codec)
      };
      return $col;
    },
    updatedAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("updated_at")}`, spec_upvote.attributes.updated_at.codec)
      };
      return $col;
    }
  },
  UserToManyMemberFilter: {
    every($where, value) {
      assertAllowed33(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed33(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed33(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  MemberFilter: {
    userId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec32;
      return condition;
    },
    organizationId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec33;
      return condition;
    },
    createdAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec34;
      return condition;
    },
    role(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec35;
      return condition;
    },
    rowId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec36;
      return condition;
    },
    organization($where, value) {
      assertAllowed34(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: organizationIdentifier,
        alias: resource_organizationPgResource.name
      });
      registryConfig.pgRelations.member.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.member.organizationByMyOrganizationId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    user($where, value) {
      assertAllowed34(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: userIdentifier,
        alias: resource_userPgResource.name
      });
      registryConfig.pgRelations.member.userByMyUserId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.member.userByMyUserId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    and($where, value) {
      assertAllowed35(value, "list");
      if (value == null) return;
      return $where.andPlan();
    },
    or($where, value) {
      assertAllowed35(value, "list");
      if (value == null) return;
      const $or = $where.orPlan();
      return () => $or.andPlan();
    },
    not($where, value) {
      assertAllowed35(value, "object");
      if (value == null) return;
      return $where.notPlan().andPlan();
    }
  },
  RoleFilter: {
    isNull($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec27 ? resolveInputCodec27(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue16 ? resolveSqlValue16($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve72(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "isNull"
        });
      $where.where(fragment);
    },
    equalTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve73(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "equalTo"
        });
      $where.where(fragment);
    },
    notEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve74(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notEqualTo"
        });
      $where.where(fragment);
    },
    distinctFrom($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve75(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "distinctFrom"
        });
      $where.where(fragment);
    },
    notDistinctFrom($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve76(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notDistinctFrom"
        });
      $where.where(fragment);
    },
    in($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec29 ? resolveInputCodec29(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve77(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "in"
        });
      $where.where(fragment);
    },
    notIn($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec29 ? resolveInputCodec29(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve78(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notIn"
        });
      $where.where(fragment);
    },
    lessThan($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve79(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThan"
        });
      $where.where(fragment);
    },
    lessThanOrEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve80(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThanOrEqualTo"
        });
      $where.where(fragment);
    },
    greaterThan($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve81(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThan"
        });
      $where.where(fragment);
    },
    greaterThanOrEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier17 ? resolveSqlIdentifier17(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec28 ? resolveInputCodec28(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve82(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThanOrEqualTo"
        });
      $where.where(fragment);
    }
  },
  OrganizationFilter: {
    rowId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec37;
      return condition;
    },
    name(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec38;
      return condition;
    },
    slug(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec39;
      return condition;
    },
    createdAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec40;
      return condition;
    },
    updatedAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec41;
      return condition;
    },
    projects($where, value) {
      assertAllowed36(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: projectIdentifier,
        alias: resource_projectPgResource.name,
        localAttributes: registryConfig.pgRelations.organization.projectsByTheirOrganizationId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.organization.projectsByTheirOrganizationId.remoteAttributes
      };
      return $rel;
    },
    projectsExist($where, value) {
      assertAllowed36(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: projectIdentifier,
        alias: resource_projectPgResource.name,
        equals: value
      });
      registryConfig.pgRelations.organization.projectsByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.organization.projectsByTheirOrganizationId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    members($where, value) {
      assertAllowed36(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: memberIdentifier,
        alias: resource_memberPgResource.name,
        localAttributes: registryConfig.pgRelations.organization.membersByTheirOrganizationId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.organization.membersByTheirOrganizationId.remoteAttributes
      };
      return $rel;
    },
    membersExist($where, value) {
      assertAllowed36(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: memberIdentifier,
        alias: resource_memberPgResource.name,
        equals: value
      });
      registryConfig.pgRelations.organization.membersByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.organization.membersByTheirOrganizationId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    invitations($where, value) {
      assertAllowed36(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: invitationIdentifier,
        alias: resource_invitationPgResource.name,
        localAttributes: registryConfig.pgRelations.organization.invitationsByTheirOrganizationId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.organization.invitationsByTheirOrganizationId.remoteAttributes
      };
      return $rel;
    },
    invitationsExist($where, value) {
      assertAllowed36(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: invitationIdentifier,
        alias: resource_invitationPgResource.name,
        equals: value
      });
      registryConfig.pgRelations.organization.invitationsByTheirOrganizationId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.organization.invitationsByTheirOrganizationId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    and($where, value) {
      assertAllowed37(value, "list");
      if (value == null) return;
      return $where.andPlan();
    },
    or($where, value) {
      assertAllowed37(value, "list");
      if (value == null) return;
      const $or = $where.orPlan();
      return () => $or.andPlan();
    },
    not($where, value) {
      assertAllowed37(value, "object");
      if (value == null) return;
      return $where.notPlan().andPlan();
    }
  },
  OrganizationToManyProjectFilter: {
    every($where, value) {
      assertAllowed38(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed38(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed38(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  ProjectAggregatesFilter: {
    filter($subquery, input) {
      if (input == null) return;
      return new PgCondition($subquery, !1, "AND");
    },
    distinctCount($subquery, input) {
      if (input == null) return;
      return $subquery.forAggregate(spec);
    }
  },
  ProjectDistinctCountAggregateFilter: {
    rowId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_project.attributes.id.codec)
      };
      return $col;
    },
    name($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("name")}`, spec_project.attributes.name.codec)
      };
      return $col;
    },
    image($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("image")}`, spec_project.attributes.image.codec)
      };
      return $col;
    },
    slug($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("slug")}`, spec_project.attributes.slug.codec)
      };
      return $col;
    },
    description($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("description")}`, spec_project.attributes.description.codec)
      };
      return $col;
    },
    organizationId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("organization_id")}`, spec_project.attributes.organization_id.codec)
      };
      return $col;
    },
    createdAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_project.attributes.created_at.codec)
      };
      return $col;
    },
    updatedAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("updated_at")}`, spec_project.attributes.updated_at.codec)
      };
      return $col;
    }
  },
  OrganizationToManyMemberFilter: {
    every($where, value) {
      assertAllowed39(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed39(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed39(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  MemberAggregatesFilter: {
    filter($subquery, input) {
      if (input == null) return;
      return new PgCondition($subquery, !1, "AND");
    },
    distinctCount($subquery, input) {
      if (input == null) return;
      return $subquery.forAggregate(spec);
    }
  },
  MemberDistinctCountAggregateFilter: {
    userId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("user_id")}`, spec_member.attributes.user_id.codec)
      };
      return $col;
    },
    organizationId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("organization_id")}`, spec_member.attributes.organization_id.codec)
      };
      return $col;
    },
    createdAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_member.attributes.created_at.codec)
      };
      return $col;
    },
    role($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("role")}`, spec_member.attributes.role.codec)
      };
      return $col;
    },
    rowId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_member.attributes.id.codec)
      };
      return $col;
    }
  },
  OrganizationToManyInvitationFilter: {
    every($where, value) {
      assertAllowed40(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed40(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed40(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  InvitationFilter: {
    rowId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec42;
      return condition;
    },
    organizationId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec43;
      return condition;
    },
    email(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec44;
      return condition;
    },
    createdAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec45;
      return condition;
    },
    updatedAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec46;
      return condition;
    },
    organization($where, value) {
      assertAllowed41(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: organizationIdentifier,
        alias: resource_organizationPgResource.name
      });
      registryConfig.pgRelations.invitation.organizationByMyOrganizationId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.invitation.organizationByMyOrganizationId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    and($where, value) {
      assertAllowed42(value, "list");
      if (value == null) return;
      return $where.andPlan();
    },
    or($where, value) {
      assertAllowed42(value, "list");
      if (value == null) return;
      const $or = $where.orPlan();
      return () => $or.andPlan();
    },
    not($where, value) {
      assertAllowed42(value, "object");
      if (value == null) return;
      return $where.notPlan().andPlan();
    }
  },
  InvitationAggregatesFilter: {
    filter($subquery, input) {
      if (input == null) return;
      return new PgCondition($subquery, !1, "AND");
    },
    distinctCount($subquery, input) {
      if (input == null) return;
      return $subquery.forAggregate(spec);
    }
  },
  InvitationDistinctCountAggregateFilter: {
    rowId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_invitation.attributes.id.codec)
      };
      return $col;
    },
    organizationId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("organization_id")}`, spec_invitation.attributes.organization_id.codec)
      };
      return $col;
    },
    email($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("email")}`, spec_invitation.attributes.email.codec)
      };
      return $col;
    },
    createdAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_invitation.attributes.created_at.codec)
      };
      return $col;
    },
    updatedAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("updated_at")}`, spec_invitation.attributes.updated_at.codec)
      };
      return $col;
    }
  },
  UserToManyCommentFilter: {
    every($where, value) {
      assertAllowed43(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed43(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed43(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  CommentFilter: {
    rowId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec47;
      return condition;
    },
    message(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec48;
      return condition;
    },
    postId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec49;
      return condition;
    },
    userId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec50;
      return condition;
    },
    createdAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec51;
      return condition;
    },
    updatedAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec52;
      return condition;
    },
    parentId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec53;
      return condition;
    },
    childComments($where, value) {
      assertAllowed44(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: commentIdentifier,
        alias: resource_commentPgResource.name,
        localAttributes: registryConfig.pgRelations.comment.commentsByTheirParentId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.comment.commentsByTheirParentId.remoteAttributes
      };
      return $rel;
    },
    childCommentsExist($where, value) {
      assertAllowed44(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: commentIdentifier,
        alias: resource_commentPgResource.name,
        equals: value
      });
      registryConfig.pgRelations.comment.commentsByTheirParentId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.comment.commentsByTheirParentId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    parent($where, value) {
      assertAllowed45(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: commentIdentifier,
        alias: resource_commentPgResource.name
      });
      registryConfig.pgRelations.comment.commentByMyParentId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.comment.commentByMyParentId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    parentExists($where, value) {
      assertAllowed45(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: commentIdentifier,
        alias: resource_commentPgResource.name,
        equals: value
      });
      registryConfig.pgRelations.comment.commentByMyParentId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.comment.commentByMyParentId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    post($where, value) {
      assertAllowed45(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: postIdentifier,
        alias: resource_postPgResource.name
      });
      registryConfig.pgRelations.comment.postByMyPostId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.comment.postByMyPostId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    user($where, value) {
      assertAllowed45(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: userIdentifier,
        alias: resource_userPgResource.name
      });
      registryConfig.pgRelations.comment.userByMyUserId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.comment.userByMyUserId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    and($where, value) {
      assertAllowed46(value, "list");
      if (value == null) return;
      return $where.andPlan();
    },
    or($where, value) {
      assertAllowed46(value, "list");
      if (value == null) return;
      const $or = $where.orPlan();
      return () => $or.andPlan();
    },
    not($where, value) {
      assertAllowed46(value, "object");
      if (value == null) return;
      return $where.notPlan().andPlan();
    }
  },
  CommentToManyCommentFilter: {
    every($where, value) {
      assertAllowed47(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed47(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed47(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  CommentAggregatesFilter: {
    filter($subquery, input) {
      if (input == null) return;
      return new PgCondition($subquery, !1, "AND");
    },
    distinctCount($subquery, input) {
      if (input == null) return;
      return $subquery.forAggregate(spec);
    }
  },
  CommentDistinctCountAggregateFilter: {
    rowId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_comment.attributes.id.codec)
      };
      return $col;
    },
    message($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("message")}`, spec_comment.attributes.message.codec)
      };
      return $col;
    },
    postId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("post_id")}`, spec_comment.attributes.post_id.codec)
      };
      return $col;
    },
    userId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("user_id")}`, spec_comment.attributes.user_id.codec)
      };
      return $col;
    },
    createdAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_comment.attributes.created_at.codec)
      };
      return $col;
    },
    updatedAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("updated_at")}`, spec_comment.attributes.updated_at.codec)
      };
      return $col;
    },
    parentId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("parent_id")}`, spec_comment.attributes.parent_id.codec)
      };
      return $col;
    }
  },
  UserToManyDownvoteFilter: {
    every($where, value) {
      assertAllowed48(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed48(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed48(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  DownvoteFilter: {
    rowId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec54;
      return condition;
    },
    postId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec55;
      return condition;
    },
    userId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec56;
      return condition;
    },
    createdAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec57;
      return condition;
    },
    updatedAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec58;
      return condition;
    },
    post($where, value) {
      assertAllowed49(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: postIdentifier,
        alias: resource_postPgResource.name
      });
      registryConfig.pgRelations.downvote.postByMyPostId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.downvote.postByMyPostId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    user($where, value) {
      assertAllowed49(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: userIdentifier,
        alias: resource_userPgResource.name
      });
      registryConfig.pgRelations.downvote.userByMyUserId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.downvote.userByMyUserId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    and($where, value) {
      assertAllowed50(value, "list");
      if (value == null) return;
      return $where.andPlan();
    },
    or($where, value) {
      assertAllowed50(value, "list");
      if (value == null) return;
      const $or = $where.orPlan();
      return () => $or.andPlan();
    },
    not($where, value) {
      assertAllowed50(value, "object");
      if (value == null) return;
      return $where.notPlan().andPlan();
    }
  },
  DownvoteAggregatesFilter: {
    filter($subquery, input) {
      if (input == null) return;
      return new PgCondition($subquery, !1, "AND");
    },
    distinctCount($subquery, input) {
      if (input == null) return;
      return $subquery.forAggregate(spec);
    }
  },
  DownvoteDistinctCountAggregateFilter: {
    rowId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_downvote.attributes.id.codec)
      };
      return $col;
    },
    postId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("post_id")}`, spec_downvote.attributes.post_id.codec)
      };
      return $col;
    },
    userId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("user_id")}`, spec_downvote.attributes.user_id.codec)
      };
      return $col;
    },
    createdAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_downvote.attributes.created_at.codec)
      };
      return $col;
    },
    updatedAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("updated_at")}`, spec_downvote.attributes.updated_at.codec)
      };
      return $col;
    }
  },
  PostToManyCommentFilter: {
    every($where, value) {
      assertAllowed51(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed51(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed51(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  PostToManyDownvoteFilter: {
    every($where, value) {
      assertAllowed52(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed52(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed52(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  PostStatusFilter: {
    rowId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec59;
      return condition;
    },
    status(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec60;
      return condition;
    },
    description(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec61;
      return condition;
    },
    color(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec62;
      return condition;
    },
    projectId(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec63;
      return condition;
    },
    isDefault(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec64;
      return condition;
    },
    createdAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec65;
      return condition;
    },
    updatedAt(queryBuilder, value) {
      if (value === void 0) return;
      if (!true && isEmpty(value)) throw Object.assign(new Error("Empty objects are forbidden in filter argument input."), {});
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const condition = new PgCondition(queryBuilder);
      condition.extensions.pgFilterAttribute = colSpec66;
      return condition;
    },
    postsByStatusId($where, value) {
      assertAllowed53(value, "object");
      const $rel = $where.andPlan();
      $rel.extensions.pgFilterRelation = {
        tableExpression: postIdentifier,
        alias: resource_postPgResource.name,
        localAttributes: registryConfig.pgRelations.postStatus.postsByTheirStatusId.localAttributes,
        remoteAttributes: registryConfig.pgRelations.postStatus.postsByTheirStatusId.remoteAttributes
      };
      return $rel;
    },
    postsByStatusIdExist($where, value) {
      assertAllowed53(value, "scalar");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: postIdentifier,
        alias: resource_postPgResource.name,
        equals: value
      });
      registryConfig.pgRelations.postStatus.postsByTheirStatusId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.postStatus.postsByTheirStatusId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
    },
    project($where, value) {
      assertAllowed54(value, "object");
      if (value == null) return;
      const $subQuery = $where.existsPlan({
        tableExpression: projectIdentifier,
        alias: resource_projectPgResource.name
      });
      registryConfig.pgRelations.postStatus.projectByMyProjectId.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = registryConfig.pgRelations.postStatus.projectByMyProjectId.remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    and($where, value) {
      assertAllowed55(value, "list");
      if (value == null) return;
      return $where.andPlan();
    },
    or($where, value) {
      assertAllowed55(value, "list");
      if (value == null) return;
      const $or = $where.orPlan();
      return () => $or.andPlan();
    },
    not($where, value) {
      assertAllowed55(value, "object");
      if (value == null) return;
      return $where.notPlan().andPlan();
    }
  },
  BooleanFilter: {
    isNull($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec30 ? resolveInputCodec30(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = resolveSqlValue17 ? resolveSqlValue17($where, value, inputCodec) : sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve83(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "isNull"
        });
      $where.where(fragment);
    },
    equalTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve84(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "equalTo"
        });
      $where.where(fragment);
    },
    notEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve85(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notEqualTo"
        });
      $where.where(fragment);
    },
    distinctFrom($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve86(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "distinctFrom"
        });
      $where.where(fragment);
    },
    notDistinctFrom($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve87(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notDistinctFrom"
        });
      $where.where(fragment);
    },
    in($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec32 ? resolveInputCodec32(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve88(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "in"
        });
      $where.where(fragment);
    },
    notIn($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec32 ? resolveInputCodec32(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve89(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "notIn"
        });
      $where.where(fragment);
    },
    lessThan($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve90(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThan"
        });
      $where.where(fragment);
    },
    lessThanOrEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve91(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "lessThanOrEqualTo"
        });
      $where.where(fragment);
    },
    greaterThan($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve92(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThan"
        });
      $where.where(fragment);
    },
    greaterThanOrEqualTo($where, value) {
      if (!$where.extensions?.pgFilterAttribute) throw new Error("Planning error: expected 'pgFilterAttribute' to be present on the $where plan's extensions; your extensions to `postgraphile-plugin-connection-filter` does not implement the required interfaces.");
      if (value === void 0) return;
      const {
          fieldName: parentFieldName,
          attributeName,
          attribute,
          codec,
          expression
        } = $where.extensions.pgFilterAttribute,
        sourceAlias = attribute ? attribute.expression ? attribute.expression($where.alias) : sql`${$where.alias}.${sql.identifier(attributeName)}` : expression ? expression : $where.alias,
        sourceCodec = codec ?? attribute.codec,
        [sqlIdentifier, identifierCodec] = resolveSqlIdentifier18 ? resolveSqlIdentifier18(sourceAlias, sourceCodec) : [sourceAlias, sourceCodec];
      if (true && value === null) return;
      if (!true && value === null) throw Object.assign(new Error("Null literals are forbidden in filter argument input."), {});
      const resolvedInput = value,
        inputCodec = resolveInputCodec31 ? resolveInputCodec31(codec ?? attribute.codec) : codec ?? attribute.codec,
        sqlValue = sqlValueWithCodec(resolvedInput, inputCodec),
        fragment = resolve93(sqlIdentifier, sqlValue, value, $where, {
          fieldName: parentFieldName ?? null,
          operatorName: "greaterThanOrEqualTo"
        });
      $where.where(fragment);
    }
  },
  PostStatusToManyPostFilter: {
    every($where, value) {
      assertAllowed56(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed56(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed56(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  ProjectToManyPostStatusFilter: {
    every($where, value) {
      assertAllowed57(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery.notPlan().andPlan();
    },
    some($where, value) {
      assertAllowed57(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    none($where, value) {
      assertAllowed57(value, "object");
      if (value == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = $where.notPlan().existsPlan({
          tableExpression,
          alias
        });
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    },
    aggregates($where, input) {
      if (input == null) return;
      if (!$where.extensions.pgFilterRelation) throw new Error("Invalid use of filter, 'pgFilterRelation' expected");
      const {
          localAttributes,
          remoteAttributes,
          tableExpression,
          alias
        } = $where.extensions.pgFilterRelation,
        $subQuery = new PgAggregateCondition($where, {
          sql,
          tableExpression,
          alias
        }, pgWhereConditionSpecListToSQL);
      localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = remoteAttributes[i];
        $subQuery.where(sql`${$where.alias}.${sql.identifier(localAttribute)} = ${$subQuery.alias}.${sql.identifier(remoteAttribute)}`);
      });
      return $subQuery;
    }
  },
  PostStatusAggregatesFilter: {
    filter($subquery, input) {
      if (input == null) return;
      return new PgCondition($subquery, !1, "AND");
    },
    distinctCount($subquery, input) {
      if (input == null) return;
      return $subquery.forAggregate(spec);
    }
  },
  PostStatusDistinctCountAggregateFilter: {
    rowId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("id")}`, spec_postStatus.attributes.id.codec)
      };
      return $col;
    },
    status($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("status")}`, spec_postStatus.attributes.status.codec)
      };
      return $col;
    },
    description($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("description")}`, spec_postStatus.attributes.description.codec)
      };
      return $col;
    },
    color($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("color")}`, spec_postStatus.attributes.color.codec)
      };
      return $col;
    },
    projectId($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("project_id")}`, spec_postStatus.attributes.project_id.codec)
      };
      return $col;
    },
    isDefault($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("is_default")}`, spec_postStatus.attributes.is_default.codec)
      };
      return $col;
    },
    createdAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("created_at")}`, spec_postStatus.attributes.created_at.codec)
      };
      return $col;
    },
    updatedAt($parent, input) {
      if (input == null) return;
      const $col = new PgCondition($parent);
      $col.extensions.pgFilterAttribute = {
        codec: TYPES.bigint,
        expression: spec.sqlAggregateWrap(sql`${$col.alias}.${sql.identifier("updated_at")}`, spec_postStatus.attributes.updated_at.codec)
      };
      return $col;
    }
  },
  ProjectOrderBy: {
    PRIMARY_KEY_ASC(queryBuilder) {
      projectUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "ASC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    PRIMARY_KEY_DESC(queryBuilder) {
      projectUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "DESC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    NAME_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "name",
        direction: "ASC"
      });
    },
    NAME_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "name",
        direction: "DESC"
      });
    },
    IMAGE_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "image",
        direction: "ASC"
      });
    },
    IMAGE_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "image",
        direction: "DESC"
      });
    },
    SLUG_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "slug",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    SLUG_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "slug",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    DESCRIPTION_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "description",
        direction: "ASC"
      });
    },
    DESCRIPTION_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "description",
        direction: "DESC"
      });
    },
    ORGANIZATION_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "organization_id",
        direction: "ASC"
      });
    },
    ORGANIZATION_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "organization_id",
        direction: "DESC"
      });
    },
    CREATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "ASC"
      });
    },
    CREATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "DESC"
      });
    },
    UPDATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "ASC"
      });
    },
    UPDATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "DESC"
      });
    },
    POSTS_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    POSTS_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_post.attributes.id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.id.codec) ?? spec_post.attributes.id.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_post.attributes.id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.id.codec) ?? spec_post.attributes.id.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_TITLE_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("title")}`, spec_post.attributes.title.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.title.codec) ?? spec_post.attributes.title.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_TITLE_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("title")}`, spec_post.attributes.title.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.title.codec) ?? spec_post.attributes.title.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_DESCRIPTION_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_post.attributes.description.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.description.codec) ?? spec_post.attributes.description.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_DESCRIPTION_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_post.attributes.description.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.description.codec) ?? spec_post.attributes.description.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_PROJECT_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_post.attributes.project_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.project_id.codec) ?? spec_post.attributes.project_id.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_PROJECT_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_post.attributes.project_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.project_id.codec) ?? spec_post.attributes.project_id.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_USER_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_post.attributes.user_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.user_id.codec) ?? spec_post.attributes.user_id.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_USER_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_post.attributes.user_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.user_id.codec) ?? spec_post.attributes.user_id.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_post.attributes.created_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.created_at.codec) ?? spec_post.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_post.attributes.created_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.created_at.codec) ?? spec_post.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_post.attributes.updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.updated_at.codec) ?? spec_post.attributes.updated_at.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_post.attributes.updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.updated_at.codec) ?? spec_post.attributes.updated_at.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_STATUS_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_id")}`, spec_post.attributes.status_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.status_id.codec) ?? spec_post.attributes.status_id.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_STATUS_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_id")}`, spec_post.attributes.status_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.status_id.codec) ?? spec_post.attributes.status_id.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_updated_at")}`, spec_post.attributes.status_updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.status_updated_at.codec) ?? spec_post.attributes.status_updated_at.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_updated_at")}`, spec_post.attributes.status_updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.status_updated_at.codec) ?? spec_post.attributes.status_updated_at.codec,
        direction: "DESC"
      });
    },
    POST_STATUSES_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    POST_STATUSES_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_postStatus.attributes.id.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.id.codec) ?? spec_postStatus.attributes.id.codec,
        direction: "ASC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_postStatus.attributes.id.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.id.codec) ?? spec_postStatus.attributes.id.codec,
        direction: "DESC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_STATUS_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status")}`, spec_postStatus.attributes.status.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.status.codec) ?? spec_postStatus.attributes.status.codec,
        direction: "ASC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_STATUS_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status")}`, spec_postStatus.attributes.status.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.status.codec) ?? spec_postStatus.attributes.status.codec,
        direction: "DESC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_DESCRIPTION_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_postStatus.attributes.description.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.description.codec) ?? spec_postStatus.attributes.description.codec,
        direction: "ASC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_DESCRIPTION_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_postStatus.attributes.description.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.description.codec) ?? spec_postStatus.attributes.description.codec,
        direction: "DESC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_COLOR_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("color")}`, spec_postStatus.attributes.color.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.color.codec) ?? spec_postStatus.attributes.color.codec,
        direction: "ASC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_COLOR_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("color")}`, spec_postStatus.attributes.color.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.color.codec) ?? spec_postStatus.attributes.color.codec,
        direction: "DESC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_PROJECT_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_postStatus.attributes.project_id.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.project_id.codec) ?? spec_postStatus.attributes.project_id.codec,
        direction: "ASC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_PROJECT_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_postStatus.attributes.project_id.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.project_id.codec) ?? spec_postStatus.attributes.project_id.codec,
        direction: "DESC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_IS_DEFAULT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("is_default")}`, spec_postStatus.attributes.is_default.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.is_default.codec) ?? spec_postStatus.attributes.is_default.codec,
        direction: "ASC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_IS_DEFAULT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("is_default")}`, spec_postStatus.attributes.is_default.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.is_default.codec) ?? spec_postStatus.attributes.is_default.codec,
        direction: "DESC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_postStatus.attributes.created_at.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.created_at.codec) ?? spec_postStatus.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_postStatus.attributes.created_at.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.created_at.codec) ?? spec_postStatus.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_postStatus.attributes.updated_at.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.updated_at.codec) ?? spec_postStatus.attributes.updated_at.codec,
        direction: "ASC"
      });
    },
    POST_STATUSES_DISTINCT_COUNT_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_post_statusPgResource.name));
      relation2.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation2.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_post_statusPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_postStatus.attributes.updated_at.codec)}
from ${resource_post_statusPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_postStatus.attributes.updated_at.codec) ?? spec_postStatus.attributes.updated_at.codec,
        direction: "DESC"
      });
    }
  },
  MemberConnection: {
    __assertStep: ConnectionStep,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy(_$parent, $pgSelect, input) {
          return input.apply($pgSelect);
        },
        having(_$parent, $pgSelect, input) {
          return input.apply($pgSelect, queryBuilder => queryBuilder.havingBuilder());
        }
      }
    }
  },
  Member: {
    __assertStep: assertPgClassSingleStep,
    userId($record) {
      return $record.get("user_id");
    },
    organizationId($record) {
      return $record.get("organization_id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    rowId($record) {
      return $record.get("id");
    },
    organization($record) {
      return resource_organizationPgResource.get({
        id: $record.get("organization_id")
      });
    },
    user($record) {
      return resource_userPgResource.get({
        id: $record.get("user_id")
      });
    }
  },
  User: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    hidraId($record) {
      return $record.get("hidra_id");
    },
    firstName($record) {
      return $record.get("first_name");
    },
    lastName($record) {
      return $record.get("last_name");
    },
    posts: {
      plan($record) {
        const $records = resource_postPgResource.find({
          user_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed58(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    upvotes: {
      plan($record) {
        const $records = resource_upvotePgResource.find({
          user_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed59(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    members: {
      plan($record) {
        const $records = resource_memberPgResource.find({
          user_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed60(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    comments: {
      plan($record) {
        const $records = resource_commentPgResource.find({
          user_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed61(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    },
    downvotes: {
      plan($record) {
        const $records = resource_downvotePgResource.find({
          user_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed62(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    }
  },
  PostConnection: {
    __assertStep: ConnectionStep,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy(_$parent, $pgSelect, input) {
          return input.apply($pgSelect);
        },
        having(_$parent, $pgSelect, input) {
          return input.apply($pgSelect, queryBuilder => queryBuilder.havingBuilder());
        }
      }
    }
  },
  PostEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PostAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const $groupDetails = $pgSelectSingle.getClassStep().getGroupDetails();
      return lambda([$groupDetails, $pgSelectSingle], ([groupDetails, item]) => {
        if (groupDetails.indicies.length === 0 || item == null) return null;else return groupDetails.indicies.map(({
          index
        }) => item[index]);
      });
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  PostDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    title($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("title")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    description($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("description")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    projectId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("project_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    userId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("user_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    statusId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("status_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    statusUpdatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("status_updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  PostGroupBy: {
    TITLE($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("title")}`,
        codec: TYPES.text
      });
    },
    DESCRIPTION($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("description")}`,
        codec: TYPES.text
      });
    },
    PROJECT_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("project_id")}`,
        codec: TYPES.uuid
      });
    },
    USER_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("user_id")}`,
        codec: TYPES.uuid
      });
    },
    CREATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`,
        codec: TYPES.timestamptz
      });
    },
    CREATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    CREATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`,
        codec: TYPES.timestamptz
      });
    },
    UPDATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    STATUS_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("status_id")}`,
        codec: TYPES.uuid
      });
    },
    STATUS_UPDATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("status_updated_at")}`,
        codec: TYPES.timestamptz
      });
    },
    STATUS_UPDATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("status_updated_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    STATUS_UPDATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("status_updated_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    }
  },
  PostHavingInput: {
    AND($where) {
      return $where;
    },
    OR($where) {
      return new PgOrFilter($where);
    },
    sum($having) {
      return $having;
    },
    distinctCount($having) {
      return $having;
    },
    min($having) {
      return $having;
    },
    max($having) {
      return $having;
    },
    average($having) {
      return $having;
    },
    stddevSample($having) {
      return $having;
    },
    stddevPopulation($having) {
      return $having;
    },
    varianceSample($having) {
      return $having;
    },
    variancePopulation($having) {
      return $having;
    }
  },
  PostHavingSumInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    statusUpdatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostHavingDistinctCountInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    statusUpdatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostHavingMinInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    statusUpdatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostHavingMaxInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    statusUpdatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostHavingAverageInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    statusUpdatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostHavingStddevSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    statusUpdatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostHavingStddevPopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    statusUpdatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostHavingVarianceSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    statusUpdatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostHavingVariancePopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_post.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_post.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    statusUpdatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("status_updated_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_post.attributes.status_updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostCondition: {
    rowId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    title($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "title",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    description($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "description",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    projectId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "project_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    userId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "user_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    createdAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "created_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    },
    updatedAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "updated_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    },
    statusId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "status_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    statusUpdatedAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "status_updated_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    }
  },
  PostOrderBy: {
    PRIMARY_KEY_ASC(queryBuilder) {
      postUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "ASC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    PRIMARY_KEY_DESC(queryBuilder) {
      postUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "DESC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    TITLE_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "title",
        direction: "ASC"
      });
    },
    TITLE_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "title",
        direction: "DESC"
      });
    },
    DESCRIPTION_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "description",
        direction: "ASC"
      });
    },
    DESCRIPTION_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "description",
        direction: "DESC"
      });
    },
    PROJECT_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "project_id",
        direction: "ASC"
      });
    },
    PROJECT_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "project_id",
        direction: "DESC"
      });
    },
    USER_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "user_id",
        direction: "ASC"
      });
    },
    USER_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "user_id",
        direction: "DESC"
      });
    },
    CREATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "ASC"
      });
    },
    CREATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "DESC"
      });
    },
    UPDATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "ASC"
      });
    },
    UPDATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "DESC"
      });
    },
    STATUS_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "status_id",
        direction: "ASC"
      });
    },
    STATUS_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "status_id",
        direction: "DESC"
      });
    },
    STATUS_UPDATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "status_updated_at",
        direction: "ASC"
      });
    },
    STATUS_UPDATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "status_updated_at",
        direction: "DESC"
      });
    },
    UPVOTES_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation3.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation3.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    UPVOTES_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation3.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation3.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    UPVOTES_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation3.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation3.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_upvote.attributes.id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.id.codec) ?? spec_upvote.attributes.id.codec,
        direction: "ASC"
      });
    },
    UPVOTES_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation3.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation3.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_upvote.attributes.id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.id.codec) ?? spec_upvote.attributes.id.codec,
        direction: "DESC"
      });
    },
    UPVOTES_DISTINCT_COUNT_POST_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation3.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation3.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_upvote.attributes.post_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.post_id.codec) ?? spec_upvote.attributes.post_id.codec,
        direction: "ASC"
      });
    },
    UPVOTES_DISTINCT_COUNT_POST_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation3.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation3.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_upvote.attributes.post_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.post_id.codec) ?? spec_upvote.attributes.post_id.codec,
        direction: "DESC"
      });
    },
    UPVOTES_DISTINCT_COUNT_USER_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation3.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation3.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_upvote.attributes.user_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.user_id.codec) ?? spec_upvote.attributes.user_id.codec,
        direction: "ASC"
      });
    },
    UPVOTES_DISTINCT_COUNT_USER_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation3.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation3.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_upvote.attributes.user_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.user_id.codec) ?? spec_upvote.attributes.user_id.codec,
        direction: "DESC"
      });
    },
    UPVOTES_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation3.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation3.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_upvote.attributes.created_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.created_at.codec) ?? spec_upvote.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    UPVOTES_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation3.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation3.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_upvote.attributes.created_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.created_at.codec) ?? spec_upvote.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    UPVOTES_DISTINCT_COUNT_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation3.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation3.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_upvote.attributes.updated_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.updated_at.codec) ?? spec_upvote.attributes.updated_at.codec,
        direction: "ASC"
      });
    },
    UPVOTES_DISTINCT_COUNT_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation3.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation3.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_upvote.attributes.updated_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.updated_at.codec) ?? spec_upvote.attributes.updated_at.codec,
        direction: "DESC"
      });
    },
    COMMENTS_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    COMMENTS_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    COMMENTS_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_comment.attributes.id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.id.codec) ?? spec_comment.attributes.id.codec,
        direction: "ASC"
      });
    },
    COMMENTS_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_comment.attributes.id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.id.codec) ?? spec_comment.attributes.id.codec,
        direction: "DESC"
      });
    },
    COMMENTS_DISTINCT_COUNT_MESSAGE_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("message")}`, spec_comment.attributes.message.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.message.codec) ?? spec_comment.attributes.message.codec,
        direction: "ASC"
      });
    },
    COMMENTS_DISTINCT_COUNT_MESSAGE_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("message")}`, spec_comment.attributes.message.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.message.codec) ?? spec_comment.attributes.message.codec,
        direction: "DESC"
      });
    },
    COMMENTS_DISTINCT_COUNT_POST_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_comment.attributes.post_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.post_id.codec) ?? spec_comment.attributes.post_id.codec,
        direction: "ASC"
      });
    },
    COMMENTS_DISTINCT_COUNT_POST_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_comment.attributes.post_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.post_id.codec) ?? spec_comment.attributes.post_id.codec,
        direction: "DESC"
      });
    },
    COMMENTS_DISTINCT_COUNT_USER_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_comment.attributes.user_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.user_id.codec) ?? spec_comment.attributes.user_id.codec,
        direction: "ASC"
      });
    },
    COMMENTS_DISTINCT_COUNT_USER_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_comment.attributes.user_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.user_id.codec) ?? spec_comment.attributes.user_id.codec,
        direction: "DESC"
      });
    },
    COMMENTS_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_comment.attributes.created_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.created_at.codec) ?? spec_comment.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    COMMENTS_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_comment.attributes.created_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.created_at.codec) ?? spec_comment.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    COMMENTS_DISTINCT_COUNT_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_comment.attributes.updated_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.updated_at.codec) ?? spec_comment.attributes.updated_at.codec,
        direction: "ASC"
      });
    },
    COMMENTS_DISTINCT_COUNT_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_comment.attributes.updated_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.updated_at.codec) ?? spec_comment.attributes.updated_at.codec,
        direction: "DESC"
      });
    },
    COMMENTS_DISTINCT_COUNT_PARENT_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("parent_id")}`, spec_comment.attributes.parent_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.parent_id.codec) ?? spec_comment.attributes.parent_id.codec,
        direction: "ASC"
      });
    },
    COMMENTS_DISTINCT_COUNT_PARENT_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation4.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation4.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("parent_id")}`, spec_comment.attributes.parent_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.parent_id.codec) ?? spec_comment.attributes.parent_id.codec,
        direction: "DESC"
      });
    },
    DOWNVOTES_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation5.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation5.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    DOWNVOTES_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation5.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation5.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation5.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation5.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_downvote.attributes.id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.id.codec) ?? spec_downvote.attributes.id.codec,
        direction: "ASC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation5.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation5.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_downvote.attributes.id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.id.codec) ?? spec_downvote.attributes.id.codec,
        direction: "DESC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_POST_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation5.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation5.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_downvote.attributes.post_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.post_id.codec) ?? spec_downvote.attributes.post_id.codec,
        direction: "ASC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_POST_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation5.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation5.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_downvote.attributes.post_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.post_id.codec) ?? spec_downvote.attributes.post_id.codec,
        direction: "DESC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_USER_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation5.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation5.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_downvote.attributes.user_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.user_id.codec) ?? spec_downvote.attributes.user_id.codec,
        direction: "ASC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_USER_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation5.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation5.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_downvote.attributes.user_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.user_id.codec) ?? spec_downvote.attributes.user_id.codec,
        direction: "DESC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation5.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation5.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_downvote.attributes.created_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.created_at.codec) ?? spec_downvote.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation5.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation5.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_downvote.attributes.created_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.created_at.codec) ?? spec_downvote.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation5.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation5.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_downvote.attributes.updated_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.updated_at.codec) ?? spec_downvote.attributes.updated_at.codec,
        direction: "ASC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation5.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation5.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_downvote.attributes.updated_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.updated_at.codec) ?? spec_downvote.attributes.updated_at.codec,
        direction: "DESC"
      });
    }
  },
  UpvoteConnection: {
    __assertStep: ConnectionStep,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy(_$parent, $pgSelect, input) {
          return input.apply($pgSelect);
        },
        having(_$parent, $pgSelect, input) {
          return input.apply($pgSelect, queryBuilder => queryBuilder.havingBuilder());
        }
      }
    }
  },
  Upvote: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    postId($record) {
      return $record.get("post_id");
    },
    userId($record) {
      return $record.get("user_id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    post($record) {
      return resource_postPgResource.get({
        id: $record.get("post_id")
      });
    },
    user($record) {
      return resource_userPgResource.get({
        id: $record.get("user_id")
      });
    }
  },
  UpvoteEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  UpvoteAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const $groupDetails = $pgSelectSingle.getClassStep().getGroupDetails();
      return lambda([$groupDetails, $pgSelectSingle], ([groupDetails, item]) => {
        if (groupDetails.indicies.length === 0 || item == null) return null;else return groupDetails.indicies.map(({
          index
        }) => item[index]);
      });
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  UpvoteDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    postId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("post_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    userId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("user_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  UpvoteGroupBy: {
    POST_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("post_id")}`,
        codec: TYPES.uuid
      });
    },
    USER_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("user_id")}`,
        codec: TYPES.uuid
      });
    },
    CREATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`,
        codec: TYPES.timestamptz
      });
    },
    CREATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    CREATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`,
        codec: TYPES.timestamptz
      });
    },
    UPDATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    }
  },
  UpvoteHavingInput: {
    AND($where) {
      return $where;
    },
    OR($where) {
      return new PgOrFilter($where);
    },
    sum($having) {
      return $having;
    },
    distinctCount($having) {
      return $having;
    },
    min($having) {
      return $having;
    },
    max($having) {
      return $having;
    },
    average($having) {
      return $having;
    },
    stddevSample($having) {
      return $having;
    },
    stddevPopulation($having) {
      return $having;
    },
    varianceSample($having) {
      return $having;
    },
    variancePopulation($having) {
      return $having;
    }
  },
  UpvoteHavingSumInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UpvoteHavingDistinctCountInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UpvoteHavingMinInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UpvoteHavingMaxInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UpvoteHavingAverageInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UpvoteHavingStddevSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UpvoteHavingStddevPopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UpvoteHavingVarianceSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UpvoteHavingVariancePopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_upvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UpvoteCondition: {
    rowId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    postId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "post_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    userId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "user_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    createdAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "created_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    },
    updatedAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "updated_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    }
  },
  UpvoteOrderBy: {
    PRIMARY_KEY_ASC(queryBuilder) {
      upvoteUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "ASC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    PRIMARY_KEY_DESC(queryBuilder) {
      upvoteUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "DESC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    POST_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "post_id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    POST_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "post_id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    USER_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "user_id",
        direction: "ASC"
      });
    },
    USER_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "user_id",
        direction: "DESC"
      });
    },
    CREATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "ASC"
      });
    },
    CREATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "DESC"
      });
    },
    UPDATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "ASC"
      });
    },
    UPDATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "DESC"
      });
    }
  },
  MemberCondition: {
    userId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "user_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    organizationId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "organization_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    createdAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "created_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    },
    role($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "role",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, roleCodec)}`;
        }
      });
    },
    rowId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    }
  },
  MemberOrderBy: {
    PRIMARY_KEY_ASC(queryBuilder) {
      memberUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "ASC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    PRIMARY_KEY_DESC(queryBuilder) {
      memberUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "DESC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    USER_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "user_id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    USER_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "user_id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    ORGANIZATION_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "organization_id",
        direction: "ASC"
      });
    },
    ORGANIZATION_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "organization_id",
        direction: "DESC"
      });
    },
    CREATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "ASC"
      });
    },
    CREATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "DESC"
      });
    },
    ROLE_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "role",
        direction: "ASC"
      });
    },
    ROLE_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "role",
        direction: "DESC"
      });
    },
    ROW_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    }
  },
  CommentConnection: {
    __assertStep: ConnectionStep,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy(_$parent, $pgSelect, input) {
          return input.apply($pgSelect);
        },
        having(_$parent, $pgSelect, input) {
          return input.apply($pgSelect, queryBuilder => queryBuilder.havingBuilder());
        }
      }
    }
  },
  Comment: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    postId($record) {
      return $record.get("post_id");
    },
    userId($record) {
      return $record.get("user_id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    parentId($record) {
      return $record.get("parent_id");
    },
    parent($record) {
      return resource_commentPgResource.get({
        id: $record.get("parent_id")
      });
    },
    post($record) {
      return resource_postPgResource.get({
        id: $record.get("post_id")
      });
    },
    user($record) {
      return resource_userPgResource.get({
        id: $record.get("user_id")
      });
    },
    childComments: {
      plan($record) {
        const $records = resource_commentPgResource.find({
          parent_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed63(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    }
  },
  CommentCondition: {
    rowId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    message($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "message",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    postId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "post_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    userId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "user_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    createdAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "created_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    },
    updatedAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "updated_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    },
    parentId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "parent_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    }
  },
  CommentOrderBy: {
    PRIMARY_KEY_ASC(queryBuilder) {
      commentUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "ASC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    PRIMARY_KEY_DESC(queryBuilder) {
      commentUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "DESC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    MESSAGE_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "message",
        direction: "ASC"
      });
    },
    MESSAGE_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "message",
        direction: "DESC"
      });
    },
    POST_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "post_id",
        direction: "ASC"
      });
    },
    POST_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "post_id",
        direction: "DESC"
      });
    },
    USER_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "user_id",
        direction: "ASC"
      });
    },
    USER_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "user_id",
        direction: "DESC"
      });
    },
    CREATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "ASC"
      });
    },
    CREATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "DESC"
      });
    },
    UPDATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "ASC"
      });
    },
    UPDATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "DESC"
      });
    },
    PARENT_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "parent_id",
        direction: "ASC"
      });
    },
    PARENT_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "parent_id",
        direction: "DESC"
      });
    },
    CHILD_COMMENTS_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    CHILD_COMMENTS_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    CHILD_COMMENTS_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_comment.attributes.id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.id.codec) ?? spec_comment.attributes.id.codec,
        direction: "ASC"
      });
    },
    CHILD_COMMENTS_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_comment.attributes.id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.id.codec) ?? spec_comment.attributes.id.codec,
        direction: "DESC"
      });
    },
    CHILD_COMMENTS_DISTINCT_COUNT_MESSAGE_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("message")}`, spec_comment.attributes.message.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.message.codec) ?? spec_comment.attributes.message.codec,
        direction: "ASC"
      });
    },
    CHILD_COMMENTS_DISTINCT_COUNT_MESSAGE_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("message")}`, spec_comment.attributes.message.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.message.codec) ?? spec_comment.attributes.message.codec,
        direction: "DESC"
      });
    },
    CHILD_COMMENTS_DISTINCT_COUNT_POST_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_comment.attributes.post_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.post_id.codec) ?? spec_comment.attributes.post_id.codec,
        direction: "ASC"
      });
    },
    CHILD_COMMENTS_DISTINCT_COUNT_POST_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_comment.attributes.post_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.post_id.codec) ?? spec_comment.attributes.post_id.codec,
        direction: "DESC"
      });
    },
    CHILD_COMMENTS_DISTINCT_COUNT_USER_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_comment.attributes.user_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.user_id.codec) ?? spec_comment.attributes.user_id.codec,
        direction: "ASC"
      });
    },
    CHILD_COMMENTS_DISTINCT_COUNT_USER_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_comment.attributes.user_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.user_id.codec) ?? spec_comment.attributes.user_id.codec,
        direction: "DESC"
      });
    },
    CHILD_COMMENTS_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_comment.attributes.created_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.created_at.codec) ?? spec_comment.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    CHILD_COMMENTS_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_comment.attributes.created_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.created_at.codec) ?? spec_comment.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    CHILD_COMMENTS_DISTINCT_COUNT_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_comment.attributes.updated_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.updated_at.codec) ?? spec_comment.attributes.updated_at.codec,
        direction: "ASC"
      });
    },
    CHILD_COMMENTS_DISTINCT_COUNT_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_comment.attributes.updated_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.updated_at.codec) ?? spec_comment.attributes.updated_at.codec,
        direction: "DESC"
      });
    },
    CHILD_COMMENTS_DISTINCT_COUNT_PARENT_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("parent_id")}`, spec_comment.attributes.parent_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.parent_id.codec) ?? spec_comment.attributes.parent_id.codec,
        direction: "ASC"
      });
    },
    CHILD_COMMENTS_DISTINCT_COUNT_PARENT_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation6.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation6.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("parent_id")}`, spec_comment.attributes.parent_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.parent_id.codec) ?? spec_comment.attributes.parent_id.codec,
        direction: "DESC"
      });
    }
  },
  CommentEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  CommentAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const $groupDetails = $pgSelectSingle.getClassStep().getGroupDetails();
      return lambda([$groupDetails, $pgSelectSingle], ([groupDetails, item]) => {
        if (groupDetails.indicies.length === 0 || item == null) return null;else return groupDetails.indicies.map(({
          index
        }) => item[index]);
      });
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  CommentDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    message($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("message")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    postId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("post_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    userId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("user_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    parentId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("parent_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  CommentGroupBy: {
    MESSAGE($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("message")}`,
        codec: TYPES.text
      });
    },
    POST_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("post_id")}`,
        codec: TYPES.uuid
      });
    },
    USER_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("user_id")}`,
        codec: TYPES.uuid
      });
    },
    CREATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`,
        codec: TYPES.timestamptz
      });
    },
    CREATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    CREATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`,
        codec: TYPES.timestamptz
      });
    },
    UPDATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    PARENT_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("parent_id")}`,
        codec: TYPES.uuid
      });
    }
  },
  CommentHavingInput: {
    AND($where) {
      return $where;
    },
    OR($where) {
      return new PgOrFilter($where);
    },
    sum($having) {
      return $having;
    },
    distinctCount($having) {
      return $having;
    },
    min($having) {
      return $having;
    },
    max($having) {
      return $having;
    },
    average($having) {
      return $having;
    },
    stddevSample($having) {
      return $having;
    },
    stddevPopulation($having) {
      return $having;
    },
    varianceSample($having) {
      return $having;
    },
    variancePopulation($having) {
      return $having;
    }
  },
  CommentHavingSumInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  CommentHavingDistinctCountInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  CommentHavingMinInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  CommentHavingMaxInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  CommentHavingAverageInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  CommentHavingStddevSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  CommentHavingStddevPopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  CommentHavingVarianceSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  CommentHavingVariancePopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_comment.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_comment.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  DownvoteConnection: {
    __assertStep: ConnectionStep,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy(_$parent, $pgSelect, input) {
          return input.apply($pgSelect);
        },
        having(_$parent, $pgSelect, input) {
          return input.apply($pgSelect, queryBuilder => queryBuilder.havingBuilder());
        }
      }
    }
  },
  DownvoteEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  DownvoteAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const $groupDetails = $pgSelectSingle.getClassStep().getGroupDetails();
      return lambda([$groupDetails, $pgSelectSingle], ([groupDetails, item]) => {
        if (groupDetails.indicies.length === 0 || item == null) return null;else return groupDetails.indicies.map(({
          index
        }) => item[index]);
      });
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  DownvoteDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    postId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("post_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    userId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("user_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  DownvoteGroupBy: {
    POST_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("post_id")}`,
        codec: TYPES.uuid
      });
    },
    USER_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("user_id")}`,
        codec: TYPES.uuid
      });
    },
    CREATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`,
        codec: TYPES.timestamptz
      });
    },
    CREATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    CREATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`,
        codec: TYPES.timestamptz
      });
    },
    UPDATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    }
  },
  DownvoteHavingInput: {
    AND($where) {
      return $where;
    },
    OR($where) {
      return new PgOrFilter($where);
    },
    sum($having) {
      return $having;
    },
    distinctCount($having) {
      return $having;
    },
    min($having) {
      return $having;
    },
    max($having) {
      return $having;
    },
    average($having) {
      return $having;
    },
    stddevSample($having) {
      return $having;
    },
    stddevPopulation($having) {
      return $having;
    },
    varianceSample($having) {
      return $having;
    },
    variancePopulation($having) {
      return $having;
    }
  },
  DownvoteHavingSumInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  DownvoteHavingDistinctCountInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  DownvoteHavingMinInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  DownvoteHavingMaxInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  DownvoteHavingAverageInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  DownvoteHavingStddevSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  DownvoteHavingStddevPopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  DownvoteHavingVarianceSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  DownvoteHavingVariancePopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_downvote.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  DownvoteCondition: {
    rowId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    postId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "post_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    userId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "user_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    createdAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "created_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    },
    updatedAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "updated_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    }
  },
  DownvoteOrderBy: {
    PRIMARY_KEY_ASC(queryBuilder) {
      downvoteUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "ASC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    PRIMARY_KEY_DESC(queryBuilder) {
      downvoteUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "DESC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    POST_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "post_id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    POST_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "post_id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    USER_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "user_id",
        direction: "ASC"
      });
    },
    USER_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "user_id",
        direction: "DESC"
      });
    },
    CREATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "ASC"
      });
    },
    CREATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "DESC"
      });
    },
    UPDATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "ASC"
      });
    },
    UPDATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "DESC"
      });
    }
  },
  MemberEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  MemberAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const $groupDetails = $pgSelectSingle.getClassStep().getGroupDetails();
      return lambda([$groupDetails, $pgSelectSingle], ([groupDetails, item]) => {
        if (groupDetails.indicies.length === 0 || item == null) return null;else return groupDetails.indicies.map(({
          index
        }) => item[index]);
      });
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  MemberDistinctCountAggregates: {
    userId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("user_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    organizationId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("organization_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    role($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("role")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, roleCodec);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  MemberGroupBy: {
    USER_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("user_id")}`,
        codec: TYPES.uuid
      });
    },
    ORGANIZATION_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("organization_id")}`,
        codec: TYPES.uuid
      });
    },
    CREATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`,
        codec: TYPES.timestamptz
      });
    },
    CREATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    CREATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    ROLE($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("role")}`,
        codec: roleCodec
      });
    }
  },
  MemberHavingInput: {
    AND($where) {
      return $where;
    },
    OR($where) {
      return new PgOrFilter($where);
    },
    sum($having) {
      return $having;
    },
    distinctCount($having) {
      return $having;
    },
    min($having) {
      return $having;
    },
    max($having) {
      return $having;
    },
    average($having) {
      return $having;
    },
    stddevSample($having) {
      return $having;
    },
    stddevPopulation($having) {
      return $having;
    },
    varianceSample($having) {
      return $having;
    },
    variancePopulation($having) {
      return $having;
    }
  },
  MemberHavingSumInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  MemberHavingDistinctCountInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  MemberHavingMinInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  MemberHavingMaxInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  MemberHavingAverageInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  MemberHavingStddevSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  MemberHavingStddevPopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  MemberHavingVarianceSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  MemberHavingVariancePopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_member.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  InvitationConnection: {
    __assertStep: ConnectionStep,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy(_$parent, $pgSelect, input) {
          return input.apply($pgSelect);
        },
        having(_$parent, $pgSelect, input) {
          return input.apply($pgSelect, queryBuilder => queryBuilder.havingBuilder());
        }
      }
    }
  },
  Invitation: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    organizationId($record) {
      return $record.get("organization_id");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    organization($record) {
      return resource_organizationPgResource.get({
        id: $record.get("organization_id")
      });
    }
  },
  InvitationEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  InvitationAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const $groupDetails = $pgSelectSingle.getClassStep().getGroupDetails();
      return lambda([$groupDetails, $pgSelectSingle], ([groupDetails, item]) => {
        if (groupDetails.indicies.length === 0 || item == null) return null;else return groupDetails.indicies.map(({
          index
        }) => item[index]);
      });
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  InvitationDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    organizationId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("organization_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    email($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("email")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  InvitationGroupBy: {
    ORGANIZATION_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("organization_id")}`,
        codec: TYPES.uuid
      });
    },
    EMAIL($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("email")}`,
        codec: TYPES.text
      });
    },
    CREATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`,
        codec: TYPES.timestamptz
      });
    },
    CREATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    CREATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`,
        codec: TYPES.timestamptz
      });
    },
    UPDATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    }
  },
  InvitationHavingInput: {
    AND($where) {
      return $where;
    },
    OR($where) {
      return new PgOrFilter($where);
    },
    sum($having) {
      return $having;
    },
    distinctCount($having) {
      return $having;
    },
    min($having) {
      return $having;
    },
    max($having) {
      return $having;
    },
    average($having) {
      return $having;
    },
    stddevSample($having) {
      return $having;
    },
    stddevPopulation($having) {
      return $having;
    },
    varianceSample($having) {
      return $having;
    },
    variancePopulation($having) {
      return $having;
    }
  },
  InvitationHavingSumInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  InvitationHavingDistinctCountInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  InvitationHavingMinInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  InvitationHavingMaxInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  InvitationHavingAverageInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  InvitationHavingStddevSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  InvitationHavingStddevPopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  InvitationHavingVarianceSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  InvitationHavingVariancePopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_invitation.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  InvitationCondition: {
    rowId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    organizationId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "organization_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    email($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "email",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    createdAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "created_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    },
    updatedAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "updated_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    }
  },
  InvitationOrderBy: {
    PRIMARY_KEY_ASC(queryBuilder) {
      invitationUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "ASC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    PRIMARY_KEY_DESC(queryBuilder) {
      invitationUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "DESC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    ORGANIZATION_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "organization_id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    ORGANIZATION_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "organization_id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    EMAIL_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "email",
        direction: "ASC"
      });
    },
    EMAIL_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "email",
        direction: "DESC"
      });
    },
    CREATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "ASC"
      });
    },
    CREATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "DESC"
      });
    },
    UPDATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "ASC"
      });
    },
    UPDATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "DESC"
      });
    }
  },
  PostStatusConnection: {
    __assertStep: ConnectionStep,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy(_$parent, $pgSelect, input) {
          return input.apply($pgSelect);
        },
        having(_$parent, $pgSelect, input) {
          return input.apply($pgSelect, queryBuilder => queryBuilder.havingBuilder());
        }
      }
    }
  },
  PostStatus: {
    __assertStep: assertPgClassSingleStep,
    rowId($record) {
      return $record.get("id");
    },
    projectId($record) {
      return $record.get("project_id");
    },
    isDefault($record) {
      return $record.get("is_default");
    },
    createdAt($record) {
      return $record.get("created_at");
    },
    updatedAt($record) {
      return $record.get("updated_at");
    },
    project($record) {
      return resource_projectPgResource.get({
        id: $record.get("project_id")
      });
    },
    postsByStatusId: {
      plan($record) {
        const $records = resource_postPgResource.find({
          status_id: $record.get("id")
        });
        return connection($records);
      },
      args: {
        first(_, $connection, arg) {
          $connection.setFirst(arg.getRaw());
        },
        last(_, $connection, val) {
          $connection.setLast(val.getRaw());
        },
        offset(_, $connection, val) {
          $connection.setOffset(val.getRaw());
        },
        before(_, $connection, val) {
          $connection.setBefore(val.getRaw());
        },
        after(_, $connection, val) {
          $connection.setAfter(val.getRaw());
        },
        condition(_condition, $connection, arg) {
          const $select = $connection.getSubplan();
          arg.apply($select, qbWhereBuilder);
        },
        filter(_, $connection, fieldArg) {
          const $pgSelect = $connection.getSubplan();
          fieldArg.apply($pgSelect, (queryBuilder, value) => {
            assertAllowed64(value, "object");
            if (value == null) return;
            const condition = new PgCondition(queryBuilder);
            return condition;
          });
        },
        orderBy(parent, $connection, value) {
          const $select = $connection.getSubplan();
          value.apply($select);
        }
      }
    }
  },
  PostStatusEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  PostStatusAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const $groupDetails = $pgSelectSingle.getClassStep().getGroupDetails();
      return lambda([$groupDetails, $pgSelectSingle], ([groupDetails, item]) => {
        if (groupDetails.indicies.length === 0 || item == null) return null;else return groupDetails.indicies.map(({
          index
        }) => item[index]);
      });
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  PostStatusDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    status($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("status")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    description($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("description")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    color($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("color")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    projectId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("project_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    isDefault($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("is_default")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.boolean);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  PostStatusGroupBy: {
    STATUS($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("status")}`,
        codec: TYPES.text
      });
    },
    DESCRIPTION($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("description")}`,
        codec: TYPES.text
      });
    },
    COLOR($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("color")}`,
        codec: TYPES.text
      });
    },
    PROJECT_ID($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("project_id")}`,
        codec: TYPES.uuid
      });
    },
    IS_DEFAULT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("is_default")}`,
        codec: TYPES.boolean
      });
    },
    CREATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`,
        codec: TYPES.timestamptz
      });
    },
    CREATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    CREATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`,
        codec: TYPES.timestamptz
      });
    },
    UPDATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    }
  },
  PostStatusHavingInput: {
    AND($where) {
      return $where;
    },
    OR($where) {
      return new PgOrFilter($where);
    },
    sum($having) {
      return $having;
    },
    distinctCount($having) {
      return $having;
    },
    min($having) {
      return $having;
    },
    max($having) {
      return $having;
    },
    average($having) {
      return $having;
    },
    stddevSample($having) {
      return $having;
    },
    stddevPopulation($having) {
      return $having;
    },
    varianceSample($having) {
      return $having;
    },
    variancePopulation($having) {
      return $having;
    }
  },
  PostStatusHavingSumInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostStatusHavingDistinctCountInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostStatusHavingMinInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostStatusHavingMaxInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostStatusHavingAverageInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostStatusHavingStddevSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostStatusHavingStddevPopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostStatusHavingVarianceSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostStatusHavingVariancePopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_postStatus.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  PostStatusCondition: {
    rowId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    status($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "status",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    description($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "description",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    color($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "color",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    projectId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "project_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    isDefault($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "is_default",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.boolean)}`;
        }
      });
    },
    createdAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "created_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    },
    updatedAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "updated_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    }
  },
  PostStatusOrderBy: {
    PRIMARY_KEY_ASC(queryBuilder) {
      post_statusUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "ASC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    PRIMARY_KEY_DESC(queryBuilder) {
      post_statusUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "DESC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    STATUS_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "status",
        direction: "ASC"
      });
    },
    STATUS_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "status",
        direction: "DESC"
      });
    },
    DESCRIPTION_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "description",
        direction: "ASC"
      });
    },
    DESCRIPTION_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "description",
        direction: "DESC"
      });
    },
    COLOR_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "color",
        direction: "ASC"
      });
    },
    COLOR_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "color",
        direction: "DESC"
      });
    },
    PROJECT_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "project_id",
        direction: "ASC"
      });
    },
    PROJECT_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "project_id",
        direction: "DESC"
      });
    },
    IS_DEFAULT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "is_default",
        direction: "ASC"
      });
    },
    IS_DEFAULT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "is_default",
        direction: "DESC"
      });
    },
    CREATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "ASC"
      });
    },
    CREATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "DESC"
      });
    },
    UPDATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "ASC"
      });
    },
    UPDATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "DESC"
      });
    },
    POSTS_BY_STATUS_ID_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    POSTS_BY_STATUS_ID_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_post.attributes.id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.id.codec) ?? spec_post.attributes.id.codec,
        direction: "ASC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_post.attributes.id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.id.codec) ?? spec_post.attributes.id.codec,
        direction: "DESC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_TITLE_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("title")}`, spec_post.attributes.title.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.title.codec) ?? spec_post.attributes.title.codec,
        direction: "ASC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_TITLE_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("title")}`, spec_post.attributes.title.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.title.codec) ?? spec_post.attributes.title.codec,
        direction: "DESC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_DESCRIPTION_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_post.attributes.description.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.description.codec) ?? spec_post.attributes.description.codec,
        direction: "ASC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_DESCRIPTION_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_post.attributes.description.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.description.codec) ?? spec_post.attributes.description.codec,
        direction: "DESC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_PROJECT_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_post.attributes.project_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.project_id.codec) ?? spec_post.attributes.project_id.codec,
        direction: "ASC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_PROJECT_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_post.attributes.project_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.project_id.codec) ?? spec_post.attributes.project_id.codec,
        direction: "DESC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_USER_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_post.attributes.user_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.user_id.codec) ?? spec_post.attributes.user_id.codec,
        direction: "ASC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_USER_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_post.attributes.user_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.user_id.codec) ?? spec_post.attributes.user_id.codec,
        direction: "DESC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_post.attributes.created_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.created_at.codec) ?? spec_post.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_post.attributes.created_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.created_at.codec) ?? spec_post.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_post.attributes.updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.updated_at.codec) ?? spec_post.attributes.updated_at.codec,
        direction: "ASC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_post.attributes.updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.updated_at.codec) ?? spec_post.attributes.updated_at.codec,
        direction: "DESC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_id")}`, spec_post.attributes.status_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.status_id.codec) ?? spec_post.attributes.status_id.codec,
        direction: "ASC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_id")}`, spec_post.attributes.status_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.status_id.codec) ?? spec_post.attributes.status_id.codec,
        direction: "DESC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_updated_at")}`, spec_post.attributes.status_updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.status_updated_at.codec) ?? spec_post.attributes.status_updated_at.codec,
        direction: "ASC"
      });
    },
    POSTS_BY_STATUS_ID_DISTINCT_COUNT_STATUS_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation7.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation7.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_updated_at")}`, spec_post.attributes.status_updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.status_updated_at.codec) ?? spec_post.attributes.status_updated_at.codec,
        direction: "DESC"
      });
    }
  },
  OrganizationConnection: {
    __assertStep: ConnectionStep,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy(_$parent, $pgSelect, input) {
          return input.apply($pgSelect);
        },
        having(_$parent, $pgSelect, input) {
          return input.apply($pgSelect, queryBuilder => queryBuilder.havingBuilder());
        }
      }
    }
  },
  OrganizationEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  OrganizationAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const $groupDetails = $pgSelectSingle.getClassStep().getGroupDetails();
      return lambda([$groupDetails, $pgSelectSingle], ([groupDetails, item]) => {
        if (groupDetails.indicies.length === 0 || item == null) return null;else return groupDetails.indicies.map(({
          index
        }) => item[index]);
      });
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  OrganizationDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    name($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("name")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    slug($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("slug")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  OrganizationGroupBy: {
    CREATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`,
        codec: TYPES.timestamptz
      });
    },
    CREATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    CREATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`,
        codec: TYPES.timestamptz
      });
    },
    UPDATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    }
  },
  OrganizationHavingInput: {
    AND($where) {
      return $where;
    },
    OR($where) {
      return new PgOrFilter($where);
    },
    sum($having) {
      return $having;
    },
    distinctCount($having) {
      return $having;
    },
    min($having) {
      return $having;
    },
    max($having) {
      return $having;
    },
    average($having) {
      return $having;
    },
    stddevSample($having) {
      return $having;
    },
    stddevPopulation($having) {
      return $having;
    },
    varianceSample($having) {
      return $having;
    },
    variancePopulation($having) {
      return $having;
    }
  },
  OrganizationHavingSumInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  OrganizationHavingDistinctCountInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  OrganizationHavingMinInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  OrganizationHavingMaxInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  OrganizationHavingAverageInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  OrganizationHavingStddevSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  OrganizationHavingStddevPopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  OrganizationHavingVarianceSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  OrganizationHavingVariancePopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_organization.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_organization.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  OrganizationCondition: {
    rowId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    name($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "name",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    slug($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "slug",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    createdAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "created_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    },
    updatedAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "updated_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    }
  },
  OrganizationOrderBy: {
    PRIMARY_KEY_ASC(queryBuilder) {
      organizationUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "ASC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    PRIMARY_KEY_DESC(queryBuilder) {
      organizationUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "DESC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    NAME_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "name",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    NAME_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "name",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    SLUG_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "slug",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    SLUG_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "slug",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    CREATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "ASC"
      });
    },
    CREATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "DESC"
      });
    },
    UPDATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "ASC"
      });
    },
    UPDATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "DESC"
      });
    },
    PROJECTS_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    PROJECTS_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    PROJECTS_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_project.attributes.id.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.id.codec) ?? spec_project.attributes.id.codec,
        direction: "ASC"
      });
    },
    PROJECTS_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_project.attributes.id.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.id.codec) ?? spec_project.attributes.id.codec,
        direction: "DESC"
      });
    },
    PROJECTS_DISTINCT_COUNT_NAME_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("name")}`, spec_project.attributes.name.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.name.codec) ?? spec_project.attributes.name.codec,
        direction: "ASC"
      });
    },
    PROJECTS_DISTINCT_COUNT_NAME_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("name")}`, spec_project.attributes.name.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.name.codec) ?? spec_project.attributes.name.codec,
        direction: "DESC"
      });
    },
    PROJECTS_DISTINCT_COUNT_IMAGE_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("image")}`, spec_project.attributes.image.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.image.codec) ?? spec_project.attributes.image.codec,
        direction: "ASC"
      });
    },
    PROJECTS_DISTINCT_COUNT_IMAGE_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("image")}`, spec_project.attributes.image.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.image.codec) ?? spec_project.attributes.image.codec,
        direction: "DESC"
      });
    },
    PROJECTS_DISTINCT_COUNT_SLUG_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("slug")}`, spec_project.attributes.slug.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.slug.codec) ?? spec_project.attributes.slug.codec,
        direction: "ASC"
      });
    },
    PROJECTS_DISTINCT_COUNT_SLUG_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("slug")}`, spec_project.attributes.slug.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.slug.codec) ?? spec_project.attributes.slug.codec,
        direction: "DESC"
      });
    },
    PROJECTS_DISTINCT_COUNT_DESCRIPTION_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_project.attributes.description.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.description.codec) ?? spec_project.attributes.description.codec,
        direction: "ASC"
      });
    },
    PROJECTS_DISTINCT_COUNT_DESCRIPTION_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_project.attributes.description.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.description.codec) ?? spec_project.attributes.description.codec,
        direction: "DESC"
      });
    },
    PROJECTS_DISTINCT_COUNT_ORGANIZATION_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_project.attributes.organization_id.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.organization_id.codec) ?? spec_project.attributes.organization_id.codec,
        direction: "ASC"
      });
    },
    PROJECTS_DISTINCT_COUNT_ORGANIZATION_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_project.attributes.organization_id.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.organization_id.codec) ?? spec_project.attributes.organization_id.codec,
        direction: "DESC"
      });
    },
    PROJECTS_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_project.attributes.created_at.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.created_at.codec) ?? spec_project.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    PROJECTS_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_project.attributes.created_at.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.created_at.codec) ?? spec_project.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    PROJECTS_DISTINCT_COUNT_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_project.attributes.updated_at.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.updated_at.codec) ?? spec_project.attributes.updated_at.codec,
        direction: "ASC"
      });
    },
    PROJECTS_DISTINCT_COUNT_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_projectPgResource.name));
      relation8.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation8.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_projectPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_project.attributes.updated_at.codec)}
from ${resource_projectPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_project.attributes.updated_at.codec) ?? spec_project.attributes.updated_at.codec,
        direction: "DESC"
      });
    },
    MEMBERS_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation9.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation9.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    MEMBERS_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation9.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation9.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    MEMBERS_DISTINCT_COUNT_USER_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation9.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation9.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_member.attributes.user_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.user_id.codec) ?? spec_member.attributes.user_id.codec,
        direction: "ASC"
      });
    },
    MEMBERS_DISTINCT_COUNT_USER_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation9.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation9.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_member.attributes.user_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.user_id.codec) ?? spec_member.attributes.user_id.codec,
        direction: "DESC"
      });
    },
    MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation9.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation9.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_member.attributes.organization_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.organization_id.codec) ?? spec_member.attributes.organization_id.codec,
        direction: "ASC"
      });
    },
    MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation9.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation9.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_member.attributes.organization_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.organization_id.codec) ?? spec_member.attributes.organization_id.codec,
        direction: "DESC"
      });
    },
    MEMBERS_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation9.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation9.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_member.attributes.created_at.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.created_at.codec) ?? spec_member.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    MEMBERS_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation9.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation9.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_member.attributes.created_at.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.created_at.codec) ?? spec_member.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    MEMBERS_DISTINCT_COUNT_ROLE_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation9.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation9.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("role")}`, spec_member.attributes.role.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.role.codec) ?? spec_member.attributes.role.codec,
        direction: "ASC"
      });
    },
    MEMBERS_DISTINCT_COUNT_ROLE_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation9.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation9.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("role")}`, spec_member.attributes.role.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.role.codec) ?? spec_member.attributes.role.codec,
        direction: "DESC"
      });
    },
    MEMBERS_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation9.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation9.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_member.attributes.id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.id.codec) ?? spec_member.attributes.id.codec,
        direction: "ASC"
      });
    },
    MEMBERS_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation9.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation9.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_member.attributes.id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.id.codec) ?? spec_member.attributes.id.codec,
        direction: "DESC"
      });
    },
    INVITATIONS_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
      relation10.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation10.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    INVITATIONS_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
      relation10.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation10.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    INVITATIONS_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
      relation10.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation10.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_invitation.attributes.id.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_invitation.attributes.id.codec) ?? spec_invitation.attributes.id.codec,
        direction: "ASC"
      });
    },
    INVITATIONS_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
      relation10.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation10.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_invitation.attributes.id.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_invitation.attributes.id.codec) ?? spec_invitation.attributes.id.codec,
        direction: "DESC"
      });
    },
    INVITATIONS_DISTINCT_COUNT_ORGANIZATION_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
      relation10.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation10.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_invitation.attributes.organization_id.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_invitation.attributes.organization_id.codec) ?? spec_invitation.attributes.organization_id.codec,
        direction: "ASC"
      });
    },
    INVITATIONS_DISTINCT_COUNT_ORGANIZATION_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
      relation10.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation10.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_invitation.attributes.organization_id.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_invitation.attributes.organization_id.codec) ?? spec_invitation.attributes.organization_id.codec,
        direction: "DESC"
      });
    },
    INVITATIONS_DISTINCT_COUNT_EMAIL_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
      relation10.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation10.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("email")}`, spec_invitation.attributes.email.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_invitation.attributes.email.codec) ?? spec_invitation.attributes.email.codec,
        direction: "ASC"
      });
    },
    INVITATIONS_DISTINCT_COUNT_EMAIL_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
      relation10.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation10.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("email")}`, spec_invitation.attributes.email.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_invitation.attributes.email.codec) ?? spec_invitation.attributes.email.codec,
        direction: "DESC"
      });
    },
    INVITATIONS_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
      relation10.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation10.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_invitation.attributes.created_at.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_invitation.attributes.created_at.codec) ?? spec_invitation.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    INVITATIONS_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
      relation10.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation10.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_invitation.attributes.created_at.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_invitation.attributes.created_at.codec) ?? spec_invitation.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    INVITATIONS_DISTINCT_COUNT_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
      relation10.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation10.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_invitation.attributes.updated_at.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_invitation.attributes.updated_at.codec) ?? spec_invitation.attributes.updated_at.codec,
        direction: "ASC"
      });
    },
    INVITATIONS_DISTINCT_COUNT_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_invitationPgResource.name));
      relation10.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation10.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_invitationPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_invitation.attributes.updated_at.codec)}
from ${resource_invitationPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_invitation.attributes.updated_at.codec) ?? spec_invitation.attributes.updated_at.codec,
        direction: "DESC"
      });
    }
  },
  UserConnection: {
    __assertStep: ConnectionStep,
    totalCount($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").singleAsRecord().select(sql`count(*)`, TYPES.bigint, !1);
    },
    aggregates($connection) {
      return $connection.cloneSubplanWithoutPagination("aggregate").single();
    },
    groupedAggregates: {
      plan($connection) {
        return $connection.cloneSubplanWithoutPagination("aggregate");
      },
      args: {
        groupBy(_$parent, $pgSelect, input) {
          return input.apply($pgSelect);
        },
        having(_$parent, $pgSelect, input) {
          return input.apply($pgSelect, queryBuilder => queryBuilder.havingBuilder());
        }
      }
    }
  },
  UserEdge: {
    __assertStep: assertEdgeCapableStep,
    cursor($edge) {
      return $edge.cursor();
    },
    node($edge) {
      return $edge.node();
    }
  },
  UserAggregates: {
    __assertStep: assertPgClassSingleStep,
    keys($pgSelectSingle) {
      const $groupDetails = $pgSelectSingle.getClassStep().getGroupDetails();
      return lambda([$groupDetails, $pgSelectSingle], ([groupDetails, item]) => {
        if (groupDetails.indicies.length === 0 || item == null) return null;else return groupDetails.indicies.map(({
          index
        }) => item[index]);
      });
    },
    distinctCount($pgSelectSingle) {
      return $pgSelectSingle;
    }
  },
  UserDistinctCountAggregates: {
    rowId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    createdAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("created_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    updatedAt($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("updated_at")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.timestamptz);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    hidraId($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("hidra_id")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.uuid);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    username($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("username")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    firstName($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("first_name")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    lastName($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("last_name")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    email($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("email")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, TYPES.text);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    },
    tier($pgSelectSingle) {
      const sqlAttribute = sql.fragment`${$pgSelectSingle.getClassStep().alias}.${sql.identifier("tier")}`,
        sqlAggregate = spec.sqlAggregateWrap(sqlAttribute, tierCodec);
      return $pgSelectSingle.select(sqlAggregate, TYPES.bigint);
    }
  },
  UserGroupBy: {
    CREATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("created_at")}`,
        codec: TYPES.timestamptz
      });
    },
    CREATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    CREATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("created_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("updated_at")}`,
        codec: TYPES.timestamptz
      });
    },
    UPDATED_AT_TRUNCATED_TO_HOUR($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    UPDATED_AT_TRUNCATED_TO_DAY($pgSelect) {
      $pgSelect.groupBy({
        fragment: aggregateGroupBySpec2.sqlWrap(sql`${$pgSelect.alias}.${sql.identifier("updated_at")}`),
        codec: aggregateGroupBySpec2.sqlWrapCodec(TYPES.timestamptz)
      });
    },
    FIRST_NAME($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("first_name")}`,
        codec: TYPES.text
      });
    },
    LAST_NAME($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("last_name")}`,
        codec: TYPES.text
      });
    },
    TIER($pgSelect) {
      $pgSelect.groupBy({
        fragment: sql.fragment`${$pgSelect.alias}.${sql.identifier("tier")}`,
        codec: tierCodec
      });
    }
  },
  UserHavingInput: {
    AND($where) {
      return $where;
    },
    OR($where) {
      return new PgOrFilter($where);
    },
    sum($having) {
      return $having;
    },
    distinctCount($having) {
      return $having;
    },
    min($having) {
      return $having;
    },
    max($having) {
      return $having;
    },
    average($having) {
      return $having;
    },
    stddevSample($having) {
      return $having;
    },
    stddevPopulation($having) {
      return $having;
    },
    varianceSample($having) {
      return $having;
    },
    variancePopulation($having) {
      return $having;
    }
  },
  UserHavingSumInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UserHavingDistinctCountInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = spec.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UserHavingMinInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec2.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UserHavingMaxInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec3.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UserHavingAverageInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec4.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UserHavingStddevSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec5.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UserHavingStddevPopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec6.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UserHavingVarianceSampleInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec7.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UserHavingVariancePopulationInput: {
    createdAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("created_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_user.attributes.created_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    },
    updatedAt($having) {
      const attributeExpression = sql.fragment`${$having.alias}.${sql.identifier("updated_at")}`,
        aggregateExpression = aggregateSpec8.sqlAggregateWrap(attributeExpression, spec_user.attributes.updated_at.codec);
      return new PgBooleanFilter($having, aggregateExpression);
    }
  },
  UserCondition: {
    rowId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    createdAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "created_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    },
    updatedAt($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "updated_at",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.timestamptz)}`;
        }
      });
    },
    hidraId($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "hidra_id",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.uuid)}`;
        }
      });
    },
    username($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "username",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    firstName($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "first_name",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    lastName($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "last_name",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    email($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "email",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, TYPES.text)}`;
        }
      });
    },
    tier($condition, val) {
      $condition.where({
        type: "attribute",
        attribute: "tier",
        callback(expression) {
          return val === null ? sql`${expression} is null` : sql`${expression} = ${sqlValueWithCodec(val, tierCodec)}`;
        }
      });
    }
  },
  UserOrderBy: {
    PRIMARY_KEY_ASC(queryBuilder) {
      userUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "ASC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    PRIMARY_KEY_DESC(queryBuilder) {
      userUniques[0].attributes.forEach(attributeName => {
        queryBuilder.orderBy({
          attribute: attributeName,
          direction: "DESC"
        });
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    ROW_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    CREATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "ASC"
      });
    },
    CREATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "created_at",
        direction: "DESC"
      });
    },
    UPDATED_AT_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "ASC"
      });
    },
    UPDATED_AT_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "updated_at",
        direction: "DESC"
      });
    },
    HIDRA_ID_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "hidra_id",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    HIDRA_ID_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "hidra_id",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    USERNAME_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "username",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    USERNAME_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "username",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    FIRST_NAME_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "first_name",
        direction: "ASC"
      });
    },
    FIRST_NAME_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "first_name",
        direction: "DESC"
      });
    },
    LAST_NAME_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "last_name",
        direction: "ASC"
      });
    },
    LAST_NAME_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "last_name",
        direction: "DESC"
      });
    },
    EMAIL_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "email",
        direction: "ASC"
      });
      queryBuilder.setOrderIsUnique();
    },
    EMAIL_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "email",
        direction: "DESC"
      });
      queryBuilder.setOrderIsUnique();
    },
    TIER_ASC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "tier",
        direction: "ASC"
      });
    },
    TIER_DESC(queryBuilder) {
      queryBuilder.orderBy({
        attribute: "tier",
        direction: "DESC"
      });
    },
    POSTS_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    POSTS_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_post.attributes.id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.id.codec) ?? spec_post.attributes.id.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_post.attributes.id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.id.codec) ?? spec_post.attributes.id.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_TITLE_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("title")}`, spec_post.attributes.title.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.title.codec) ?? spec_post.attributes.title.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_TITLE_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("title")}`, spec_post.attributes.title.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.title.codec) ?? spec_post.attributes.title.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_DESCRIPTION_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_post.attributes.description.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.description.codec) ?? spec_post.attributes.description.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_DESCRIPTION_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("description")}`, spec_post.attributes.description.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.description.codec) ?? spec_post.attributes.description.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_PROJECT_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_post.attributes.project_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.project_id.codec) ?? spec_post.attributes.project_id.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_PROJECT_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("project_id")}`, spec_post.attributes.project_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.project_id.codec) ?? spec_post.attributes.project_id.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_USER_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_post.attributes.user_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.user_id.codec) ?? spec_post.attributes.user_id.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_USER_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_post.attributes.user_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.user_id.codec) ?? spec_post.attributes.user_id.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_post.attributes.created_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.created_at.codec) ?? spec_post.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_post.attributes.created_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.created_at.codec) ?? spec_post.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_post.attributes.updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.updated_at.codec) ?? spec_post.attributes.updated_at.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_post.attributes.updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.updated_at.codec) ?? spec_post.attributes.updated_at.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_STATUS_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_id")}`, spec_post.attributes.status_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.status_id.codec) ?? spec_post.attributes.status_id.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_STATUS_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_id")}`, spec_post.attributes.status_id.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.status_id.codec) ?? spec_post.attributes.status_id.codec,
        direction: "DESC"
      });
    },
    POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_updated_at")}`, spec_post.attributes.status_updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.status_updated_at.codec) ?? spec_post.attributes.status_updated_at.codec,
        direction: "ASC"
      });
    },
    POSTS_DISTINCT_COUNT_STATUS_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_postPgResource.name));
      relation11.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation11.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_postPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("status_updated_at")}`, spec_post.attributes.status_updated_at.codec)}
from ${resource_postPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_post.attributes.status_updated_at.codec) ?? spec_post.attributes.status_updated_at.codec,
        direction: "DESC"
      });
    },
    UPVOTES_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation12.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation12.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    UPVOTES_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation12.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation12.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    UPVOTES_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation12.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation12.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_upvote.attributes.id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.id.codec) ?? spec_upvote.attributes.id.codec,
        direction: "ASC"
      });
    },
    UPVOTES_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation12.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation12.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_upvote.attributes.id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.id.codec) ?? spec_upvote.attributes.id.codec,
        direction: "DESC"
      });
    },
    UPVOTES_DISTINCT_COUNT_POST_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation12.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation12.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_upvote.attributes.post_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.post_id.codec) ?? spec_upvote.attributes.post_id.codec,
        direction: "ASC"
      });
    },
    UPVOTES_DISTINCT_COUNT_POST_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation12.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation12.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_upvote.attributes.post_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.post_id.codec) ?? spec_upvote.attributes.post_id.codec,
        direction: "DESC"
      });
    },
    UPVOTES_DISTINCT_COUNT_USER_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation12.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation12.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_upvote.attributes.user_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.user_id.codec) ?? spec_upvote.attributes.user_id.codec,
        direction: "ASC"
      });
    },
    UPVOTES_DISTINCT_COUNT_USER_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation12.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation12.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_upvote.attributes.user_id.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.user_id.codec) ?? spec_upvote.attributes.user_id.codec,
        direction: "DESC"
      });
    },
    UPVOTES_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation12.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation12.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_upvote.attributes.created_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.created_at.codec) ?? spec_upvote.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    UPVOTES_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation12.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation12.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_upvote.attributes.created_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.created_at.codec) ?? spec_upvote.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    UPVOTES_DISTINCT_COUNT_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation12.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation12.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_upvote.attributes.updated_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.updated_at.codec) ?? spec_upvote.attributes.updated_at.codec,
        direction: "ASC"
      });
    },
    UPVOTES_DISTINCT_COUNT_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_upvotePgResource.name));
      relation12.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation12.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_upvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_upvote.attributes.updated_at.codec)}
from ${resource_upvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_upvote.attributes.updated_at.codec) ?? spec_upvote.attributes.updated_at.codec,
        direction: "DESC"
      });
    },
    MEMBERS_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation13.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation13.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    MEMBERS_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation13.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation13.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    MEMBERS_DISTINCT_COUNT_USER_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation13.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation13.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_member.attributes.user_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.user_id.codec) ?? spec_member.attributes.user_id.codec,
        direction: "ASC"
      });
    },
    MEMBERS_DISTINCT_COUNT_USER_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation13.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation13.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_member.attributes.user_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.user_id.codec) ?? spec_member.attributes.user_id.codec,
        direction: "DESC"
      });
    },
    MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation13.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation13.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_member.attributes.organization_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.organization_id.codec) ?? spec_member.attributes.organization_id.codec,
        direction: "ASC"
      });
    },
    MEMBERS_DISTINCT_COUNT_ORGANIZATION_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation13.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation13.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("organization_id")}`, spec_member.attributes.organization_id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.organization_id.codec) ?? spec_member.attributes.organization_id.codec,
        direction: "DESC"
      });
    },
    MEMBERS_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation13.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation13.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_member.attributes.created_at.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.created_at.codec) ?? spec_member.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    MEMBERS_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation13.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation13.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_member.attributes.created_at.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.created_at.codec) ?? spec_member.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    MEMBERS_DISTINCT_COUNT_ROLE_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation13.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation13.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("role")}`, spec_member.attributes.role.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.role.codec) ?? spec_member.attributes.role.codec,
        direction: "ASC"
      });
    },
    MEMBERS_DISTINCT_COUNT_ROLE_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation13.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation13.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("role")}`, spec_member.attributes.role.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.role.codec) ?? spec_member.attributes.role.codec,
        direction: "DESC"
      });
    },
    MEMBERS_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation13.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation13.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_member.attributes.id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.id.codec) ?? spec_member.attributes.id.codec,
        direction: "ASC"
      });
    },
    MEMBERS_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_memberPgResource.name));
      relation13.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation13.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_memberPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_member.attributes.id.codec)}
from ${resource_memberPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_member.attributes.id.codec) ?? spec_member.attributes.id.codec,
        direction: "DESC"
      });
    },
    COMMENTS_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    COMMENTS_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    COMMENTS_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_comment.attributes.id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.id.codec) ?? spec_comment.attributes.id.codec,
        direction: "ASC"
      });
    },
    COMMENTS_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_comment.attributes.id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.id.codec) ?? spec_comment.attributes.id.codec,
        direction: "DESC"
      });
    },
    COMMENTS_DISTINCT_COUNT_MESSAGE_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("message")}`, spec_comment.attributes.message.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.message.codec) ?? spec_comment.attributes.message.codec,
        direction: "ASC"
      });
    },
    COMMENTS_DISTINCT_COUNT_MESSAGE_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("message")}`, spec_comment.attributes.message.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.message.codec) ?? spec_comment.attributes.message.codec,
        direction: "DESC"
      });
    },
    COMMENTS_DISTINCT_COUNT_POST_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_comment.attributes.post_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.post_id.codec) ?? spec_comment.attributes.post_id.codec,
        direction: "ASC"
      });
    },
    COMMENTS_DISTINCT_COUNT_POST_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_comment.attributes.post_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.post_id.codec) ?? spec_comment.attributes.post_id.codec,
        direction: "DESC"
      });
    },
    COMMENTS_DISTINCT_COUNT_USER_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_comment.attributes.user_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.user_id.codec) ?? spec_comment.attributes.user_id.codec,
        direction: "ASC"
      });
    },
    COMMENTS_DISTINCT_COUNT_USER_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_comment.attributes.user_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.user_id.codec) ?? spec_comment.attributes.user_id.codec,
        direction: "DESC"
      });
    },
    COMMENTS_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_comment.attributes.created_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.created_at.codec) ?? spec_comment.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    COMMENTS_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_comment.attributes.created_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.created_at.codec) ?? spec_comment.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    COMMENTS_DISTINCT_COUNT_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_comment.attributes.updated_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.updated_at.codec) ?? spec_comment.attributes.updated_at.codec,
        direction: "ASC"
      });
    },
    COMMENTS_DISTINCT_COUNT_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_comment.attributes.updated_at.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.updated_at.codec) ?? spec_comment.attributes.updated_at.codec,
        direction: "DESC"
      });
    },
    COMMENTS_DISTINCT_COUNT_PARENT_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("parent_id")}`, spec_comment.attributes.parent_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.parent_id.codec) ?? spec_comment.attributes.parent_id.codec,
        direction: "ASC"
      });
    },
    COMMENTS_DISTINCT_COUNT_PARENT_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_commentPgResource.name));
      relation14.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation14.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_commentPgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("parent_id")}`, spec_comment.attributes.parent_id.codec)}
from ${resource_commentPgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_comment.attributes.parent_id.codec) ?? spec_comment.attributes.parent_id.codec,
        direction: "DESC"
      });
    },
    DOWNVOTES_COUNT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation15.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation15.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "ASC"
      });
    },
    DOWNVOTES_COUNT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation15.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation15.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`select count(*)
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.parens(sql.join(conditions.map(c => sql.parens(c)), " AND "))}`})`;
      $select.orderBy({
        fragment,
        codec: TYPES.bigint,
        direction: "DESC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_ROW_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation15.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation15.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_downvote.attributes.id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.id.codec) ?? spec_downvote.attributes.id.codec,
        direction: "ASC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_ROW_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation15.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation15.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("id")}`, spec_downvote.attributes.id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.id.codec) ?? spec_downvote.attributes.id.codec,
        direction: "DESC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_POST_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation15.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation15.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_downvote.attributes.post_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.post_id.codec) ?? spec_downvote.attributes.post_id.codec,
        direction: "ASC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_POST_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation15.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation15.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("post_id")}`, spec_downvote.attributes.post_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.post_id.codec) ?? spec_downvote.attributes.post_id.codec,
        direction: "DESC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_USER_ID_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation15.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation15.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_downvote.attributes.user_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.user_id.codec) ?? spec_downvote.attributes.user_id.codec,
        direction: "ASC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_USER_ID_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation15.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation15.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("user_id")}`, spec_downvote.attributes.user_id.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.user_id.codec) ?? spec_downvote.attributes.user_id.codec,
        direction: "DESC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_CREATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation15.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation15.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_downvote.attributes.created_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.created_at.codec) ?? spec_downvote.attributes.created_at.codec,
        direction: "ASC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_CREATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation15.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation15.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("created_at")}`, spec_downvote.attributes.created_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.created_at.codec) ?? spec_downvote.attributes.created_at.codec,
        direction: "DESC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_ASC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation15.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation15.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_downvote.attributes.updated_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.updated_at.codec) ?? spec_downvote.attributes.updated_at.codec,
        direction: "ASC"
      });
    },
    DOWNVOTES_DISTINCT_COUNT_UPDATED_AT_DESC($select) {
      const foreignTableAlias = $select.alias,
        conditions = [],
        tableAlias = sql.identifier(Symbol(resource_downvotePgResource.name));
      relation15.localAttributes.forEach((localAttribute, i) => {
        const remoteAttribute = relation15.remoteAttributes[i];
        conditions.push(sql.fragment`${tableAlias}.${sql.identifier(remoteAttribute)} = ${foreignTableAlias}.${sql.identifier(localAttribute)}`);
      });
      if (typeof resource_downvotePgResource.from === "function") throw new Error("Function source unsupported");
      const fragment = sql`(${sql.indent`
select ${spec.sqlAggregateWrap(sql.fragment`${tableAlias}.${sql.identifier("updated_at")}`, spec_downvote.attributes.updated_at.codec)}
from ${resource_downvotePgResource.from} ${tableAlias}
where ${sql.join(conditions.map(c => sql.parens(c)), " AND ")}`})`;
      $select.orderBy({
        fragment,
        codec: spec.pgTypeCodecModifier?.(spec_downvote.attributes.updated_at.codec) ?? spec_downvote.attributes.updated_at.codec,
        direction: "DESC"
      });
    }
  },
  Mutation: {
    __assertStep: __ValueStep,
    createDownvote: {
      plan(_, args) {
        const $insert = pgInsertSingle(resource_downvotePgResource, Object.create(null));
        args.apply($insert);
        return object({
          result: $insert
        });
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    createUpvote: {
      plan(_, args) {
        const $insert = pgInsertSingle(resource_upvotePgResource, Object.create(null));
        args.apply($insert);
        return object({
          result: $insert
        });
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    createInvitation: {
      plan(_, args) {
        const $insert = pgInsertSingle(resource_invitationPgResource, Object.create(null));
        args.apply($insert);
        return object({
          result: $insert
        });
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    createOrganization: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"createOrganization"}, but that function did not return a step!
${String(oldPlan)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    createComment: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan2(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"createComment"}, but that function did not return a step!
${String(oldPlan2)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper2(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    createProject: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan3(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"createProject"}, but that function did not return a step!
${String(oldPlan3)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper3(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    createMember: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan4(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"createMember"}, but that function did not return a step!
${String(oldPlan4)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper4(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    createPost: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan5(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"createPost"}, but that function did not return a step!
${String(oldPlan5)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper5(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    createPostStatus: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan6(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"createPostStatus"}, but that function did not return a step!
${String(oldPlan6)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper6(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    createUser: {
      plan(_, args) {
        const $insert = pgInsertSingle(resource_userPgResource, Object.create(null));
        args.apply($insert);
        return object({
          result: $insert
        });
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    updateDownvote: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan7(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updateDownvote"}, but that function did not return a step!
${String(oldPlan7)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper7(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    updateUpvote: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan8(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updateUpvote"}, but that function did not return a step!
${String(oldPlan8)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper8(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    updateInvitation: {
      plan(_$root, args) {
        const $update = pgUpdateSingle(resource_invitationPgResource, {
          id: args.getRaw(['input', "rowId"])
        });
        args.apply($update);
        return object({
          result: $update
        });
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    updateOrganization: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan9(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updateOrganization"}, but that function did not return a step!
${String(oldPlan9)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper9(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    updateComment: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan10(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updateComment"}, but that function did not return a step!
${String(oldPlan10)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper10(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    updateProject: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan11(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updateProject"}, but that function did not return a step!
${String(oldPlan11)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper11(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    updateMember: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan12(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updateMember"}, but that function did not return a step!
${String(oldPlan12)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper12(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    updatePost: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan13(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updatePost"}, but that function did not return a step!
${String(oldPlan13)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper13(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    updatePostStatus: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan14(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updatePostStatus"}, but that function did not return a step!
${String(oldPlan14)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper14(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    updateUser: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan15(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"updateUser"}, but that function did not return a step!
${String(oldPlan15)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper15(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    deleteDownvote: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan16(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deleteDownvote"}, but that function did not return a step!
${String(oldPlan16)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper16(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    deleteUpvote: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan17(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deleteUpvote"}, but that function did not return a step!
${String(oldPlan17)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper17(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    deleteInvitation: {
      plan(_$root, args) {
        const $delete = pgDeleteSingle(resource_invitationPgResource, {
          id: args.getRaw(['input', "rowId"])
        });
        args.apply($delete);
        return object({
          result: $delete
        });
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    deleteOrganization: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan18(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deleteOrganization"}, but that function did not return a step!
${String(oldPlan18)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper18(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    deleteComment: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan19(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deleteComment"}, but that function did not return a step!
${String(oldPlan19)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper19(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    deleteProject: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan20(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deleteProject"}, but that function did not return a step!
${String(oldPlan20)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper20(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    deleteMember: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan21(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deleteMember"}, but that function did not return a step!
${String(oldPlan21)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper21(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    deletePost: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan22(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deletePost"}, but that function did not return a step!
${String(oldPlan22)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper22(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    deletePostStatus: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan23(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deletePostStatus"}, but that function did not return a step!
${String(oldPlan23)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper23(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    },
    deleteUser: {
      plan(...planParams) {
        const smartPlan = (...overrideParams) => {
            const $prev = oldPlan24(...overrideParams.concat(planParams.slice(overrideParams.length)));
            if (!($prev instanceof ExecutableStep)) {
              console.error(`Wrapped a plan function at ${"Mutation"}.${"deleteUser"}, but that function did not return a step!
${String(oldPlan24)}`);
              throw new Error("Wrapped a plan function, but that function did not return a step!");
            }
            return $prev;
          },
          [$source, fieldArgs, info] = planParams,
          $newPlan = planWrapper24(smartPlan, $source, fieldArgs, info);
        if ($newPlan === void 0) throw new Error("Your plan wrapper didn't return anything; it must return a step or null!");
        if ($newPlan !== null && !isExecutableStep($newPlan)) throw new Error(`Your plan wrapper returned something other than a step... It must return a step (or null). (Returned: ${inspect($newPlan)})`);
        return $newPlan;
      },
      args: {
        input(_, $object) {
          return $object;
        }
      }
    }
  },
  CreateDownvotePayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    downvote($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    downvoteEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = downvoteUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_downvotePgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  CreateDownvoteInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    downvote(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  DownvoteInput: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    postId(obj, val, {
      field,
      schema
    }) {
      obj.set("post_id", bakedInputRuntime(schema, field.type, val));
    },
    userId(obj, val, {
      field,
      schema
    }) {
      obj.set("user_id", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    }
  },
  CreateUpvotePayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    upvote($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    upvoteEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = upvoteUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_upvotePgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  CreateUpvoteInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    upvote(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  UpvoteInput: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    postId(obj, val, {
      field,
      schema
    }) {
      obj.set("post_id", bakedInputRuntime(schema, field.type, val));
    },
    userId(obj, val, {
      field,
      schema
    }) {
      obj.set("user_id", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    }
  },
  CreateInvitationPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    invitation($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    invitationEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = invitationUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_invitationPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  CreateInvitationInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    invitation(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  InvitationInput: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    organizationId(obj, val, {
      field,
      schema
    }) {
      obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
    },
    email(obj, val, {
      field,
      schema
    }) {
      obj.set("email", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    }
  },
  CreateOrganizationPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    organization($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    organizationEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = organizationUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_organizationPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  CreateOrganizationInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    organization(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  OrganizationInput: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    name(obj, val, {
      field,
      schema
    }) {
      obj.set("name", bakedInputRuntime(schema, field.type, val));
    },
    slug(obj, val, {
      field,
      schema
    }) {
      obj.set("slug", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    }
  },
  CreateCommentPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    comment($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    commentEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = commentUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_commentPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  CreateCommentInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    comment(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  CommentInput: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    message(obj, val, {
      field,
      schema
    }) {
      obj.set("message", bakedInputRuntime(schema, field.type, val));
    },
    postId(obj, val, {
      field,
      schema
    }) {
      obj.set("post_id", bakedInputRuntime(schema, field.type, val));
    },
    userId(obj, val, {
      field,
      schema
    }) {
      obj.set("user_id", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    },
    parentId(obj, val, {
      field,
      schema
    }) {
      obj.set("parent_id", bakedInputRuntime(schema, field.type, val));
    }
  },
  CreateProjectPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    project($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    projectEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = projectUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_projectPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  CreateProjectInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    project(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  ProjectInput: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    name(obj, val, {
      field,
      schema
    }) {
      obj.set("name", bakedInputRuntime(schema, field.type, val));
    },
    image(obj, val, {
      field,
      schema
    }) {
      obj.set("image", bakedInputRuntime(schema, field.type, val));
    },
    slug(obj, val, {
      field,
      schema
    }) {
      obj.set("slug", bakedInputRuntime(schema, field.type, val));
    },
    description(obj, val, {
      field,
      schema
    }) {
      obj.set("description", bakedInputRuntime(schema, field.type, val));
    },
    organizationId(obj, val, {
      field,
      schema
    }) {
      obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    }
  },
  CreateMemberPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    member($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    memberEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = memberUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_memberPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  CreateMemberInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    member(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  MemberInput: {
    __baked: createObjectAndApplyChildren,
    userId(obj, val, {
      field,
      schema
    }) {
      obj.set("user_id", bakedInputRuntime(schema, field.type, val));
    },
    organizationId(obj, val, {
      field,
      schema
    }) {
      obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    role(obj, val, {
      field,
      schema
    }) {
      obj.set("role", bakedInputRuntime(schema, field.type, val));
    },
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    }
  },
  CreatePostPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    post($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    postEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = postUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_postPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  CreatePostInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    post(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  PostInput: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    title(obj, val, {
      field,
      schema
    }) {
      obj.set("title", bakedInputRuntime(schema, field.type, val));
    },
    description(obj, val, {
      field,
      schema
    }) {
      obj.set("description", bakedInputRuntime(schema, field.type, val));
    },
    projectId(obj, val, {
      field,
      schema
    }) {
      obj.set("project_id", bakedInputRuntime(schema, field.type, val));
    },
    userId(obj, val, {
      field,
      schema
    }) {
      obj.set("user_id", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    },
    statusId(obj, val, {
      field,
      schema
    }) {
      obj.set("status_id", bakedInputRuntime(schema, field.type, val));
    },
    statusUpdatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("status_updated_at", bakedInputRuntime(schema, field.type, val));
    }
  },
  CreatePostStatusPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    postStatus($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    postStatusEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = post_statusUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_post_statusPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  CreatePostStatusInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    postStatus(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  PostStatusInput: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    status(obj, val, {
      field,
      schema
    }) {
      obj.set("status", bakedInputRuntime(schema, field.type, val));
    },
    description(obj, val, {
      field,
      schema
    }) {
      obj.set("description", bakedInputRuntime(schema, field.type, val));
    },
    color(obj, val, {
      field,
      schema
    }) {
      obj.set("color", bakedInputRuntime(schema, field.type, val));
    },
    projectId(obj, val, {
      field,
      schema
    }) {
      obj.set("project_id", bakedInputRuntime(schema, field.type, val));
    },
    isDefault(obj, val, {
      field,
      schema
    }) {
      obj.set("is_default", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    }
  },
  CreateUserPayload: {
    __assertStep: assertExecutableStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    user($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    userEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = userUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_userPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  CreateUserInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    user(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  UserInput: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    },
    hidraId(obj, val, {
      field,
      schema
    }) {
      obj.set("hidra_id", bakedInputRuntime(schema, field.type, val));
    },
    username(obj, val, {
      field,
      schema
    }) {
      obj.set("username", bakedInputRuntime(schema, field.type, val));
    },
    firstName(obj, val, {
      field,
      schema
    }) {
      obj.set("first_name", bakedInputRuntime(schema, field.type, val));
    },
    lastName(obj, val, {
      field,
      schema
    }) {
      obj.set("last_name", bakedInputRuntime(schema, field.type, val));
    },
    email(obj, val, {
      field,
      schema
    }) {
      obj.set("email", bakedInputRuntime(schema, field.type, val));
    }
  },
  UpdateDownvotePayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    downvote($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    downvoteEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = downvoteUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_downvotePgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  UpdateDownvoteInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    patch(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  DownvotePatch: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    postId(obj, val, {
      field,
      schema
    }) {
      obj.set("post_id", bakedInputRuntime(schema, field.type, val));
    },
    userId(obj, val, {
      field,
      schema
    }) {
      obj.set("user_id", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    }
  },
  UpdateUpvotePayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    upvote($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    upvoteEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = upvoteUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_upvotePgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  UpdateUpvoteInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    patch(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  UpvotePatch: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    postId(obj, val, {
      field,
      schema
    }) {
      obj.set("post_id", bakedInputRuntime(schema, field.type, val));
    },
    userId(obj, val, {
      field,
      schema
    }) {
      obj.set("user_id", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    }
  },
  UpdateInvitationPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    invitation($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    invitationEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = invitationUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_invitationPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  UpdateInvitationInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    patch(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  InvitationPatch: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    organizationId(obj, val, {
      field,
      schema
    }) {
      obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
    },
    email(obj, val, {
      field,
      schema
    }) {
      obj.set("email", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    }
  },
  UpdateOrganizationPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    organization($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    organizationEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = organizationUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_organizationPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  UpdateOrganizationInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    patch(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  OrganizationPatch: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    name(obj, val, {
      field,
      schema
    }) {
      obj.set("name", bakedInputRuntime(schema, field.type, val));
    },
    slug(obj, val, {
      field,
      schema
    }) {
      obj.set("slug", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    }
  },
  UpdateCommentPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    comment($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    commentEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = commentUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_commentPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  UpdateCommentInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    patch(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  CommentPatch: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    message(obj, val, {
      field,
      schema
    }) {
      obj.set("message", bakedInputRuntime(schema, field.type, val));
    },
    postId(obj, val, {
      field,
      schema
    }) {
      obj.set("post_id", bakedInputRuntime(schema, field.type, val));
    },
    userId(obj, val, {
      field,
      schema
    }) {
      obj.set("user_id", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    },
    parentId(obj, val, {
      field,
      schema
    }) {
      obj.set("parent_id", bakedInputRuntime(schema, field.type, val));
    }
  },
  UpdateProjectPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    project($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    projectEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = projectUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_projectPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  UpdateProjectInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    patch(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  ProjectPatch: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    name(obj, val, {
      field,
      schema
    }) {
      obj.set("name", bakedInputRuntime(schema, field.type, val));
    },
    image(obj, val, {
      field,
      schema
    }) {
      obj.set("image", bakedInputRuntime(schema, field.type, val));
    },
    slug(obj, val, {
      field,
      schema
    }) {
      obj.set("slug", bakedInputRuntime(schema, field.type, val));
    },
    description(obj, val, {
      field,
      schema
    }) {
      obj.set("description", bakedInputRuntime(schema, field.type, val));
    },
    organizationId(obj, val, {
      field,
      schema
    }) {
      obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    }
  },
  UpdateMemberPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    member($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    memberEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = memberUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_memberPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  UpdateMemberInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    patch(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  MemberPatch: {
    __baked: createObjectAndApplyChildren,
    userId(obj, val, {
      field,
      schema
    }) {
      obj.set("user_id", bakedInputRuntime(schema, field.type, val));
    },
    organizationId(obj, val, {
      field,
      schema
    }) {
      obj.set("organization_id", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    role(obj, val, {
      field,
      schema
    }) {
      obj.set("role", bakedInputRuntime(schema, field.type, val));
    },
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    }
  },
  UpdatePostPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    post($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    postEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = postUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_postPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  UpdatePostInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    patch(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  PostPatch: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    title(obj, val, {
      field,
      schema
    }) {
      obj.set("title", bakedInputRuntime(schema, field.type, val));
    },
    description(obj, val, {
      field,
      schema
    }) {
      obj.set("description", bakedInputRuntime(schema, field.type, val));
    },
    projectId(obj, val, {
      field,
      schema
    }) {
      obj.set("project_id", bakedInputRuntime(schema, field.type, val));
    },
    userId(obj, val, {
      field,
      schema
    }) {
      obj.set("user_id", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    },
    statusId(obj, val, {
      field,
      schema
    }) {
      obj.set("status_id", bakedInputRuntime(schema, field.type, val));
    },
    statusUpdatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("status_updated_at", bakedInputRuntime(schema, field.type, val));
    }
  },
  UpdatePostStatusPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    postStatus($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    postStatusEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = post_statusUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_post_statusPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  UpdatePostStatusInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    patch(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  PostStatusPatch: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    status(obj, val, {
      field,
      schema
    }) {
      obj.set("status", bakedInputRuntime(schema, field.type, val));
    },
    description(obj, val, {
      field,
      schema
    }) {
      obj.set("description", bakedInputRuntime(schema, field.type, val));
    },
    color(obj, val, {
      field,
      schema
    }) {
      obj.set("color", bakedInputRuntime(schema, field.type, val));
    },
    projectId(obj, val, {
      field,
      schema
    }) {
      obj.set("project_id", bakedInputRuntime(schema, field.type, val));
    },
    isDefault(obj, val, {
      field,
      schema
    }) {
      obj.set("is_default", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    }
  },
  UpdateUserPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    user($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    userEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = userUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_userPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  UpdateUserInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    },
    patch(qb, arg) {
      if (arg != null) return qb.setBuilder();
    }
  },
  UserPatch: {
    __baked: createObjectAndApplyChildren,
    rowId(obj, val, {
      field,
      schema
    }) {
      obj.set("id", bakedInputRuntime(schema, field.type, val));
    },
    createdAt(obj, val, {
      field,
      schema
    }) {
      obj.set("created_at", bakedInputRuntime(schema, field.type, val));
    },
    updatedAt(obj, val, {
      field,
      schema
    }) {
      obj.set("updated_at", bakedInputRuntime(schema, field.type, val));
    },
    hidraId(obj, val, {
      field,
      schema
    }) {
      obj.set("hidra_id", bakedInputRuntime(schema, field.type, val));
    },
    username(obj, val, {
      field,
      schema
    }) {
      obj.set("username", bakedInputRuntime(schema, field.type, val));
    },
    firstName(obj, val, {
      field,
      schema
    }) {
      obj.set("first_name", bakedInputRuntime(schema, field.type, val));
    },
    lastName(obj, val, {
      field,
      schema
    }) {
      obj.set("last_name", bakedInputRuntime(schema, field.type, val));
    },
    email(obj, val, {
      field,
      schema
    }) {
      obj.set("email", bakedInputRuntime(schema, field.type, val));
    }
  },
  DeleteDownvotePayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    downvote($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    downvoteEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = downvoteUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_downvotePgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  DeleteDownvoteInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    }
  },
  DeleteUpvotePayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    upvote($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    upvoteEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = upvoteUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_upvotePgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  DeleteUpvoteInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    }
  },
  DeleteInvitationPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    invitation($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    invitationEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = invitationUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_invitationPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  DeleteInvitationInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    }
  },
  DeleteOrganizationPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    organization($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    organizationEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = organizationUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_organizationPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  DeleteOrganizationInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    }
  },
  DeleteCommentPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    comment($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    commentEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = commentUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_commentPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  DeleteCommentInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    }
  },
  DeleteProjectPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    project($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    projectEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = projectUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_projectPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  DeleteProjectInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    }
  },
  DeleteMemberPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    member($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    memberEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = memberUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_memberPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  DeleteMemberInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    }
  },
  DeletePostPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    post($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    postEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = postUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_postPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  DeletePostInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    }
  },
  DeletePostStatusPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    postStatus($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    postStatusEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = post_statusUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_post_statusPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  DeletePostStatusInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    }
  },
  DeleteUserPayload: {
    __assertStep: ObjectStep,
    clientMutationId($mutation) {
      return $mutation.getStepForKey("result").getMeta("clientMutationId");
    },
    user($object) {
      return $object.get("result");
    },
    query() {
      return rootValue();
    },
    userEdge($mutation, fieldArgs) {
      const $result = $mutation.getStepForKey("result", !0);
      if (!$result) return constant(null);
      const $select = (() => {
        if ($result instanceof PgDeleteSingleStep) return pgSelectFromRecord($result.resource, $result.record());else {
          const spec = userUniques[0].attributes.reduce((memo, attributeName) => {
            memo[attributeName] = $result.get(attributeName);
            return memo;
          }, Object.create(null));
          return resource_userPgResource.find(spec);
        }
      })();
      fieldArgs.apply($select, "orderBy");
      const $connection = connection($select),
        $single = $select.row(first($select));
      return new EdgeStep($connection, $single);
    }
  },
  DeleteUserInput: {
    clientMutationId(qb, val) {
      qb.setMeta("clientMutationId", val);
    }
  }
};
export const schema = makeGrafastSchema({
  typeDefs: typeDefs,
  plans: plans
});